<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Category: JavaScript | 锁越smile</title>
  <meta name="description" content="保持乐观，保持谦虚" />
  <meta name="keywords" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/">
  <link rel="alternate" href="/atom.xml" title="锁越smile">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="保持乐观，保持谦虚">
<meta property="og:type" content="website">
<meta property="og:title" content="锁越smile">
<meta property="og:url" content="http://yoursite.com/categories/JavaScript/index.html">
<meta property="og:site_name" content="锁越smile">
<meta property="og:description" content="保持乐观，保持谦虚">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="锁越smile">
<meta name="twitter:description" content="保持乐观，保持谦虚">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  <link rel="stylesheet" href="/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>

<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/' >
				锁越smile
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/'>
								Home
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/archives'>
								Archives
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-gallery' href='https://photos.google.com/album/AF1QipNoqKYgspQo5O1YhlFXGCQ7p575KBH3Yxf8WHL4?hl=zh-CN'>
								Gallery
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-about' href='/about'>
								About
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search flat-box"></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu flat-box"></span></a></li>
			</ul>
		</div>
		
		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				Word of Forks
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><span class="icon icon-chat_bubble_outline flat-box"></span></a></li>
				<li class='s-top'><a href='javascript:void(0)'><span class="icon icon-arrow_upward flat-box"></span></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><span class="icon icon-format_list_numbered flat-box"></span></a></li>
			</ul>
		</div>
	</div>
</header>
<aside class="menu-phone">
	<nav>
		
			<a href="/" class="nav-home nav">
				Home
			</a>
		
			<a href="/archives" class="nav-archives nav">
				Archives
			</a>
		
			<a href="https://photos.google.com/album/AF1QipNoqKYgspQo5O1YhlFXGCQ7p575KBH3Yxf8WHL4?hl=zh-CN" class="nav-gallery nav">
				Gallery
			</a>
		
			<a href="/about" class="nav-about nav">
				About
			</a>
		
	</nav>
</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        
  <script>
    window.subData= { title:'Category : JavaScript'}
  </script>

<section class="post-list">
	
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2017/03/13/t-book_jq_001/">
        框架初探：jQuery 初体验
      </a>
    </h2>
    
    <time>
      Mar 13, 2017
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <p>学过一段时间，也用过一段时间 JavaScript，总感觉原生的 JS 需要处理太多的兼容问题。有没有一个好的工具，把这些麻烦事件都给封装起来。当然是有的，自从用了 jQuery， 代码敲得少了，处理的事情却更多。现在写一个入门的博客，以便以后翻阅。</p>
<h3 id="jQuery-是啥"><a href="#jQuery-是啥" class="headerlink" title="jQuery 是啥"></a>jQuery 是啥</h3><p>jQuery 本身是很小型框架的，这个有点像我们学习 C++ 中的 STL (标准模板库)，简单来说就是大神们帮我们把一些复杂的实现逻辑封装成一个函数或者类直接供我们来用。其中也考虑了健壮性和兼容性以及性能问题，真的是很好很方便的工具。就让我站在巨人们的身上敲代码吧。</p>
<h3 id="jQuery-原理"><a href="#jQuery-原理" class="headerlink" title="jQuery 原理"></a>jQuery 原理</h3><p>jQuery3.0.0 现在采用的是 ES5 语法并没有采用 ES6 语法的,而且全部采用的是严格模式，我仔细看了下未压缩源码总共有 10038 行，规模还算不小。<br>但是整体的结构的设计变化不大。</p>
<p>jQuery 的核心是一个 <strong>立即执行的匿名函数</strong>，接收两个参数，一个是 <code>global</code> 对象，一个是 <code>factory</code> 的函数对象。<br>下面是它的核心的源码结构，核心函数是507行完，大部分代码其实是在扩展里面<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">( <span class="function"><span class="keyword">function</span>(<span class="params"> global, factory </span>) </span>&#123;</span><br><span class="line">    <span class="string">"using strict"</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">"object"</span> ) &#123;</span><br><span class="line">        <span class="comment">// 定义模块对象</span></span><br><span class="line">        <span class="built_in">module</span>.exports = global.document ?</span><br><span class="line">            factory( global, <span class="literal">true</span> ) :</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params"> w </span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> ( !w.document ) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">"jQuery requires a window with a document"</span> );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> factory( w );</span><br><span class="line">            &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        factory( global );</span><br><span class="line">    &#125;</span><br><span class="line">&#125; )( <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span> ? <span class="built_in">window</span> : <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> window, noGlobal </span>) </span>&#123;</span><br><span class="line">    <span class="string">"using strict"</span>;</span><br><span class="line">    <span class="comment">// 代码</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure></p>
<p>这段代码的主要作用是判断 <code>global.document</code> 是否存在，不存在就抛出错误，存在就定义的模块为传进来的 <code>factory</code> 对象。<br>所以其实真正的操作全在 <code>factory</code> 的函数里。<br>比较在意的是 jQuery 的代码风格和我们大多数人平时的风格不一样，松散性太高，有些不习惯</p>
<p>下面我们看看 factory 函数里到底写了些什么呢<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"> window, noGlobal </span>) </span>&#123;</span><br><span class="line">    <span class="string">"using strict"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">document</span> = <span class="built_in">window</span>.document;</span><br><span class="line">    <span class="keyword">var</span> getProto = <span class="built_in">Object</span>.getPrototypeOf;</span><br><span class="line">    <span class="keyword">var</span> slice = arr.slice;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">    <span class="comment">// 这里是把一些数组的方法作了简化</span></span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        varsion = <span class="string">"3.0.0"</span>,</span><br><span class="line">        jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> jQuery.fn.init( selector, context );</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">        fcamelCase = <span class="function"><span class="keyword">function</span>(<span class="params"> all, letter </span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> letter.toUpperCase();</span><br><span class="line">        &#125;;</span><br><span class="line">    jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;;</span><br><span class="line">    jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这 500 多行整体的结构大致就是这样的，学了 ES5 理解这些代码也不难，它首先处理了基本类型数组的一些方法，然后定义了 jQuery 选择器的方法初始化过程，然后定义 jQuery 的核心方法和原型的调用过程，最后增加了 jQuery 的扩展。具体 10000 多行代码也不细说了。下面看看怎么用吧。</p>
<h3 id="开始用-jQuery"><a href="#开始用-jQuery" class="headerlink" title="开始用 jQuery"></a>开始用 jQuery</h3><p>开始 jQuery 真的很简单</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>两种方式引用<br>1.下载后引用本地库<br>我们到官网下载jQuery的不同版本，然后把文件放到我的项目目录中，供调用<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>jQuery初探测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/jquery-3.0.0.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"test.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我下载的是最新的3.0.0版本，在html引用，后写一个js测试一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure></p>
<p>2.在线直接引用<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>jQuery初探测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.0.0.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"test.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>测试结果相同<br>说明：中间有个 min 是压缩版，就是生产版本，没有的就是开发版本。不同场景使用不同版本，开发版本可以直接修改内容，生产版本已经压缩好了，一般就是直接用于产品了。</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>选择一个元素或者元素集合，对选中的元素进行操作，比如<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>jQuery初探测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/jquery-3.0.0.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"test.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>can't see me<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常写法</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"h1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="keyword">this</span>).addClass(<span class="string">"color"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">"h2"</span>).mouseover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="keyword">this</span>).hide();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"h1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="keyword">this</span>).addClass(<span class="string">"color"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">"h2"</span>).mouseover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="keyword">this</span>).hide();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>也可在线测试 <a href="http://runjs.cn/code/agukaw1z" target="_blank" rel="noopener"><strong>jquery在线测试</strong></a></p>
<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>具体全面的使用，参照<a href="http://jquery.cuishifeng.cn/" target="_blank" rel="noopener"><strong>API</strong></a>;<br>我现在一个方面实现几个简单的 demo</p>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>先写一个模板<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"dome"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/jquery.3.0.0.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给body添加css</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="built_in">document</span>.body).css(<span class="string">"color"</span>, <span class="string">"red"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p><code>$(selector, [context])</code>,第一个参数为选择器，第二个对象是可选项，选择器的当前环境<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例1</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 给div p 增加 css</span></span><br><span class="line">    $(<span class="string">"div p"</span>).addCss(<span class="string">"color"</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鼠标移动上去就隐藏</span></span><br><span class="line">    $(<span class="string">"div.myclass"</span>).mouseover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="keyword">this</span>).hide();</span><br><span class="line">    &#125;);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 找到页面中的第一个表单，选择里面的input,点击改变值</span></span><br><span class="line">    $(<span class="string">"input"</span>, <span class="built_in">document</span>.forms[<span class="number">0</span>]).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="keyword">this</span>).attr(<span class="string">"value"</span>, <span class="string">"出来了"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="动态创建"><a href="#动态创建" class="headerlink" title="动态创建"></a>动态创建</h4><p><code>$(html, [ownerdocument])</code>第一个参数为 html 片段，第二个是可选项，为 html 所属文档文档<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个hello的div插入到.hide中</span></span><br><span class="line">$(<span class="string">"&lt;div&gt;&lt;p&gt;hello&lt;/p&gt;&lt;/div&gt;"</span>).appendTo(<span class="string">".hide"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建div元素并声明对象的属性</span></span><br><span class="line">$(<span class="string">"&lt;div&gt;"</span>, &#123;</span><br><span class="line">    <span class="string">"class"</span>: <span class="string">"test"</span>,</span><br><span class="line">    text: <span class="string">"click me"</span>,</span><br><span class="line">    click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="keyword">this</span>).toggleClass(<span class="string">'test'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).appendTo(<span class="string">"body"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个imput</span></span><br><span class="line">$(<span class="string">"&lt;input&gt;"</span>, &#123;</span><br><span class="line">    type: <span class="string">"text"</span>,</span><br><span class="line">    val: <span class="string">"Test"</span>,</span><br><span class="line">    focusin: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="keyword">this</span>).addClass(<span class="string">"active"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    focusout: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="keyword">this</span>).removeClass(<span class="string">"active"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).appendTo(<span class="string">"form"</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><p>简单的使用，jQuery.ajax(url, [setting])<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 发送一个ajax请求</span></span><br><span class="line"><span class="comment">// Ajax</span></span><br><span class="line">  <span class="keyword">var</span> data = $.ajax(&#123;</span><br><span class="line">      type: <span class="string">"get"</span>,</span><br><span class="line">      url: <span class="string">"demo1.php"</span>,</span><br><span class="line">      data: <span class="string">"name=suo&amp;gender=male"</span>,</span><br><span class="line">      asyns: <span class="literal">true</span>,</span><br><span class="line">      cache: <span class="literal">false</span>,</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"good"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;).reponseText;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure></p>
<p>使用AJAX进行跨域请求<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"input[name='username']"</span>).keyup(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> username = $(<span class="keyword">this</span>).val();</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">"http://101.132.34.184/demo/demo1.php"</span>,</span><br><span class="line">            dataType: <span class="string">"json"</span>,</span><br><span class="line">            type: <span class="string">"post"</span>,</span><br><span class="line">            data: &#123; <span class="string">"username"</span>: username &#125;,</span><br><span class="line">            crossDomain: <span class="literal">true</span>,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo/demo1.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">// 允许跨域</span></span><br><span class="line">    header(<span class="string">"Access-Control-Allow-Origin:*"</span>);</span><br><span class="line">    $userDB = [<span class="string">"shaosuo"</span>, <span class="string">"suoyue"</span>, <span class="string">"yue"</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">"username"</span>])) &#123;</span><br><span class="line">        <span class="keyword">if</span>(in_array($_POST[<span class="string">"username"</span>], $userDB)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">php<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><em>还有一些用法，这里不一一测试了，做到这些也算是入门了，多查文档多熟悉语法，jQuery 用熟练了才算真正的好用</em></p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
        <a href="/tags/jQuery/">jQuery</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2016/09/15/t-book_js_0/">
        ECMAScript 6 之 Module
      </a>
    </h2>
    
    <time>
      Sep 15, 2016
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><p>在 ES6 以前，JavaScript 始终没有模块体系，无法将一个大程序拆分成相互依赖的小程序，再用简单的方法拼装起来。而其它语言却都有这样的功能。如 Ruby的<code>require</code>,Python的<code>import</code>,甚至 css 都有<code>@import</code>。因此社区制定了一些模块加载方案，主要有 CommonJS 和 AMD 两种，前者用于服务器，后者用于浏览器。 ES6 在语言标准层面上，实现了模块功能，而且相当简单，完全可以替代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<h4 id="ES6-模块设计思想"><a href="#ES6-模块设计思想" class="headerlink" title="ES6 模块设计思想"></a>ES6 模块设计思想</h4><p>是尽量的静态化，使得编译时就能确定模块之间的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<p>CommonJS 写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; stat, exist, readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exist = _fs.exist;</span><br><span class="line"><span class="keyword">let</span> readFile = _fs.readFile;</span><br></pre></td></tr></table></figure></p>
<p>ES6 模块写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; stat, exist, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure></p>
<p>编译时加载方法，使得静态分析成为可能，效率也更高<br>它的好处</p>
<ul>
<li>不需要 UMD 模块格式，将来服务器和浏览器都会支持</li>
<li>将来浏览器的新 API 就能用模块格式来提供</li>
<li>不再需要对象作为命令空间</li>
</ul>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>ES6 模块自动采用严格模式</p>
<ul>
<li>变量必须声明后使用</li>
<li>函数参数不能同名</li>
<li>不能使用<code>with</code></li>
<li>不能对<code>const</code>变量赋值</li>
<li>不能用<code>0</code>表示八进制</li>
<li>不能删除不可删除属性</li>
<li><code>eval</code>不会在外层作用域引入变量</li>
<li><code>eval</code>和<code>agrgument</code>不能重新赋值</li>
<li>不能使用<code>arguments.callee</code></li>
<li>不能使用<code>arguments.caller</code></li>
<li>禁止<code>this</code>指向全局变量</li>
<li>增加保留字<code>protected</code>, <code>static</code>, <code>interface</code></li>
</ul>
<h4 id="import与export-命令"><a href="#import与export-命令" class="headerlink" title="import与export 命令"></a>import与export 命令</h4><p><code>import</code>和<code>export</code>构成模块的对外接口</p>
<p><strong>1.import</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mian.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;name, gender, age&#125; <span class="keyword">from</span> <span class="string">'./person'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名</span></span><br><span class="line"><span class="keyword">import</span> &#123;name <span class="keyword">as</span> n&#125; <span class="keyword">from</span> <span class="string">'./person'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只加载不输入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./person'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块整体加载</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> person <span class="keyword">from</span> <span class="string">'./person'</span>;</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li>不能使用表达式，静态效果</li>
<li>可以提升到头部</li>
<li>加载两次同样的模块，只执行一次</li>
</ul>
<p><strong>2.export</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单次定义</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name = <span class="string">"suo"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> gender = <span class="string">"male"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量定义</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'suo'</span>;</span><br><span class="line"><span class="keyword">var</span> gender = <span class="string">"male"</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;name, gender, age&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    name <span class="keyword">as</span> n,</span><br><span class="line">    gender <span class="keyword">as</span> g,</span><br><span class="line">    age <span class="keyword">as</span> a</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"><span class="keyword">export</span> &#123; sum &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    sum <span class="keyword">as</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认输出</span></span><br><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</span><br><span class="line">&#125; <span class="comment">// 非匿名也可以</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br><span class="line">foo(); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></p>
<p>注意：后两种就算只有一个变量或者函数也要花括号</p>
<p><strong>3.复合写法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;name, gender&#125; <span class="keyword">from</span> <span class="string">'person'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123;name, gender&#125; <span class="keyword">from</span> <span class="string">'person'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;name, gender&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名</span></span><br><span class="line"><span class="keyword">export</span> &#123;name <span class="keyword">as</span> n&#125; <span class="keyword">from</span> <span class="string">'person'</span>;</span><br><span class="line"><span class="comment">// 整体</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'person'</span>;</span><br><span class="line"><span class="comment">// 默认</span></span><br><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span>&#125; <span class="keyword">from</span> <span class="string">'person'</span>;</span><br><span class="line"><span class="comment">// 具名改默认</span></span><br><span class="line"><span class="keyword">export</span> &#123;name <span class="keyword">as</span> <span class="keyword">default</span>&#125; <span class="keyword">from</span> <span class="string">'person'</span>;</span><br><span class="line"><span class="comment">// 默认改具名</span></span><br><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> name&#125; <span class="keyword">from</span> <span class="string">'person'</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;getName <span class="keyword">as</span> personName&#125; <span class="keyword">from</span> <span class="string">'person'</span>;</span><br><span class="line"><span class="comment">// 输出其中的一部分，并改名</span></span><br></pre></td></tr></table></figure>
<h4 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> B = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">from</span> <span class="string">'main'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test2.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;A, B&#125; <span class="keyword">from</span> <span class="string">'main'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// db.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> db = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span>,</span><br><span class="line">    paw: <span class="string">"suoyue"</span>,</span><br><span class="line">    info: <span class="string">"ok"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// user.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> user = [<span class="string">'suo'</span>, <span class="string">'yue'</span>, <span class="string">'smile'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;db&#125; <span class="keyword">from</span> <span class="string">'db'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;user&#125; <span class="keyword">from</span> <span class="string">'user'</span>;</span><br></pre></td></tr></table></figure>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
        <a href="/tags/ECMAScript6/">ECMAScript6</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2016/09/10/t-book_js_012/">
        ECMAScript 6 之 let 和 const 命令
      </a>
    </h2>
    
    <time>
      Sep 10, 2016
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <p>学习前端有一段时间了，ECMAScript5 也算是掌握的差不多了。经过了这段时间的实践，也从中发现ECMAScript5 有很多不方便的地方。比如只有函数作用域，块级作用域需要模拟，还有面向对象也是不足够的，等等。后来我接触到了 ECMAScript6 果然在这个新版本中，很多 ES5 的遗留问题都得到改善。所以我近期找了一些 ES6 的资料书来学习。其中入门最佳的书籍，要推阮一峰老师的 《ECMAScript 6入门》 了。感谢一峰老师的知识的整理，提升了我学习 ES6 的效率。</p>
<h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><p>类似于<code>var</code>，<strong>只在块中有效。变相的新增了块级作用域有没有</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"suo"</span>;</span><br><span class="line">    <span class="keyword">var</span> gender = <span class="string">"male"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// suo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">//</span></span><br><span class="line"><span class="built_in">console</span>.log(gender); <span class="comment">// yue</span></span><br></pre></td></tr></table></figure></p>
<p><strong>1.适合使用for循环</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="string">"suo"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// suo suo suo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br></pre></td></tr></table></figure></p>
<p>知道注意的地方是，<code>let</code>用在<code>for</code>循环中是输出了三次<code>suo</code>，说明<code>for</code>中的两个<code>let</code>的作用域也不一样</p>
<p><strong>2.不存在变量声明提升</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"suo"</span>;</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: name is not defined</span></span><br></pre></td></tr></table></figure></p>
<p>变量使用一定要在声明后使用，否则报错</p>
<p><strong>3.暂时性死区</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"suo"</span>;</span><br><span class="line">&#123;</span><br><span class="line">    name =<span class="string">"yue"</span>;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"suo yue"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: name is not defined</span></span><br></pre></td></tr></table></figure></p>
<p>一旦块中有<code>let</code>声明的变量，该变量即与块绑定，不受外界变量干扰</p>
<p><strong>4.不允许重复声明</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"suo"</span>;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"yue"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Identifier 'name' has already been declared</span></span><br></pre></td></tr></table></figure></p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>let 实际是给 JavaScript 新增了块级作用域<br><strong>1.作用域嵌套</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"suo"</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> name =<span class="string">"yue"</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(name); <span class="comment">// yue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// yue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>作用域之间任意嵌套互不影响</p>
<p><strong>2.块级作用域域函数声明</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"suo"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"yue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    foo(); <span class="comment">// suo</span></span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>函数声明互不影响，不同环境运行不一样。避免使用函数声明，用函数表达式替代</p>
<p><strong>3.do表达式(提案)</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// Uncaught SyntaxError: Unexpected token do</span></span><br></pre></td></tr></table></figure></p>
<h3 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h3><p>与 c++ 类似，const 声明一个只读常量，一旦声明不可改变，同时也意味着声明必须初始化<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line">PI = <span class="number">3</span>; <span class="comment">//Assignment to constant variable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LENGTH; </span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure></p>
<p><strong>1.只在声明所在的块级作用域内有效</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(PI); <span class="comment">// VM143:4 Uncaught ReferenceError: PI is not defined</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2.不可重复声明</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Identifier 'PI' has already been declared</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3.const的本质</strong><br><code>const</code>保证的是变量指向的内存地址不改变。对于引用类型来说，变量名本身就是一个指向实际的内存指针。所以总结来说<code>const</code>是让变量名与它指向的内存的地址，这一关系不变。相当于 C 语言中的指针常量而不是常量指针。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span>,</span><br><span class="line">    gender: <span class="string">"male"</span></span><br><span class="line">&#125;;</span><br><span class="line">person.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// yue</span></span><br><span class="line"></span><br><span class="line">person1 = &#123;</span><br><span class="line">    name: <span class="string">"yue"</span>,</span><br><span class="line">    gender: <span class="string">"female"</span></span><br><span class="line">&#125;;</span><br><span class="line">person = person1; </span><br><span class="line"><span class="comment">// Uncaught TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure></p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
        <a href="/tags/ECMAScript6/">ECMAScript6</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2015/12/15/t-book_js_011/">
        《JavaScript高级程序设计》读后记&lt;十一&gt;：跨域
      </a>
    </h2>
    
    <time>
      Dec 15, 2015
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <p>终于到了收官之作了，学了这么长时间的 JavaScript ，对这门语言也有一个全面的认识。虽然你没有 C 系列经典健全，没有 Java 系列流行应用广泛，也许也没有 PHP 广受追捧。甚至天生的不完美给开发者带来不少麻烦，各个浏览器不同的支持兼容性也很让人头疼。但是随着前端的发展，作为一门脚本语言，你变化越来越大也越来越完善，同时好的工具也层出不穷，各种开源技术遍地开花。因此我始终相信你会成为一门理想的编程语言，让前端这个领域始终朝气蓬勃。</p>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>什么是跨域？为什么跨域？这一切都要从它谈起：<strong>同源策略</strong>。<br>同源策略：同协议，同域，同端口<br>如果三个条件满足就是同源，两个不同源的站点是无法获取数据的。这是浏览器的一种策略。目的是为了保护用户信息安全，防止窃取数据。<br>具体是以下行为被禁止</p>
<ul>
<li>Cookie 和 LocalStroage ，indexDB 无法读取</li>
<li>Dom 无法获得</li>
<li>Ajax 请求无法获得<br>下面我们具体了解下 Ajax</li>
</ul>
<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>全称 Asynchronous JavaScript + XML，这个技术能够向服务器请求额外的数据而无需卸载页面，简单的说就是无刷新技术，不需要刷新页面就可以获得新数据并显示在页面上。<br>这个技术的核心是<code>XMLHttpRequest</code>对象</p>
<h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h4><p>直接上代码吧<br>1.创建 XHR 对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建XHR对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="comment">// IE7 以上版本</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> ActiveXObject != <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="comment">// IE7 之前的版本</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.activeXString != <span class="string">"string"</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> versions = [<span class="string">"MSXML2.XMLHttp6.0"</span>, <span class="string">"MSXML2.XMLHTTP.3.0"</span>, <span class="string">"MSXML2.XMLHttp"</span>];</span><br><span class="line">        <span class="keyword">var</span> <span class="number">1</span>, len;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, len = versions.length; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">new</span> ActiveXObject(versions[i]);</span><br><span class="line">                <span class="built_in">arguments</span>.callee.activeXString = versions[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">                <span class="comment">// 跳过</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActivaXObject(<span class="built_in">arguments</span>.callee.activeXString);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"no xhr object avaiable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.使用 XHR 方法和属性<br>发送同步请求<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建XHR对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动请求(同步)</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"login.php"</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器收到请求后自动填充xhr对象的属性</span></span><br><span class="line"><span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"request fail!"</span> + xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发送异步请求<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR(); <span class="comment">// 0状态</span></span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 检测请求状态</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// 检测状态码，确认响应成功返回</span></span><br><span class="line">        <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"xhr.responseText"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"fail"</span> + xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1状态</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"login.php"</span>, <span class="string">"true"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2状态</span></span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用xhr.about()可以取消异步请求</span></span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ul>
<li>responseText: 响应主体被返回的文本</li>
<li>responseXML: 响应的XML DOM 文档</li>
<li>status: 响应的HTTP状态，200成功，304资源未修改</li>
<li>statusText: HTTP状态说明</li>
<li>readyState: 0未初始-1启动-2发送-3接收-4完成</li>
</ul>
<p>3.HTTP 头部信息<br>(1)发送 XHR 时还会发送相应的头部信息</p>
<ul>
<li>Accept: 浏览器能处理的内容</li>
<li>Accept-Charset: 能处理的字符集</li>
<li>Accept-Encoding: 压缩编码</li>
<li>Accept-Language: 语言</li>
<li>Connection: 连接类型</li>
<li>Cookie: 设置的 Cookie</li>
<li>Host: 所在的域</li>
<li>Referer: 请求的 URL (Referrer拼写正确的单词)</li>
<li>User-Agent: 用户代理字符串</li>
</ul>
<p>(2)设置获取头部信息<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send方法之前</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">"User-Agent"</span>, <span class="string">"suo"</span>); <span class="comment">// 设置</span></span><br><span class="line"></span><br><span class="line">xhr.getRequestHeader(<span class="string">"User-Agent"</span>); <span class="comment">// 获取</span></span><br><span class="line"></span><br><span class="line">xhr.getRequestHeader(); <span class="comment">// 获取所有</span></span><br></pre></td></tr></table></figure></p>
<p>(3)Get 请求<br>关键在于处理字符格式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理字符函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addURLParam</span>(<span class="params">url, name, value</span>) </span>&#123;</span><br><span class="line">    url += (url.indexOf(<span class="string">"?"</span>) == <span class="number">-1</span> ? <span class="string">"?"</span> : <span class="string">"&amp;"</span>);</span><br><span class="line">    url += encodeURLComponent(name) + <span class="string">"="</span> + encodeURLComponent(value);</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"index.php"</span>;</span><br><span class="line">url = addURLParam(url, <span class="string">"name"</span>, <span class="string">"suo"</span>);</span><br><span class="line">url = addURLParam(url, <span class="string">"friend"</span>, <span class="string">"yue"</span>);</span><br><span class="line"><span class="comment">// 请求</span></span><br><span class="line">xhr.open();</span><br></pre></td></tr></table></figure></p>
<p>(4)Post 请求<br>模仿表单提交<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"post"</span>, <span class="string">"login"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"user-info"</span>);</span><br><span class="line">xhr.send(serialize(form));</span><br></pre></td></tr></table></figure></p>
<h4 id="XMLHttpRequest2"><a href="#XMLHttpRequest2" class="headerlink" title="XMLHttpRequest2"></a>XMLHttpRequest2</h4><p>1.FromData<br>2.超时设定<br>3.进度事件<br>4.progress 事件</p>
<h4 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h4><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>全称为Cross-Origin Resource Sharing, 跨域资源共享，W3C新出来的一个规范的跨域方法<br>在发送请求的时候添加一个 origin 头部，服务器根据头部信息决定是否响应<br>Origin: <a href="http://suosmile.cn" target="_blank" rel="noopener">http://suosmile.cn</a><br>服务器判断是否要响应，可以接受就回发一个<br>Access-Control-Allow-Origin: <a href="http://suosmile.cn" target="_blank" rel="noopener">http://suosmile.cn</a></p>
<h4 id="IE-实现-CORS"><a href="#IE-实现-CORS" class="headerlink" title="IE 实现 CORS"></a>IE 实现 CORS</h4><p>IE8 中引入了 XDR 类型</p>
<ul>
<li>cookie 不会随请求发出，也不会响应返回</li>
<li>只能设置请求头部信息中的 Content-Type 字段</li>
<li>不能访问响应头部信息</li>
<li>只支持 GET 和 POST</li>
<li>默认异步</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建XDR</span></span><br><span class="line"><span class="keyword">var</span> xdr = <span class="keyword">new</span> XDomainRequest();</span><br><span class="line"><span class="comment">// 成功触发</span></span><br><span class="line">xdr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xdr.responseText);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误返回</span></span><br><span class="line">xdr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 超时</span></span><br><span class="line">xdr.timeout = <span class="number">1000</span>;</span><br><span class="line">xdr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timeout"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启动</span></span><br><span class="line">xdr.open(<span class="string">"post"</span>, <span class="string">"http://suosmile.cn"</span>);</span><br><span class="line"><span class="comment">// 设置post格式</span></span><br><span class="line">xdr.contentType = <span class="string">"application/x-www-form-urlencoded"</span>;</span><br><span class="line"><span class="comment">// 发送</span></span><br><span class="line">xdr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h4 id="其他浏览器实现"><a href="#其他浏览器实现" class="headerlink" title="其他浏览器实现"></a>其他浏览器实现</h4><p>只需要把<code>XMLHttpRequest</code>对象中的<code>open</code>方法的<code>url</code>改写成绝对地址就可以了，但是会有一些限制</p>
<ul>
<li>不能使用<code>setRequestHeader()</code>和<code>getAllResponseHeaders()</code>方法</li>
<li>不能发送和接收<code>cookie</code></li>
</ul>
<h4 id="跨浏览器实现"><a href="#跨浏览器实现" class="headerlink" title="跨浏览器实现"></a>跨浏览器实现</h4><h3 id="图片-Ping"><a href="#图片-Ping" class="headerlink" title="图片 Ping"></a>图片 Ping</h3><p>一个网页可以从任何网页加载图片<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.onload = img.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">img.src = <span class="string">"http://suosmile.cn?name=suo"</span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>全称Json with padding的简写，是应用JSON的一种新方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback(&#123;<span class="string">"name"</span>:<span class="string">"suo"</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>有两个部分组成，一个是回调函数和数据<br>通过动态操作脚本实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.ip + <span class="string">","</span> + response.city + <span class="string">','</span> + response.region_name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.src = <span class="string">"http://suosmile.cn?callback=handleResponse"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.firstChild);</span><br></pre></td></tr></table></figure></p>
<h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><p>一种高级的<code>Comet</code>，高级的<code>AJAX</code></p>
<h3 id="服务器发送"><a href="#服务器发送" class="headerlink" title="服务器发送"></a>服务器发送</h3><p>SSE </p>
<h3 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h3><h3 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h3><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3>

    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2015/12/12/t-book_js_010/">
        《JavaScript高级程序设计》读后记&lt;十&gt;：事件
      </a>
    </h2>
    
    <time>
      Dec 12, 2015
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><h4 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h4><h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h3><h4 id="HTML-事件处理程序"><a href="#HTML-事件处理程序" class="headerlink" title="HTML 事件处理程序"></a>HTML 事件处理程序</h4><h4 id="DOM0-级事件处理程序"><a href="#DOM0-级事件处理程序" class="headerlink" title="DOM0 级事件处理程序"></a>DOM0 级事件处理程序</h4><h4 id="DOM2-级事件处理程序"><a href="#DOM2-级事件处理程序" class="headerlink" title="DOM2 级事件处理程序"></a>DOM2 级事件处理程序</h4><h4 id="IE-事件处理"><a href="#IE-事件处理" class="headerlink" title="IE 事件处理"></a>IE 事件处理</h4><h4 id="跨浏览器事件处理"><a href="#跨浏览器事件处理" class="headerlink" title="跨浏览器事件处理"></a>跨浏览器事件处理</h4><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><h4 id="DOM-事件对象"><a href="#DOM-事件对象" class="headerlink" title="DOM 事件对象"></a>DOM 事件对象</h4><h4 id="IE-事件对象"><a href="#IE-事件对象" class="headerlink" title="IE 事件对象"></a>IE 事件对象</h4><h4 id="跨浏览器事件对象"><a href="#跨浏览器事件对象" class="headerlink" title="跨浏览器事件对象"></a>跨浏览器事件对象</h4><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><h4 id="UI-事件"><a href="#UI-事件" class="headerlink" title="UI 事件"></a>UI 事件</h4><h4 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h4><h4 id="鼠标滚轮事件"><a href="#鼠标滚轮事件" class="headerlink" title="鼠标滚轮事件"></a>鼠标滚轮事件</h4><h4 id="键盘文本事件"><a href="#键盘文本事件" class="headerlink" title="键盘文本事件"></a>键盘文本事件</h4><h4 id="复合事件"><a href="#复合事件" class="headerlink" title="复合事件"></a>复合事件</h4><h4 id="变动事件"><a href="#变动事件" class="headerlink" title="变动事件"></a>变动事件</h4><h4 id="HTML5事件"><a href="#HTML5事件" class="headerlink" title="HTML5事件"></a>HTML5事件</h4><h4 id="设备事件"><a href="#设备事件" class="headerlink" title="设备事件"></a>设备事件</h4><h4 id="触摸手势事件"><a href="#触摸手势事件" class="headerlink" title="触摸手势事件"></a>触摸手势事件</h4><h3 id="内存与性能"><a href="#内存与性能" class="headerlink" title="内存与性能"></a>内存与性能</h3><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><h4 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h4><h3 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h3><h4 id="模拟鼠标事件"><a href="#模拟鼠标事件" class="headerlink" title="模拟鼠标事件"></a>模拟鼠标事件</h4><h4 id="模拟键盘事件"><a href="#模拟键盘事件" class="headerlink" title="模拟键盘事件"></a>模拟键盘事件</h4><h4 id="模拟其他事件"><a href="#模拟其他事件" class="headerlink" title="模拟其他事件"></a>模拟其他事件</h4>

    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2015/12/10/t-book_js_009/">
        《JavaScript高级程序设计》读后记&lt;九&gt;：DOM
      </a>
    </h2>
    
    <time>
      Dec 10, 2015
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <p>DOM 为 <strong>Document Object Model</strong> 的缩写，也是 HTML 和 XML 文档的一个 API 接口。描绘的是一个层次化节点树，允许开发人人添加移除和修改页面的某一部分。</p>
<h4 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>用一个图片描述一下</p>
<p>1.Node 类型</p>
<p><strong>属性</strong><br>(1)nodeType<br>JavaScipt中的所有节点类型都继承与Node类型。因此所有节点都共享着相同的基本属性和方法<br>每个节点都有个NodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的下列12个数值常量来表示，任何节点类型必居其一</p>
<ul>
<li>Node.ElEMNRT_NODE</li>
<li>Node.ATTRIBUTE_NODE</li>
<li>Node.TEXT_NODE</li>
<li>Node.CDATASELECTION_NODE</li>
<li>Node.ENTITY_REFERENCE_NODE</li>
<li>Node.ENYIYY_NODE</li>
<li>Node.PROCESSING_INSTUCATION_NODE</li>
<li>Node.COMMENT_NODE</li>
<li>Node.DOCUMNENT_NODE</li>
<li>Node.DOCUMENT_TYPE_NODE</li>
<li>Node.DOCUMENT_FRAGMENT_NODE</li>
<li>Node.NOTATION_NODE</li>
</ul>
<p>通过比较上面这些常量很容易确定节点的类型<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nodeTyep == Node.ELEMENT) &#123;</span><br><span class="line">    alert(<span class="string">"node is element type"</span>); <span class="comment">// ie无效</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以直接与数字比较</span></span><br></pre></td></tr></table></figure></p>
<p>(2)nodeName：保存标签名<br>(3)nodeValue：null<br>(4)childNodes:保存着NodeList对象，一组有序的序列<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstChild = someNode.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> length = someNode.childNodes.length;</span><br></pre></td></tr></table></figure></p>
<p>(5)parentNode:指向文档父节点<br>(6)nextSibling:下一个节点<br>(7)previouSibling:上一个节点<br>(8)ownerDocument:整个文档的文档节点</p>
<p><strong>方法</strong><br>(1)appendChild方法<br>在childNodes列表的末尾添加一个节点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> returnedNode = someNode.appendChild(newNode);</span><br></pre></td></tr></table></figure></p>
<p>(2)insertBefore方法<br>插入特定的位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入到第一个</span></span><br><span class="line"><span class="keyword">var</span> aNode1 = someNode.appendChild(newNode, someNode.firstChild);</span><br><span class="line"><span class="comment">// 插入到倒数第二个</span></span><br><span class="line"><span class="keyword">var</span> aNode2 = someNode.appendChild(newNode, someNode.lastChild);</span><br></pre></td></tr></table></figure></p>
<p>(3)replaceChild方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换第一个</span></span><br><span class="line"><span class="keyword">var</span> aNode1 = someNode.replaceChild(newNode, someNode.firstChild); </span><br><span class="line"><span class="comment">// 替换最后一个</span></span><br><span class="line"><span class="keyword">var</span> aNode2 = someNode.replaceChild(newNode, someNode.lastChild);</span><br></pre></td></tr></table></figure></p>
<p>(4)removeChild方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除第一个</span></span><br><span class="line"><span class="keyword">var</span> aNode1 = someNode.removeChild(newNide, someNode.firstChild);</span><br><span class="line"><span class="comment">// 移除最后一个</span></span><br><span class="line"><span class="keyword">var</span> aNode2 = someNode.removeChild(newNide, someNode.laststChild);</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Document 类型<br>表示文档，在浏览器中document对象是HTMLDocument的一个实例，表示整个HTML页面。document对象是window对象的一个属性，因此document作为全局对象来访问</li>
</ol>
<ul>
<li>nodeType:9</li>
<li>NodeName:#document</li>
<li>nodeValue:null</li>
<li>parentNode:null</li>
<li>ownerDocument:null</li>
</ul>
<p>(1)文档子节点<br>2个快捷访问方式，一个是documentElement属性，一个是childNodes访问文档元素</p>
<ul>
<li><p><code>documentElement</code>属性，指向<code>&lt;html&gt;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="built_in">document</span>.documentElement;</span><br><span class="line"><span class="built_in">console</span>.log(html === <span class="built_in">document</span>.childNodes[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(html === <span class="built_in">document</span>.firstChild);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>body</code>属性，直接指向<code>&lt;body&gt;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>所有浏览器都支持document.documentElement和document.body</p>
<ul>
<li><code>doctype</code>属性，指向<code>&lt;!DOCTYPE&gt;</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> docType = <span class="built_in">document</span>.doctype;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>(2)文档信息</p>
<ul>
<li><code>title</code>属性，指向<code>&lt;title&gt;</code></li>
<li><code>URL</code>属性</li>
<li><code>domain</code>属性</li>
<li><code>referrer</code>属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aTitle = <span class="built_in">document</span>.title;</span><br><span class="line"><span class="comment">// 完整URL</span></span><br><span class="line"><span class="keyword">var</span> aUrl = <span class="built_in">document</span>.url;</span><br><span class="line"><span class="comment">// 域</span></span><br><span class="line"><span class="keyword">var</span> aDomain = <span class="built_in">document</span>.domain;</span><br><span class="line"><span class="comment">// 来源URL</span></span><br><span class="line"><span class="keyword">var</span> aReferrer = <span class="built_in">document</span>.referrer</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>(3)查找元素</p>
<ul>
<li><p><code>getElementById</code>方法:取ID元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">"mydiv"</span>); <span class="comment">// 早期版本不分大小写</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>getElementsByTagName</code>方法:取元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(aLi[<span class="number">0</span>].innerHTML);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部</span></span><br><span class="line"><span class="keyword">var</span> all = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"*"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>getElementsByName</code>方法：取name所有元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> radio = <span class="built_in">document</span>.getElementsByName(<span class="string">"color"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>(4)特殊集合</p>
<ul>
<li>document.anchors: 所有<code>&lt;a&gt;</code></li>
<li>document.applets: 所有带name的<code>&lt;a&gt;</code></li>
<li>document.forms: 所有<code>&lt;form&gt;</code>元素</li>
<li>document.images: 所有<code>&lt;img&gt;</code>元素</li>
<li>document.links: 所有带src的<code>&lt;a&gt;</code>元素</li>
</ul>
<p>(5)DOM 一致性检测<br>DOM 有多个级别。实现DOM检测就有很大必要了,implementation,规定了一个方法hasFeature<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasXmlDom = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"XML"</span>, <span class="string">"1.0"</span>);</span><br></pre></td></tr></table></figure></p>
<p>(6)文档写入</p>
<ul>
<li>write():原样写入</li>
<li>writeln():写入换行</li>
<li>open()</li>
<li>close()</li>
</ul>
<ol>
<li>Element 类型</li>
</ol>
<ul>
<li>nodeType:1</li>
<li>nodeName:标签名</li>
<li>nodeValue:null</li>
<li>parentNode:可是Document或者Element</li>
<li>childNodes:都可能</li>
</ul>
<p>(1)HTML元素</p>
<ul>
<li>id: 元素在文档唯一标识符</li>
<li>title: 附加说明</li>
<li>lang: 语言代码</li>
<li>dir: 语言的方向</li>
<li>className: 与class对应，之所以不用class是因为class是ES保留字</li>
</ul>
<p>这些值都可以用来修改<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"suo"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">title</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">""</span> <span class="attr">lang</span>=<span class="string">""</span> <span class="attr">dir</span>=<span class="string">""</span>&gt;</span>name<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ie8之前不能访问 --&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>(2)特性</p>
<ul>
<li>getAttribute()</li>
<li>setAttrubute()</li>
<li>removeAttribute()</li>
</ul>
<p>(3)创建元素<br>document.createElement方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">div.id = <span class="string">"suo"</span>;</span><br><span class="line">div.className = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="string">"div"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完整插入</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"&lt;div id=\"suo\" class=\"yue\"&gt; &lt;/div&gt;"</span>);</span><br></pre></td></tr></table></figure></p>
<p>(4)元素的子节点<br>不同浏览器解析不一样</p>
<ul>
<li>IE不解析间隔</li>
<li>其他浏览器连间隔也解析</li>
</ul>
<p>4.Text 类型</p>
<ul>
<li>nodeType: 3</li>
<li>nodeName: “#text”</li>
<li>nodeValue: 节点文本</li>
<li>parentNode是一个Element</li>
<li>没有子节点</li>
<li>appendData(text): 插入节点末尾</li>
<li>deleteDate(offset, count): 删除文本</li>
<li>insertData(offset, text): 插入文本</li>
<li>replaceData(offset, count, text): 替换文本</li>
<li>splitText(offset): 分割文本</li>
<li>substringData(offset, count): 提取字符串</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 没有内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 有个空格 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 有内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得文本</span></span><br><span class="line"><span class="keyword">var</span> textNode = div.firstChild;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> textNode = div.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 修改值</span></span><br><span class="line">textNode.nodeValue = <span class="string">"suoyue"</span>;</span><br></pre></td></tr></table></figure>
<p>(1)创建文本节点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"&lt;p&gt;hello world!&lt;/p&gt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分开创建</span></span><br><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</span><br><span class="line">element.className = <span class="string">"color"</span>;</span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"hello world!"</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br></pre></td></tr></table></figure></p>
<p>(2)规范文本节点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.normalize(); <span class="comment">// 将多个文本节点合并成一个文本节点</span></span><br></pre></td></tr></table></figure></p>
<p>5.Comment 类型<br>注释在DOM里面用Comment类型表示</p>
<ul>
<li>nodeType: 8</li>
<li>nodeName: “#comment”</li>
<li>nodeValue: “注释的内容”</li>
<li>parentNode 可能是Document或者Element</li>
<li>不支持子节点</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"mydiv"</span>);</span><br><span class="line"><span class="keyword">var</span> comment = div.firstChild;</span><br><span class="line"><span class="built_in">console</span>.log(comment);</span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line"><span class="keyword">var</span> comment = <span class="built_in">document</span>.createComment(<span class="string">"good job"</span>);</span><br></pre></td></tr></table></figure>
<p>6.CDATASection 类型</p>
<ul>
<li>nodeType: 4</li>
<li>nodeName: “#cdata-section”</li>
<li>nodeValue: CDATA区域内容</li>
<li>parentNode 可能是Document或者Element</li>
<li>不支持子节点</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cdata = <span class="built_in">document</span>.createCDateSection();</span><br></pre></td></tr></table></figure>
<p>7.DocumentType 类型<br>仅FireFox,Safari,Oprea支持</p>
<ul>
<li>nodeType: 10</li>
<li>nodeName: doctype的名称</li>
<li>nodeValue: null</li>
<li>parentNode: Document</li>
<li>不支持子节点</li>
</ul>
<p>8.DocumentFragment 类型<br>轻量级文档，文档片段</p>
<ul>
<li>nodeType: 11</li>
<li>nodeName: “#document-fragment”</li>
<li>nodeValue: null</li>
<li>parentNode: null</li>
<li>子节点可以为各种</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFrament();</span><br><span class="line">va ul = <span class="built_in">document</span>.getElementById(<span class="string">"list"</span>);</span><br><span class="line"><span class="keyword">var</span> li = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">    li.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Item"</span> + (i+<span class="number">1</span>)));</span><br><span class="line">    fragment.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure>
<p>9.Attr 类型</p>
<ul>
<li>nodeType: 2</li>
<li>nodeName: 特性的名称</li>
<li>nodeValue: 特性的值</li>
<li>parentNode: null</li>
<li>HTML没有子节点</li>
<li>XML里面子节点可以是TEXT或者EntityReference</li>
</ul>
<h4 id="DOM-操作技术"><a href="#DOM-操作技术" class="headerlink" title="DOM 操作技术"></a>DOM 操作技术</h4><p>DOM操作比较简明，原本不会很麻烦，但是由于浏览器有个隐性的陷阱和不兼容的问题，JavaScript操作还比较麻烦<br>1.动态脚本<br>动态加载外部文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">script.src = <span class="string">"suo.js"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数封装一下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">$url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">    script.src = $url;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.动态样式<br>与动态脚本一样<br>3.操作表格<br>4.使用NodeList</p>
<h4 id="DOM-选择符API"><a href="#DOM-选择符API" class="headerlink" title="DOM 选择符API"></a>DOM 选择符API</h4><p>1.querySelector 方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受选择符，返回与该模式匹配的第一个元素</span></span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">"body"</span>);</span><br><span class="line"><span class="keyword">var</span> myid = <span class="built_in">document</span>.querySelector(<span class="string">"#myid"</span>);</span><br><span class="line"><span class="keyword">var</span> myclass = <span class="built_in">document</span>.querySelector(<span class="string">".myclass"</span>);</span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.querySelector(<span class="string">"img.myclass"</span>);</span><br></pre></td></tr></table></figure></p>
<p>2.querySelectorAll 方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受选择符，返回的是一个NodeList实例</span></span><br><span class="line"><span class="keyword">var</span> nodeList = <span class="built_in">document</span>.querySelector(<span class="string">".myclass"</span>);</span><br></pre></td></tr></table></figure></p>
<p>3.machesSelector 方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受选择符，返回True或者false</span></span><br><span class="line"><span class="keyword">var</span> hasCLass = <span class="built_in">document</span>.matchesSelector(<span class="string">"body.myclass"</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h4><p>新增的一组属性，为了让IE的行为一致</p>
<ul>
<li>childElementCount: 返回子元素个数</li>
<li>firstElementChild: 指向第一个子元素</li>
<li>lastAElementChild: 指向最后一个子元素</li>
<li>previousElementSibling: 指向后一个同辈元素</li>
<li>nextElementSibling: 指向前一个子元素</li>
</ul>
<h4 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h4><p>1.与类相关的扩充</p>
<ul>
<li>getElementsByClassName()</li>
<li>classList 属性</li>
</ul>
<p>2.焦点管理</p>
<ul>
<li>document.activeElement</li>
</ul>
<p>3.HTMLDocument的变化</p>
<ul>
<li>readyState 属性</li>
<li>兼容模式</li>
<li>head 属性</li>
</ul>
<p>4.字符集属性<br><code>document.charset = &quot;UTF-8</code></p>
<p>5.自定义属性类型<br><code>data-</code></p>
<p>6.插入标记</p>
<ul>
<li>innerHTML 属性</li>
<li>outerHTML 属性</li>
<li>insertAdjacentHTML 方法</li>
<li>内存与性能</li>
<li>scrollIntoView方法</li>
</ul>
<h4 id="扩展（了解）"><a href="#扩展（了解）" class="headerlink" title="扩展（了解）"></a>扩展（了解）</h4><p>1.文档模式</p>
<ul>
<li>IE5: 混杂模式</li>
<li>IE7: IE7标准模式</li>
<li>IE8: IE8标准模式</li>
<li>IE9: IE9标准模式，ES5，CSS3，H5大部分功能</li>
</ul>
<p>2.children 属性<br>3.contains 方法<br>4.插入文本<br>5.滚动</p>
<!-- #### DOM2和DOM3 -->


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2015/12/08/t-book_js_008/">
        《JavaScript高级程序设计》读后记&lt;八&gt;：BOM
      </a>
    </h2>
    
    <time>
      Dec 8, 2015
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <p>前几章学了 JavaScript 的基础的知识，理论性太强。需要思考理解的东西远远多于实战的。我最近看了 BOM 这一章，才真正的感受到了 JavaScript 真的很强大，特别是在于操作浏览器这方法。不多写了，已经等不急实战了。</p>
<h3 id="理解BOM"><a href="#理解BOM" class="headerlink" title="理解BOM"></a>理解BOM</h3><h4 id="使用-Window-对象"><a href="#使用-Window-对象" class="headerlink" title="使用 Window 对象"></a>使用 Window 对象</h4><p>说明一下，在浏览器中 window 对象有两重身份，一重是 JavaScript 访问浏览器的接口，另一重是 ES 规定的 Global 对象，因此可以访问<code>parseInt()</code>等方法<br>测试一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"suo"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">sayName(); <span class="comment">// suo</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// suo</span></span><br><span class="line"><span class="built_in">window</span>.sayName(); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>说明全局的变量和方法，使用 window均能访问到</p>
<p>全局变量的window的变量有说明差异呢，有一点就是定义在window上的属性可以使用delete删除，而定义的全局变量不可以<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"suo"</span>;</span><br><span class="line"><span class="built_in">window</span>.gender = <span class="string">"male"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> name;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.gender;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// suo</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.gender); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>另外尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的对象是否存在<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newname = oldname; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> newname = <span class="built_in">window</span>.oldname; <span class="comment">// 没报错</span></span><br></pre></td></tr></table></figure></p>
<p>说了这么多，我们来用 window 对象操作窗口<br>(1)控制窗口位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>) ?</span><br><span class="line">    <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>) ?</span><br><span class="line">    <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(leftPos);</span><br><span class="line"><span class="built_in">console</span>.log(topPos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IE(5,7-11) edge firefox 都能正常显示位置</span></span><br><span class="line"><span class="comment">// chorme 始终显示 0 0</span></span><br><span class="line"><span class="comment">// 令人费解</span></span><br></pre></td></tr></table></figure></p>
<p>除此之外还可以改变位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动多少像素</span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"><span class="comment">// 移动到哪个位置</span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试结果，除了IE以外，其他浏览器都默认禁用了</span></span><br></pre></td></tr></table></figure></p>
<p>(2)控制窗口大小<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面视图区大小</span></span><br><span class="line"><span class="comment">// 兼容的处理</span></span><br><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.campatMode == <span class="string">"CSS1Compat"</span>) &#123;</span><br><span class="line">        pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">        pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pageWidth = <span class="built_in">document</span>.body.clientWidth; <span class="comment">// IE6</span></span><br><span class="line">        pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(pageWidth + <span class="string">','</span> + pageHeight); <span class="comment">// 1080,1008</span></span><br></pre></td></tr></table></figure></p>
<p>我们还可以调整窗口大小<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整的像素</span></span><br><span class="line"><span class="built_in">window</span>.resizeBy(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line"><span class="comment">// 调整到多少</span></span><br><span class="line"><span class="built_in">window</span>.resizeTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 仍然除了IE以外其他都禁用了的</span></span><br></pre></td></tr></table></figure></p>
<p>(3)打开窗口<br>使用<code>window.open()</code>函数打开窗口，其中有四个参数：URL， target， 特性字符串，是否取得历史纪录中那个页面。第一个参数不用说，第二个参数有几个可以是特殊值：<code>_self</code>,<code>_parent</code>,<code>_top</code>,<code>_blank</code>。举个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开窗口</span></span><br><span class="line"><span class="keyword">var</span> local = <span class="built_in">window</span>.open(<span class="string">"http://localhost:4000"</span>, <span class="string">"local"</span>, <span class="string">"height=500,width=500,top=100,left=100,resizable=yes"</span>);</span><br><span class="line"><span class="comment">// 关闭窗口</span></span><br><span class="line">local.close()</span><br><span class="line"><span class="comment">// 强制关闭</span></span><br><span class="line">top.close();</span><br></pre></td></tr></table></figure></p>
<p>检测窗口是否被屏蔽<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blocked = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> local = <span class="built_in">window</span>.open(<span class="string">"http://localhost:4000"</span>, <span class="string">"_blank"</span>);</span><br><span class="line">    <span class="keyword">if</span> (local == <span class="literal">null</span>) &#123;</span><br><span class="line">        blocked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"窗口被屏蔽"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(4)使用定时器<br>window 对象提供两种定时器，一种是超时定时器<code>setTimeout()</code>,另一种是间歇定时器<code>setInterval()</code>。它们都提供两个参数，一个是执行的代码，一个是时间毫秒。看一下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超时定时器</span></span><br><span class="line"><span class="keyword">var</span> timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>); <span class="comment">// 经过一秒后ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消超时定时器</span></span><br><span class="line">clearTimeout(timer); <span class="comment">// 没打印</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 间歇定时器</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="number">3</span>; <span class="comment">// 设置最多定时次数</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> interval = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">if</span> (num == max) &#123;</span><br><span class="line">        clearInterval(interval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>); <span class="comment">// 没经过一秒打印一个ok，打印三次后结束打印</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用超时定时器模拟间歇定时器</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timerFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; max) &#123;  </span><br><span class="line">        setTimeout(timerFunction, <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(timerFunction, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<p>开发环境中很少真正使用间歇定时器，一般用超时定时器模拟它，原因在于当执行函数时间大于间歇时间时，后一个间歇定时器在前一个调用结束之前调用。</p>
<p>(5)使用系统对话框<br>由于系统对话框带来的用户体验相当差，现在用的很少，这里随便提一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证框与弹出框</span></span><br><span class="line"><span class="keyword">if</span> (confirm(<span class="string">"are you sure?"</span>)) &#123;</span><br><span class="line">    alert(<span class="string">"baici"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">"shagua"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 文本框</span></span><br><span class="line"><span class="keyword">var</span> name = prompt(<span class="string">"you name?"</span>);</span><br><span class="line">alert(<span class="string">"welcome "</span> + name);</span><br><span class="line"><span class="comment">// 打开find,print</span></span><br><span class="line">find();</span><br><span class="line">print(); <span class="comment">// 打印对话框</span></span><br></pre></td></tr></table></figure></p>
<h4 id="使用-location-对象"><a href="#使用-location-对象" class="headerlink" title="使用 location 对象"></a>使用 location 对象</h4><p>location对象是BOM最有用的对象之一，提供了文档有关的信息，还提供了一些导航功能。它是一个特别的对象，即是window属性，也是document属性，也就是说location,window.location,document.location是同一个东西。我们来试试它的功能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(location.hash); <span class="comment">// 无</span></span><br><span class="line"><span class="built_in">console</span>.log(location.host); <span class="comment">// localhost:4000</span></span><br><span class="line"><span class="built_in">console</span>.log(location.href); <span class="comment">// http://localhost:4000/</span></span><br><span class="line"><span class="built_in">console</span>.log(location.port); <span class="comment">// 4000</span></span><br><span class="line"><span class="built_in">console</span>.log(location.protocol); <span class="comment">// http:</span></span><br><span class="line"><span class="built_in">console</span>.log(location.search);</span><br></pre></td></tr></table></figure></p>
<h4 id="使用-navigator对象"><a href="#使用-navigator对象" class="headerlink" title="使用 navigator对象"></a>使用 navigator对象</h4><h4 id="使用-screen-对象"><a href="#使用-screen-对象" class="headerlink" title="使用 screen 对象"></a>使用 screen 对象</h4><p>用来识别客户端浏览器的，用处不大，表明客户端能力的。一般用于客户端能力检测</p>
<h4 id="使用-history对象"><a href="#使用-history对象" class="headerlink" title="使用 history对象"></a>使用 history对象</h4><p>保存用户上网的历史记录。处于安全考虑，开发人员无法知道历史记录的具体的URL,但是可以通过go()方法在历史记录中任意跳转。这个方法只接受一个参数，正数前进，负数后退<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go方法前进后退</span></span><br><span class="line">history.go(<span class="number">-1</span>);</span><br><span class="line">history.go(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写的两个方法</span></span><br><span class="line">history.back();</span><br><span class="line">history.forword();</span><br></pre></td></tr></table></figure></p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2015/12/06/t-book_js_007/">
        《JavaScript高级程序设计》读后记&lt;七&gt;：继承
      </a>
    </h2>
    
    <time>
      Dec 6, 2015
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <p>上一篇博客，我深入理解了对象，可以通过一些方式来创建对象。而对于 OOP 来说，仅仅做到这些是不够的。我们学过 OOP 都知道，它有三大特性，继承，多态，封装。第一个就是继承，而 JS 却本身没有继承这一方法。所以我们需要通过 JS 其他的特性来实现继承。由于 JS 的函数是没有函数签名的。所以并不能做到“接口继承”，但是我们可以做到“实现继承”。</p>
<h4 id="理解继承"><a href="#理解继承" class="headerlink" title="理解继承"></a>理解继承</h4><p><strong>(1)原型链</strong><br><strong>原型链</strong>是实现继承的主要方法，那么原型链到底是什么样的东西呢？上一篇博客我们重点分析了原型这一属性和对象。并且给出了一个图来说明它们之间的关系。回顾一些，下面给出之前的图<br><a href="/images/dm5.png">img</a><br>现在，我稍微改变一下原型属性的指向，我们让原型属性不指向它自己的原型对象，而是指向另一个函数的原型对象。如同所示，依次如此就构成了 <strong>原型链</strong><br><a href="/images/dm6.png">img</a><br><strong>各个函数之间通过原型对象构成一条链，所以称之为原型链</strong>，下面模拟一下这个过程<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.prototype = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getPersonValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prototype;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subprototype = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承，子类型原型等于父类型实例</span></span><br><span class="line">SubPerson.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">SubPerson.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subprototype;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subperson = <span class="keyword">new</span> SubPerson();</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson.getPersonValue()); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson.getSubValue()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>由上可知，当我们的函数的原型属性等于另一个函数的实例时，我们就继承了它的原型属性和方法。同时我们仍然保留了自己原型属性和方法。</p>
<p>我们现在知道了使用原型链来实现继承，有了继承我们的 <strong>原型搜索机制</strong>也得到了扩展</p>
<ul>
<li>搜索实例本身定义的属性</li>
<li>搜索实例原型</li>
<li>搜索继承的原型(多重继续)</li>
<li>搜索Object的原型(继承链顶端)</li>
</ul>
<p><strong>要注意的方面：</strong></p>
<ul>
<li><strong>子类型给原型添加的方法要在父类型之后添加</strong>(无论是新添加还是重新)</li>
<li><strong>通过原型链实现继承，不能通过对象字面量创建原型方法，这样会重写原型链</strong></li>
</ul>
<p><strong>原型链的缺陷：</strong><br>缺陷一，原型链实现的继承，原型变成了另外一个类型的实例，<strong>原有的实例属性变成了原型属性</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = [<span class="string">"suo"</span>, <span class="string">"yue"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line">SubPerson.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubPerson();</span><br><span class="line">sub1.name.push(<span class="string">"smile"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.name); <span class="comment">// (3) ["suo", "yue", "smile"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> SubPerson();</span><br><span class="line"><span class="built_in">console</span>.log(sub2.name); <span class="comment">// (3) ["suo", "yue", "smile"]</span></span><br></pre></td></tr></table></figure></p>
<p>缺陷二，<strong>子类继承了父类，但是没法给父类传递参数。</strong><br>基于这些缺陷，单一的使用原型链继承不太实用，怎么去解决这些问题呢？</p>
<p><strong>(2)构造函数</strong><br>上面两个缺陷是否有解决方法，结合我们之前学习的知识。我们思考一下，<br><strong>可以传参，而且不使用原型等于实例这种方法，怎么让子类型使用父类型的变量和方法呢呢？</strong><br>由此我们想到了之前学习的两个函数的方法，一个是<code>apply()</code>，一个是<code>call()</code>。<strong>它们可以将函数调用的其他函数绑定本函数的作用域和参数</strong>。现在我们来试试<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = [<span class="string">"suo"</span>, <span class="string">"yue"</span>];</span><br><span class="line">    <span class="keyword">this</span>.addName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name.push(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类函数，并绑定子类函数和参数</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subperson1 = <span class="keyword">new</span> SubPerson(<span class="string">"smile"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">var</span> subperson2 = <span class="keyword">new</span> SubPerson(<span class="string">"cry"</span>, <span class="string">"female"</span>);</span><br><span class="line">subperson1.addName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson1.name); <span class="comment">// ["suo", "yue", "smile"]</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson2.name); <span class="comment">// ["suo", "yue"]</span></span><br></pre></td></tr></table></figure></p>
<p>同理单独使用构造函数实现继承也是不行的，共享属性和变量就谈不上了，所以我们还是结合它们两者的优势重新实现继承吧。这和创建对象的模式有着异曲同工之妙。</p>
<p><strong>(3)组合继承</strong><br>结合以上我们来整合它们的技术，先上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.nameGroup = [<span class="string">"suo"</span>, <span class="string">"yue"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类型函数原型方法</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.addName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nameGroup.push(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造继承，调用父类型函数并绑定作用域和参数</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型链继承，子类型函数原型等于父类型实例</span></span><br><span class="line">SubPerson.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 修正构造属性</span></span><br><span class="line">SubPerson.prototype.constructor = SubPerson;</span><br><span class="line"><span class="comment">// 子类型函数原型方法</span></span><br><span class="line">SubPerson.prototype.getGender = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> subperson1 = <span class="keyword">new</span> SubPerson(<span class="string">"smile"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">var</span> subperson2 = <span class="keyword">new</span> SubPerson(<span class="string">"cry"</span>, <span class="string">"female"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">subperson1.addName();</span><br><span class="line"><span class="built_in">console</span>.log(subperson1.getName());   <span class="comment">// smile</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson1.getGender()); <span class="comment">// male</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson1.nameGroup);   <span class="comment">// ["suo", "yue", ""]</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson2.getName());   <span class="comment">// cry</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson2.getGender()); <span class="comment">// female</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson2.nameGroup);   <span class="comment">// ["suo", "yue"]</span></span><br></pre></td></tr></table></figure></p>
<p><strong>(4)原型式继承</strong><br>基于已有的对象创建新对象，同时还不必因此自定义类型，看看代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    Person.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们可能看不懂，但是结合原型链的思想，改变一下，或许就很明了了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person1是Person的实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">person1</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 子类型的原型等于父类型的实例</span></span><br><span class="line">    SubPerson.prototype = person1;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubPerson;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">subperson1 = object(person1);</span><br></pre></td></tr></table></figure></p>
<p>咋一看这不就是将原型链的继承方法，用函数封装了一下吗。有啥区别<br>确实原理都是样的。区别就在于，<strong>原型链方法是类型到类型。而原型式继承则直接是对象到对象</strong>。测试一下，到底可不可以继承到属性和方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span>,</span><br><span class="line">    nameGroup: [<span class="string">"suo"</span>, <span class="string">"yue"</span>];</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    P.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subperson = createObj(person1);</span><br><span class="line"><span class="built_in">console</span>.log(subperson.getName()); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>很明显当然是可以的，我们由此也想到了，这和复制一个对象有什么区别呢？当然是有区别的，本质来说，这种继承方法是一个 <strong>浅复制</strong>，<strong>虽然复制了对象的属性，但是引用型的属性仍然是共享的</strong>。验证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subperson1 = createObj(person1); </span><br><span class="line"><span class="keyword">var</span> subperson2 = createObj(person1);</span><br><span class="line">subperson1.nameGroup.push(<span class="string">"smile"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subperson2.nameGroup); </span><br><span class="line"><span class="comment">// (3) ["suo", "yue", "smile"]</span></span><br></pre></td></tr></table></figure></p>
<p>ES 新增了一个<code>Object.create()</code>方法规范了这个原型式继承。只有一个参数的情况下两者效果是一样的。第二个参数是可选的，作用是可以设置属性特性。这和我们之前谈到的<code>Object.defineProperties()</code>是同等效果的。测试一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> subperson1 = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">"yue"</span>,</span><br><span class="line">        enumerable: <span class="literal">false</span> <span class="comment">// 设置不可枚举</span></span><br><span class="line">    &#125;,</span><br><span class="line">    gerder: &#123;</span><br><span class="line">        value: <span class="string">"male"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(subperson1.name + <span class="string">','</span> + subperson1.gender); </span><br><span class="line"><span class="comment">// male, undefined 说明不能自己增加属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (prop <span class="keyword">in</span> subperson1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop); <span class="comment">// age </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>(5)寄生式继承</strong><br>寄生式继承与刚刚学习的原型式继承紧密相连，在原型式继承的基础上又封装了一道函数。直接上代码吧<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span>,</span><br><span class="line">    mess: <span class="string">"bye"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 原型式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    P.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寄生式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnobj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = createObj(o);</span><br><span class="line">    clone.sayBye = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o.mess;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> anoperson = createAnobj(person);</span><br><span class="line"><span class="built_in">console</span>.log(anoperson.name + <span class="string">','</span> + anoperson.sayBye());</span><br><span class="line"><span class="comment">// suo,bye</span></span><br></pre></td></tr></table></figure></p>
<p>咋一看，这不就是在原型式的基础上加一个添加方法的函数吗。当然完全是，它还有另一个用途，如果对象不是自定义或者构造函数时，它也是有用的，随便举个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnobj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone =  o; <span class="comment">// 原型式函数不是必须的</span></span><br><span class="line">    o.printFirst = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(o[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr2 = createAnobj(arr);</span><br><span class="line">arr.printFirst(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>(6)寄生组合继承</strong><br>我们知道原型链与构造函数的组合模式是最常见的继承方式，但是它也有不足的地方。它们单独来将每次调用一次父类型，组合起来就是调用了两次父类型。我们现在有一种方法来解决这个问题，就是组合寄生继承模式。<strong>它的思路就是构造函数模式不变，不直接调用父类型函数，而是通过原型模式创建一个副本，然后让子类的原型等于这个副本。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.nameGroup = [<span class="string">"xiao"</span>, <span class="string">"ai"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.addName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nameGroup.push(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继承属性</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="comment">// 自己属性</span></span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型式模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    P.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄生模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">p, subp</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象，浅复制原型对象</span></span><br><span class="line">    <span class="keyword">var</span> prototype = createObj(p.prototype);</span><br><span class="line">    <span class="comment">// 增强对象，修正构造函数</span></span><br><span class="line">    prototype.constructor = subp;</span><br><span class="line">    <span class="comment">// 指向对象，子类型指向创建并修正构造的父类型原型对象</span></span><br><span class="line">    subp.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行寄生模式</span></span><br><span class="line">inheritPrototype(Person, SubPerson);</span><br><span class="line"></span><br><span class="line">SubPerson.prototype.sayBye = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bye"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> subperson1 = <span class="keyword">new</span> SubPerson(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subperson1.getName()); <span class="comment">// 父类型属性和方法</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson1);</span><br><span class="line"><span class="built_in">console</span>.log(subperson1.gender); <span class="comment">// 自己的属性</span></span><br><span class="line">subperson1.addName(); <span class="comment">// 父类型的方法</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson1.nameGroup);</span><br><span class="line">subperson1.sayBye(); <span class="comment">// 自己的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subperson2 = <span class="keyword">new</span> SubPerson(<span class="string">"yue"</span>, <span class="string">"female"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subperson2.nameGroup); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// suo</span></span><br><span class="line"><span class="comment">// male</span></span><br><span class="line"><span class="comment">// bye</span></span><br><span class="line"><span class="comment">// (3) ["xiao", "ai", "suo"]</span></span><br><span class="line"><span class="comment">// (2) ["xiao", "ai"]</span></span><br></pre></td></tr></table></figure></p>
<p>写到这里，只能感叹一句，<strong>寄生组合模式简直就是一个大杂烩啊</strong>。</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
        <a href="/tags/OOP/">OOP</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2015/12/05/t-book_js_006/">
        《JavaScript高级程序设计》读后记&lt;六&gt;：对象
      </a>
    </h2>
    
    <time>
      Dec 5, 2015
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <p>上篇博客谈到了引用类型，array, function 等等。它们都有一个共同的特点就是，它们都继承于 object，它们都是对象，拥有属性和方法。我虽然搞清楚了它们的很多特性和方法，也可以用它们做一些事情。但是对象这个东西还是有很多东西是有些模糊的，这些天我看完了面向对象这一章。里面很多设计和 c++, Java 面向对象很相似，有共通的地方，但是也有很多地方是 JS 独有的特性。现在我整理出了一条思路，写下这篇博客，希望能更加透彻的理解面向对象的思想。</p>
<h3 id="理解-JavaScript-面向对象"><a href="#理解-JavaScript-面向对象" class="headerlink" title="理解 JavaScript 面向对象"></a>理解 JavaScript 面向对象</h3><p>前面已经接触过了很多对象，现在稍稍回顾一下，话不多说，上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接new对象</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">person.name = <span class="string">"suo"</span>;</span><br><span class="line">person.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;; </span><br><span class="line">person.getName(); <span class="comment">// suod</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字面量创建对象</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span>,</span><br><span class="line"></span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line">person.getName(); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>这两种创建对象的方法都是最初级的，第二个比一个好那么一点点<br>在使用更高级的创建方法之前要讨论一下对象的属性</p>
<h4 id="理解属性的特性"><a href="#理解属性的特性" class="headerlink" title="理解属性的特性"></a>理解属性的特性</h4><p><strong>ES5 定义了特性(attribute)，它是内部使用的，用来描述属性(property)的特征</strong>。这句话怎么解释呢？特性和属性，我们所知道的属性，就是对象的属性，方法。但是这些属性有一些特征，而把属性的特征称为特性。并且用两对方括号表示 [[Enumerable]]</p>
<p>下面具体谈谈这些属性的特性。<strong>分为两种特性，一种是数据特性，一种是访问器特性</strong></p>
<ul>
<li>[[Configurable]]: 能否删除而重新定义属性，能否修改属性特性</li>
<li>[[Enumerable]]: 能否通过 for-in 返回属性</li>
<li>[[Writable]]: 能否修改属性的值</li>
<li>[[Value]]: 包含属性的值</li>
</ul>
<p>下面我们举个例子具体说明这些特性的意义<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>name</code>是对象<code>person</code>的属性，[[Value]] 的值就应该是<code>&quot;suo&quot;</code>，其中<code>name</code>是可以删除和重新定义的。可以通过 for-in 返回属性，可以修改值，由此我们得出上面三个特性的默认值都是<code>true</code></p>
<p>既然属性的特性有默认的值，那么是否可以修改呢，答案是可以的<br>ES5 有一个方法可以修改属性的特性值<code>Object.defineProperty()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>, <span class="comment">// 设置特性为不能修改</span></span><br><span class="line">    value: <span class="string">"suo"</span>     <span class="comment">// 设置属性的值为"suo"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// suo</span></span><br><span class="line">person.name = <span class="string">"yue"</span>; <span class="comment">// 严格模式下导致错误</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>我们看到我们可以通过这个方法直接为属性设置值，同时设置了只读权限</p>
<p>现在我们知道属性的特性是可以重新定义和修改的，但是我们也知道特性里有一个 [[Configurable]] 可以控制是否可以修改特性，也就是设置<code>Configurable</code>为<code>false</code>，就不能再修改这个对象属性的特性了(除<code>writable</code>以外)，下面我们验证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>, <span class="comment">//设置不能删除属性，不能重新定义特性</span></span><br><span class="line">    value: <span class="string">"suo"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    value: <span class="string">"yue"</span> <span class="comment">// 出错。不能重新定义特性</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">delete</span> person.name; <span class="comment">// 不起作用，严格模式报错</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br></pre></td></tr></table></figure></p>
<p>现在看看访问器特性，包含 getter 和 setter 函数，读取访问器属性调用 getter，写入调用 setter<br>同样的访问器特性也是四个，其中前两个和数据特性一样，后两个如下</p>
<ul>
<li>[[Get]]: 读取属性时调用的函数，默认值是<code>undefined</code></li>
<li>[[set]]: 写入属性时调用的函数，默认也是<code>undefined</code></li>
</ul>
<p>同样我们来看看代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设suo是男生，yue是女生，当改变对象名字的时候，使得性别也改变</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    _name: <span class="string">"suo"</span>, <span class="comment">// 只能通过对象方法访问</span></span><br><span class="line">    gender: <span class="string">"male"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line"></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name === <span class="string">"yue"</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.gender = <span class="string">"fel"</span> + <span class="keyword">this</span>.gender;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">person.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.gender); <span class="comment">// female</span></span><br></pre></td></tr></table></figure></p>
<p><strong>说了这么多，那么使用这些特性有什么好处呢？</strong><br><code>get</code>函数内只能读，<code>set</code>函数内只能写，这样就完美的实现了读写分离，支持这个方法的需要 IE9 以上<br>上面用的都是单个属性的操作，也有可以一次操作多个属性的方法<code>defineProperties()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    _name: <span class="string">"suo"</span>,</span><br><span class="line">    gender: <span class="string">"male"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(person, &#123;</span><br><span class="line">    _name: &#123;</span><br><span class="line">        writable: <span class="literal">false</span>,</span><br><span class="line">        value: <span class="string">"yue"</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    gender: &#123;</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        value: <span class="string">"male"</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    name: &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"yue"</span> === <span class="keyword">this</span>._name) &#123;</span><br><span class="line">                <span class="keyword">this</span>.gender = <span class="string">"fe"</span> + <span class="keyword">this</span>.gender;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">person.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.gender); <span class="comment">// female</span></span><br></pre></td></tr></table></figure></p>
<p>这个方法使用的效果和上面单个方法别无二致，唯一不同的是，这些特性是同一时间创建的<br>现在我们来读取这些特性，使用方法<code>getOwnPropertyDescriptor</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">"_name"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value); <span class="comment">// yue</span></span><br></pre></td></tr></table></figure></p>
<p>前面谈了那么多关于属性的特性，现在我们该进入正题了</p>
<h4 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h4><p><strong>(1)工厂模式</strong><br> 考虑到<code>ES</code>没法创建类，所以就采用了函数封装特定的接口创建对象，下面直接上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂方法：批量生产对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.gender = gender;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o.name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"yue"</span>, <span class="string">"female"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这样写的好处就在于，本来需要单个创建的对象，通过函数的封装，可以批量的创建对象了。<br>其实它是有缺点的，<strong>虽然解决了相似对象创建的问题，但是对象的识别没法解决</strong>。</p>
<p><strong>(2)构造函数</strong><br>我们知道引用类型是通过原生的构造函数创建对象，其实构造函数是可以自定义的。所以我们现在可以通过自定义的方式来创建对象，上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.name = gender;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"yue"</span>, <span class="string">"female"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这种方式和工厂模式其实很相似，大家可能一看就知道了。它们之间有些稍稍不同的地方，这些其实很好解释，知道构造函数生成对象的过程，就很容易理解了，这两种方式其实是一个原理。<br><strong>构造函数，new 的过程</strong>:</p>
<ul>
<li>创建一个新对象</li>
<li>将作用域给新对象</li>
<li>给对象添加属性</li>
<li>返回对象</li>
</ul>
<p>现在也许大家都明白了，原来我们使用的工厂模式，其实就是在模拟构造函数生成对象的过程<br>构造函数生成的对象都有一个 constructor 属性，它就是指向构造函数本身的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.constructor == Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>由此我们可以看出，<strong>构造函数相比工厂模式的好处就在于，它解决了对象的识别问题</strong>，我们可以通过这些方式来判断，这个对象到底是由哪个函数构造的。<br>当然这种模式也是存在缺陷的，虽然我们利用工厂模式和构造函数，生产了很多对象。但是每生产一个对象，就要给对象里的属性和方法分配一块内存，然而对象的方法很多都是一样的。<strong>这样就导致了内存的大量的浪费</strong>，我们能否让这些方法共享呢？现在尝试独立这些共享方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    <span class="keyword">this</span>.getName = getName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125; <span class="comment">// 独立方法</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>虽然这是可行的，但是污染了全局作用域。<code>getName</code>虽然是全局的，单真正确是用在构造函数里面。这在开发中是一种及其不好的做法。</p>
<p><strong>(3)原型模式</strong><br>我们之前谈到函数类型，它都有一个 prototype 属性，当时没有过多的研究，现在可以好好探究一下了。首先这个属性是一个指针，指向一个对象，这个对象里面包含了所有实例共享的属性和方法。到这里你肯定明白了，<strong>原来这个原型属性就是为了解决构造函数无法共享属性和方法的啊</strong>。上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"suo"</span>;</span><br><span class="line">Person.prototype.gender = <span class="string">"male"</span>;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">//suo</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.getName()); <span class="comment">//suo</span></span><br></pre></td></tr></table></figure></p>
<p>很明显，原型对象的属性和方法，对于对象来说都是公有的，大家都一样。<br>下面继续深挖一下原型对象这种东西，有助于之后学习的理解<br><strong>只要创建函数，就会有一个 prototype 属性，这个属性指向了函数的原型对象。默认情况下所有的原型对象都会获得一个 constructor 属性，这个 constructor 是一个指向这个 prototype 所在的函数的指针</strong>。这个关系有点微妙，我还是画个图说明一下吧<br><img src="/images/dm3.png" alt="img"><br>代码验证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor); <span class="comment">// f Person()&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>其中我们可以通过<code>isProtptypeOf()</code>方法验证对象原型的对应关系<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><code>ES5</code>新增了<code>getPrototypeOf()</code>方法来获取原型值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1));</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;  name: "suo", gender: "male", getName: ƒ, constructor: ƒ &#125;</span></span><br><span class="line"><span class="comment">//    gender: "male"</span></span><br><span class="line"><span class="comment">//    getName: ƒ ()name:"suo"</span></span><br><span class="line"><span class="comment">//    constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">//    __proto__: Object</span></span><br></pre></td></tr></table></figure></p>
<p>上面我们通过这个方法把原型的全部内容打印了出来，这些都清楚了是吧<br>虽然可以通过对象访问原型的值，但是不能通过对象重写原型的值，这个原因很简单，因为我们知道，原型的属性和方法都是共享的，如果随便一个实例都能改动的话，原型就乱套了，<strong>改变一个原型的属性就会影响其他的实例</strong>。因此原型是不允许实例改变的。<strong>如果实例的属性名字与原型名字重名的话，它会屏蔽原型的属性</strong>。测试一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person1.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// yue</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.getName()); <span class="comment">// suo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person1.name; <span class="comment">// 删除属性</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>我们现在知道了，实例的属性是可以和原型重名的，那么怎么判断它到底是谁的属性呢，<strong><code>hasOwnProperty()</code>可以来检测这个属性到底是实例的还是原型的</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person1.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// yue</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> person1.name; <span class="comment">// 删除属性</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// suo</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>由此可知，<code>true</code>就是实例的，<code>false</code>就是原型的<br>现在我们没那么严苛，<strong>我们想要判断该属性是否可以被实例访问到，这里就有<code>in</code>方法可以判断</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>除此之外，如果我们还想得到所有实例的属性，也有种方法使用，for-in</strong>，当然有些不可枚举的属性是访问不到的。我们尝试去做一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (prop <span class="keyword">in</span> person1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name</span></span><br><span class="line"><span class="comment">// gender</span></span><br><span class="line"><span class="comment">// getName</span></span><br></pre></td></tr></table></figure></p>
<p>我们发现没有 protptype 属性，原因是它都是不可枚举的，[[enumerable]] 为<code>false</code><br>除此之外我们还可以使用<code>Object.keys()</code>方法来枚举对象属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(Person.prototype));</span><br><span class="line"><span class="comment">// (3) ["name", "gender", "getName"]</span></span><br></pre></td></tr></table></figure></p>
<p>关于原型的写法，同样我们可以通过字面量来批量写原型属性，方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person, // 构造函数还原</span><br><span class="line">    name: "suo",</span><br><span class="line">    gender: "male",</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure></p>
<p>要注意的一点是，字面量本身也是一个对象，<strong>原型指向字面量后指针就跑歪了，所以要我们要让它重新指向函数。这种方式仍然有个问题就是</strong>，本身 prototype 属性是不可枚举的，现在把 constructor 加上去后，导致变成可枚举的了，现在属性的特性的知识就有用武之地了，我们可以直接设置它的特性为不可枚举的，那不就可以了吗。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span>,</span><br><span class="line">    gender: <span class="string">"male"</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 添加属性值并设置特性不可枚举</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: Person</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们之前谈到不能用实例修改原型，但是我们可以直接在原型上做修改啊，修改的原型后会对实例有什么影响呢？测试一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// yue</span></span><br></pre></td></tr></table></figure></p>
<p>由此我们可知，<strong>即使是先创建了实例，修改原型属性后，实例访问的原型属性也会修改，说明原型是动态的</strong>，这其实也很简单说明。实例和原型本身就不是绑定的，我们通过原型访问，是通过指针访问的。原型里的属性改变了，我们再次通过指针访问时，当然也是改变后的属性了。<br>说了这么多，看起来原型挺好的，但是光有原型也是不够的，我们知道原型的方法和属性都是共享的，那么我私人的属性和方法该怎么办呢？<strong>那么为什么不把这两种模式结合起来呢？</strong></p>
<p><strong>(4)组合模式(构造+原型)</strong><br>结合构造和原型，我们来试着创建一个对象吧<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="comment">// constructor: Person,</span></span><br><span class="line">    origin: <span class="string">"monkey"</span>,   <span class="comment">// 起源</span></span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: Person</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"yue"</span>, <span class="string">"female"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.name === person2.name); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.origin === person2.origin);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>我们使用图示来说明这个方式<br><a href="/images/dm4.png">img</a></p>
<p><strong>(5)动态原型</strong><br>学过了其他 oop 语言，像c++，Java 都是用类封装所有的属性和方法，倒是觉得 ES 的比较奇怪了。现在就有一种方法来动态的创造原型，<strong>需要时才创建原型属性和方法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getName != <span class="string">"function"</span>) &#123;</span><br><span class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p><strong>只有当调用这个方法时，这个方法不存在，它才会被添加在原型里</strong>，使用动态模式不能用字面量方法给原型赋值，原因就是，它会将 constructor 导向新的对象，之前也遇到过。</p>
<p><strong>(6)寄生构造</strong><br>一句话，使用构造函数的工厂模式创建对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.gender = gender;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>咋一看，<strong>这不就是在构造函数里再造一个工厂模式吗？</strong>到底有啥用<br>其实这个寄生构造函数的用途，<strong>在于对原生的构造函数进行修改，重新造一个构造函数</strong>，比如下面<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建数组对象</span></span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>;</span><br><span class="line">    <span class="comment">// 添加参数</span></span><br><span class="line">    arr.push.apply(arr, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 添加方法</span></span><br><span class="line">    arr.toUpdateJoin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 返回数组</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> SpecialArray(<span class="string">"suo"</span>, <span class="string">"yue"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.toUpdateJoin()); <span class="comment">// suo|yue</span></span><br></pre></td></tr></table></figure></p>
<p>这样就改造好了，把原来数组的连接改成了<code>|</code>。</p>
<p><strong>(7)稳妥构造</strong><br>某个人发明了稳妥对象概念，什么是稳妥对象呢，<strong>它其实就是没有公共属性，不引用 this 对象</strong>。借鉴寄生构造函数，实现这个稳妥构造，上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name; <span class="comment">//注意这里没this</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>这种模式非常安全，里面没有公共属性和 this ，这样外界要访问到<code>name</code>，只能通过函数来访问了。写了这么多也差不多把面向对象搞清楚了一半，下一篇博客，专门研究面向对象里的 <strong>继承</strong>。</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
        <a href="/tags/OOP/">OOP</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2015/12/02/t-book_js_005/">
        《JavaScript高级程序设计》读后记&lt;五&gt;：引用类型
      </a>
    </h2>
    
    <time>
      Dec 2, 2015
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <p>前几篇博客，谈到了变量有 2 类数据类型，5 种基本数据类型和引用数据类型。同时也阐述了基本数据类型和引用数据类型的区别。但是一直没有提到具体的引用类型，今天专门看了引用类型一章，发现里面涉及的内容还挺多的。一时难以记住全部的内容，所以在这里写一篇博客，留做以后的学习作参考。</p>
<h3 id="理解引用类型"><a href="#理解引用类型" class="headerlink" title="理解引用类型"></a>理解引用类型</h3><p>引用类型的值(对象)是引用类型的实例，这和基本类型也是一样的，基本类型的值当然也是基本类型的实例。它们唯一的区别在于引用类型是一种数据结构，它的数据的组织更加复杂些。<br>前面也提到过，对象的创建是用 <strong>new</strong> 方法创建的。这里的所有的引用类型都类似，可以用 new 方法创建。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>; <span class="comment">// 同样的括号可以省略</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h4><p>除了上面那种创建 object 方法外还有种方法，使用对象字面量来表示<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name : <span class="string">"suo"</span>,</span><br><span class="line">    gender : <span class="string">"male"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>除此之外还有另一个写法，就是空对象，后添加属性，这也是可以的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">"suo"</span>;</span><br><span class="line">person.gender = <span class="string">"male"</span>;</span><br></pre></td></tr></table></figure></p>
<p>同时我们可以看到，object 访问属性是通过<code>.</code>来访问，其实也有另一种方法，通过<code>[]</code>来访问<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person[<span class="string">"name"</span>] = <span class="string">"suo"</span>;</span><br><span class="line">person[<span class="string">"gender"</span>] = <span class="string">"male"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"name"</span>]+<span class="string">','</span>+person[<span class="string">"gender"</span>]); <span class="comment">// suo,male</span></span><br></pre></td></tr></table></figure></p>
<p><strong>那么问题来了，什么时候用<code>.</code>，什么时候用<code>[]</code>呢？</strong><br><code>[]</code>表示法有个优点，就是他可以通过变量访问属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person[<span class="string">"name"</span>] = <span class="string">"suo"</span>;</span><br><span class="line">person[<span class="string">"gender"</span>] = <span class="string">"male"</span>;</span><br><span class="line"><span class="keyword">var</span> suo = <span class="string">"name"</span>; <span class="comment">// 将属性字符串赋值给变量</span></span><br><span class="line"><span class="built_in">console</span>.log(person[suo]+<span class="string">','</span>+person[<span class="string">"gender"</span>]); <span class="comment">// suo,male</span></span><br></pre></td></tr></table></figure></p>
<p>除此之外，都用<code>.</code>来表示，毕竟<code>.</code>表示更加方便简洁</p>
<h4 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h4><p>上面提到了 object 类型，下面具体谈一下 array 类型。其实感觉他俩挺像的，为什么这么说呢？<br>之前一段时间我一直在学习数据结构。真正的体会到了，很多看似不同的东西，其实在结构上是很相似的，甚至只是改进了一下数据的组织方式而已。<br>我们可以想象一下<code>object</code>的数据结构<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    key1 : value1,</span><br><span class="line">    key2 : value2,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>value</code>也可以是函数，对比一下数组的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="number">0</span> : value1,</span><br><span class="line">    <span class="number">1</span> : value2,</span><br><span class="line">    ...</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>其中数组中的下标是在字面量中省略的<br>很明显，它们的数据结构都是线性的序列，区别在于两点<br>1.object 的元素，可以是任意类型的。array 的一般是同一类类型的元素<br>2.object 是关联容器结构，array 是顺序容器结构。array 是寻秩访问，object 是寻关键码访问。<br><strong>谈到了它们之间的区别与联系，现在具体说一下 array 吧</strong><br>创建 array 也是有两种方法，一种是 new ,一种是字面量。和 object 差别不大<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>; <span class="comment">// 同理可省略</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    arr[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125; <span class="comment">// 1 2 3 4 5 6 7 8 9 10</span></span><br></pre></td></tr></table></figure></p>
<p>省略括号表示创建一个空的数组，数组不仅可以创建空数组，还可以创建想要的形式的数组<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// 创建包含三个元素的数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"hello"</span>); <span class="comment">// 创建包含一项元素"hello"的数组</span></span><br></pre></td></tr></table></figure></p>
<p>另外一种方式是字面量的，这种方式创建数组更加灵活<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []; <span class="comment">// 空数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"!"</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [ , , ]; <span class="comment">// 不建议使用，会生成undefined变量</span></span><br></pre></td></tr></table></figure></p>
<p>数组的长度可以用 length 得到<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.length); <span class="comment">// 4</span></span><br><span class="line">arr1[arr1.length] = <span class="number">5</span>; <span class="comment">// 添加一项</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1[<span class="number">4</span>]); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>
<p>之前谈到可以用<code>instanceof</code>来检测数组，但是它只能在一个全局内检测。所以 ES5 新增了一个方法来检测数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><code>Array</code>有很多类型的方法，我们先归一下类，以后再慢慢细究吧。<br>(1)转换方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(colors.toString()); <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.valueOf()); <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.join(<span class="string">"|"</span>)); <span class="comment">// red|blue|green</span></span><br></pre></td></tr></table></figure></p>
<p>(2)栈方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors.push(<span class="string">"yellow"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["red", "blue", "green", "yellow"]</span></span><br><span class="line">colors.pop(); </span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure></p>
<p>(3)队列方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors.push(<span class="string">"yellow"</span>, <span class="string">"black"</span>);</span><br><span class="line"><span class="keyword">var</span> pop = colors.pop(); <span class="comment">// black </span></span><br><span class="line"><span class="keyword">var</span> head = colors.shift();  <span class="comment">// red</span></span><br><span class="line">colors.unshift(<span class="string">"red"</span>, <span class="string">"black"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(pop+<span class="string">','</span>+head); </span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["red", "black", "blue", "green", "yellow"]</span></span><br></pre></td></tr></table></figure></p>
<p>(4)重排序方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转组项顺序</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>,  <span class="number">4</span>];</span><br><span class="line">num.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 4,5,2,3,1</span></span><br><span class="line"><span class="comment">//升序排序</span></span><br><span class="line">num.sort();</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure></p>
<p>(5)操作方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 粘贴(新数组)</span></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.concat(<span class="string">"yellow"</span>, [<span class="string">"black"</span>, <span class="string">"white"</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(colors2);</span><br><span class="line"><span class="comment">// (6) ["red", "blue", "green", "yellow", "black", "white"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 截切(新数组)</span></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> colors3 = colors.slice(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 不包含1</span></span><br><span class="line"><span class="built_in">console</span>.log(colors2); <span class="comment">// ["blue", "green"]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors3); <span class="comment">// ["red"]co</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换(原数组上操作)</span></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors.splice(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors)</span><br><span class="line">colors.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"yellow"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors)</span><br><span class="line">colors.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors)</span><br><span class="line"><span class="comment">//(2) ["red", "green"]</span></span><br><span class="line"><span class="comment">//(3) ["red", "yellow", "green"]</span></span><br><span class="line"><span class="comment">//(3) ["red", "black", "green"]</span></span><br></pre></td></tr></table></figure></p>
<p>(6)位置方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正向查找</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(num.indexOf(<span class="number">3</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 逆向查找</span></span><br><span class="line"><span class="built_in">console</span>.log(num.lastIndexOf(<span class="number">3</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>(7)迭代方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每项都</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> res = num.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 每项结果</span></span><br><span class="line"><span class="keyword">var</span> res2 = num.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// [3, 5, 4]</span></span><br><span class="line"><span class="comment">// 每项运行</span></span><br><span class="line"><span class="keyword">var</span> res3 = num.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    num = num * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res3);</span><br><span class="line"><span class="comment">// 每次结果数组</span></span><br><span class="line"><span class="keyword">var</span> res4 = num.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item * <span class="number">2</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res4);</span><br><span class="line"><span class="comment">// 任一项</span></span><br><span class="line"><span class="keyword">var</span> res5 = num.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);  </span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res5);</span><br></pre></td></tr></table></figure></p>
<p>(8)归并方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正向归并</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = num.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 逆向归并</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = num.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h4><p>我们可能学习过 Java 中的 Date 类型，其实 ES 也是借鉴它构建的。使用的也是 UTC 来保存日期。保存的日期的范围为 1970.1.1 前后的 1 亿年。<br>使用<code>new</code>创建<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line"><span class="built_in">console</span>.log(now); <span class="comment">// Sun Dec 02 2016 11:10:38 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure></p>
<p><strong>由此得知，Dete对象默认创建的是当前的时间，那怎么得到特定的时间呢?</strong><br>有两种方法：一种是<code>Date.parse()</code>，另一种是<code>Date.UTC()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">"Nov 12, 1995"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(someDate); <span class="comment">// Fri Nov 12 1995 00:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="comment">// 省略Date.parse也是可以的</span></span><br><span class="line"><span class="keyword">var</span> someDate2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"Sep 22, 1996"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(someDate2); <span class="comment">// Sun Sep 22 1996 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure></p>
<p>上面的方法返回的是日期对象，下面再测试一下<code>Date.UTC()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">1995</span>, <span class="number">11</span>, <span class="number">12</span>));</span><br><span class="line"><span class="built_in">console</span>.log(someDate); <span class="comment">// Sun Dec 12 1995 08:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line"><span class="keyword">var</span> someDate2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1995</span>, <span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(someDate2); <span class="comment">//Tue Dec 12 1995 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure></p>
<p>由此我们得知，这两种方法都是可以自动调用的，调用哪一种方法取决于传入的参数。<br><code>ES5</code>新增了一种<code>now()</code>方法，可以取得当前时间的毫秒数，那么我们可以用它做一些有用的事<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    sum = i*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> end = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="keyword">var</span> runtime = end - start;</span><br><span class="line"><span class="built_in">console</span>.log(runtime); <span class="comment">// 10(ms)</span></span><br></pre></td></tr></table></figure></p>
<p>用+操作符也可以达到同等目的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> +<span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure></p>
<p>因为时间本身是毫秒数，所有可以用<code>&gt;</code>或者<code>&lt;</code>比较日期<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2016</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(date1 &gt; date2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>格式化日期<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line"><span class="built_in">console</span>.log(date.toDateString()); <span class="comment">// Sun Dec 02 2016</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toTimeString()); <span class="comment">// 11:53:46 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toLocaleDateString()); <span class="comment">// 2016/12/2</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toUTCString()); <span class="comment">// Sun Dec 02 2016 11:53:46 GMT</span></span><br></pre></td></tr></table></figure></p>
<p>日期组件方法，都是一些 get，set 方法，这里就不一一说了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line"><span class="built_in">console</span>.log(date.getTime()); <span class="comment">// 1506830282288(ms)</span></span><br></pre></td></tr></table></figure></p>
<h4 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h4><p>我学过 PHP 的正则表达式，学过 Java 的正则表达式，很有意思的是现在又学<code>JS</code>的正则表达式，相对来说容易很多了，除了调用的方法名有所不同以外，其他的内容几乎无差别<br>首先创建一个正则表达式，同样是两种方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"pat"</span>,<span class="string">"flags"</span>); <span class="comment">// new对象</span></span><br><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/pat/</span>flags; <span class="comment">// 字面量</span></span><br></pre></td></tr></table></figure></p>
<p>稍微解释一些这个表达式的含义，<code>/</code>这个是表达式的定界符，就是隔离正则与其他字符的一个分界，为其他字符也可以，表达式后面的<code>flags</code>是一个标记，就是来切换正则表达式匹配规则的模式。<br>常见的模式有 g 表示全局模式，i 不区分大小写，m 多行模式，举几个例子说明下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/i</span>;</span><br></pre></td></tr></table></figure></p>
<p>解释一下，<code>suo</code>是正则法则，i 是模式，也就是匹配字符<code>suo</code>,且不区分大小写<br>使用<code>test</code>来测试是否匹配上<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/i</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pat.test(<span class="string">"Suo"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.test(<span class="string">"SUO"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.test(<span class="string">"sso"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>ES5 规定，使用字面量创建正则必须像直接调用 RegExp 构造函数一样，每次都要创建新的实例。<br>下面我们来看看实例的属性和方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/i</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pat.global); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.ignoreCase); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.multiline); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.lastIndex); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.source); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>这些属性都是正则表达式本身具有的一些属性，没啥用，<br>但是它的两个方法是我们要掌握的，<strong>第一个就是<code>exec()</code>它是用来捕获组的</strong>，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/ig</span>; <span class="comment">// 全局模式</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"suo: I am Suoyue"</span>;</span><br><span class="line"><span class="keyword">var</span> matches = pat.exec(str);</span><br><span class="line"><span class="comment">// 第一次捕获</span></span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches.input); <span class="comment">// suo: I am suo yue"</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">// suo</span></span><br><span class="line"><span class="comment">// 第二次捕获</span></span><br><span class="line">matches = pat.exec(str);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">// Suo</span></span><br></pre></td></tr></table></figure></p>
<p>正如上面所说，每一次捕获都要创建实例，都要再执行一遍捕获方法<br><strong>另一种方法是<code>test()</code>方法，他是一个判断是否匹配，正如它的名字，只是测试而已</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/i</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"suo: I am Suoyue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pat.test(str)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>假设我现在捕获到了一个组，我们怎么取得我们想要的东西呢？</strong><br>答案是使用RegExp的构造函数属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/ig</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"ss suo: I am Suoyue"</span>;</span><br><span class="line"><span class="keyword">if</span> (pat.test(str)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$_);    <span class="comment">// 最近一次要匹配的字符串 suo: I am Suoyue</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$`"</span>]); <span class="comment">// 最近匹配项前面的字符串 ss</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$'"</span>]); <span class="comment">// 最近匹配项后面的字符串 : I am Suoyue</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$&amp;"</span>]); <span class="comment">// 最近一次匹配项 suo</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$+"</span>]); <span class="comment">// 最近匹配的捕获组 [空]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$*"</span>]); <span class="comment">// 是否使用多行模式 (未实现)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了上面 6 个以外还有很多，不一一累述了<br>虽 ES 正则表达式功能还是比较完备的，但是对于 PHP 和 Java  还是缺少很多高级特性，作为一个前端的脚本语言，这些已经足够了</p>
<h4 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h4><p>前面我们一直提到函数，他是对象，它可以赋值给变量，它是 ES 中最小的作用域。但是一直我都没有具体研究它，现在我读了函数这章，很多之前的稍有疑问的地方，现在都豁然开朗了。</p>
<p>之前也说过，<strong>函数有两种表达方式，一种是使用函数声明，一种是使用函数表达式</strong>。我们稍微回顾一些这两种形式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//code...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//code...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意的是函数声明是会有函数声明提升的，之前也讲过，这里不在累述了。<br>由上面可以看出，函数包含函数名，函数本体，也就是<code>{}</code>里面的内容</p>
<p>函数实际是对象，<strong>那么函数名实际上是一个指向函数对象的指针，不会与某个函数绑定</strong><br>这句话怎么理解呢？下面给出一个例子来说明这个问题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"suo"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> boo = foo;</span><br><span class="line">foo = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 经测试foo解引用后，运行会出错</span></span><br><span class="line">boo(); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>由上面的代码可以看出，<code>foo</code>只是一个指向函数对象的指针，当使用解引用后，断绝了这个关系了。而<code>boo</code>又指向了函数对象，所以可以运行。</p>
<p>下面我们来探讨另一个问题，既然我们已经得出结论，函数名只是一个指向函数对象的指针。那函数就不应该有重载这个特性。因为同一个函数名是指向同一个函数对象的。就不会指向其他对象的说法<br>下面我们也来例证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"suo"</span>;</span><br><span class="line"><span class="keyword">var</span> gender = <span class="string">"male"</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name+<span class="string">','</span>+gender);</span><br><span class="line">&#125;</span><br><span class="line">foo(name); <span class="comment">// suo,undefined</span></span><br><span class="line">foo(name, gender); <span class="comment">// suo,male</span></span><br></pre></td></tr></table></figure></p>
<p>由上可知，如果函数有重载的话，第一个<code>foo</code>执行的结果应该是<code>suo</code>，但是实际的结果确实<code>suo</code>，<code>undefined</code>。很显然第一个函数执行的也是第二个函数表达式。第二个表达式的函数覆盖了之前的。<br>得出结论，<strong>函数重名会覆盖，不管参数是怎样的</strong></p>
<p>上面也提到了函数是对象，那么函数就可以给其他变量赋值。不仅如此函数还可以作为返回值用。<br>下面看一个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较人的身高</span></span><br><span class="line"><span class="keyword">var</span> suo = &#123;</span><br><span class="line">    height : <span class="number">180</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> yue = &#123;</span><br><span class="line">    height : <span class="number">170</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">campareHeight</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params">suo, yue</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (suo.height &gt; yue.height) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (suo.height &lt; yue.height) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(suo, yue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(campareHeight(<span class="string">"height"</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>这里要提醒下，函数声明是不可以直接做返回值的，只有执行后的函数才能做返回值.一般这种情况我，使用立即执行函数一步来搞定，下面写一个立即执行函数的简单例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明与执行分步写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo()); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 使用立即执行函数一步写</span></span><br><span class="line"><span class="built_in">console</span>.log( (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;)() ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>函数内部有两个特殊的对象：arguments 和 this</strong><br>arguments 是一个类数组对象，包含传入函数的所以参数主要用来保存函数参数的，这个对象有一个叫 callee 的属性，它是一个指针，指向拥有这个 arguments 对象的函数。<br>下面一个例子告诉我们caller的用法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>); <span class="comment">// 3628800</span></span><br></pre></td></tr></table></figure></p>
<p>其实这个就是 10 的阶乘。关键在于这行代码<code>arguments.callee(num-1)</code>，我们再仔细揣摩这句话，<strong>callee 的属性，它是一个指针，指向拥有这个 arguments 对象的函数</strong>，现在明白了<code>arguments.callee(num-1)</code>就等同于<code>foo(num-1)</code>，这样就清楚了。<br>该说说 this 了，我看了半天书上的叙述，总结了一句话，<strong>当在哪个作用域调用函数时，该函数中的 this 就是哪个作用域对象</strong><br>下面验证下这句话的正确性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局调用</span></span><br><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    color: <span class="string">"blue"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">getColor(); <span class="comment">// red</span></span><br><span class="line">o.getColor = getColor;</span><br><span class="line">o.getColor(); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure></p>
<p>另一个是<code>caller</code>，表示调用当前函数的函数的引用，全局作用域为<code>null</code>，验证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    boo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(boo.caller); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.caller); <span class="comment">// null</span></span><br><span class="line">foo(); <span class="comment">// ƒ foo() &#123; boo();&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这里可以看到显示了 foo 的源码，下面用另一种方式实现这个效果(根据 callee 的用法好理解)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    boo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.caller); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.caller); <span class="comment">// null</span></span><br><span class="line">foo(); <span class="comment">// ƒ foo() &#123; boo();&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这种写法虽然现在可以，但是出于安全性考虑，严格模式下已经不许这样做了，另外严格模式下函数的 caller 属性是不能赋值的</p>
<p>都说对象是有属性方法的，函数也不例外，下面谈谈函数的属性和方法吧<br>函数有两个属性一个是 leghth，一个是 prototype ，前面一个是指希望接受参数个数，没什么好说的。关键在于这个 prototype 属性,这个属性是ES搞面向对象专门搞得一个属性，这里不谈太多了，下一篇博客研究对象和继承时。好好探究这个属性。这里就简单提几点，ES5 中，prototype 属性太多，是无法使用 for-in 枚举的。</p>
<p>下面我们聊聊,<strong>函数的两个独有的方法</strong>，说独有是因为它不是其他对象有的，因为它们关系到作用域。我们知道 ES 就只有函数作用域，所以这一切搜说得通了。<br>这两个方法，一个是<code>apply()</code>,一个是<code>call()</code>,这两个函数有很多相似之处。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callFoo</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">callFoo(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>这里我的理解是，apply这个函数，是将 callFoo 的 this 对象和 arguments 传给了 foo，并执行结果返回给 callFoo，也可以不用自己的 arguments 对象，随意传一个数组也可以。因为 arguments 本身也是一个数组。如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callFoo</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.apply(<span class="keyword">this</span>, [<span class="number">3</span>, <span class="number">2</span>]); <span class="comment">// 替换成自己的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不写参数看看</span></span><br><span class="line">callFoo(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>果然是这样，证明我的理解是正确的。<br>理解了 apply，call 也就好理解了，它们区别就在于参数，不同于 apply，一个作用域和一个参数数组。<strong>call 的参数要全部单独写出来</strong>。改变上面的代码，看看<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callFoo</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.call(<span class="keyword">this</span>, <span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 参数数组变成单个参数</span></span><br><span class="line">&#125;</span><br><span class="line">callFoo(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>一切都在意料之中，果然是这样。<br>说了这么这两个方法，它们有啥用呢？<strong>它们的真正用处在于扩充函数的作用域</strong><br>下面看一个例子你就明白了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    color: <span class="string">"blue"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">getColor();            <span class="comment">// red</span></span><br><span class="line">getColor.call(<span class="keyword">this</span>);   <span class="comment">// red</span></span><br><span class="line">getColor.call(<span class="built_in">window</span>); <span class="comment">// red</span></span><br><span class="line">getColor.call(o);      <span class="comment">// blue</span></span><br></pre></td></tr></table></figure></p>
<p>这里你是否明白了呢，<code>getColor</code>本来是全局作用域，本应该是输出<code>red</code>，绑定<code>o</code>后，竟然可以输出对象的变量。这样做的最大好处是函数既访问到了对象的变量，而且和对象没有形成耦合关系。<br>最后说一个 ES 方法<code>bind()</code>。下面看一下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    color: <span class="string">"blue"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oGetColor = getColor.bind(o);</span><br><span class="line">oGetColor(); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure></p>
<p>这个方法比<code>call()</code>更直接，直接实现函数对象绑定的值，并给一个新的函数。这个就牛逼了，具有<code>call()</code>的好处,并且更加直接，好理解。</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
</section>


  <nav id="page-nav">
    
    
    <a class="next" rel="next" href="/categories/JavaScript/page/2/">
      <span class="text">Next</span>
      <span class="icon icon-chevron-right"></span>
    </a>
    
  </nav>
  

      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<div class='header'>suoyue</div>
<div class='content'>
<div class='desc'>Tempora mutantur, nos et mutamur in illis ...</div>
</div>
</section>

  <section class='m_widget links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="https://ccoooss.com">
            <div class='name'>ClassicOldSong</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://frantic1048.logdown.com/">
            <div class='name'>Frantic1048</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://hclmaster.github.io/">
            <div class='name'>Hclmaster</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://whst.github.io/">
            <div class='name'>WANG Hsü-Tung</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/C/"><div class='name'>C</div><div class='badget'>6</div></a></li>
    
        <li><a class="flat-box" href="/categories/CSS/"><div class='name'>CSS</div><div class='badget'>4</div></a></li>
    
        <li><a class="flat-box" href="/categories/HTML/"><div class='name'>HTML</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/JavaScript/"><div class='name'>JavaScript</div><div class='badget'>14</div></a></li>
    
        <li><a class="flat-box" href="/categories/vue/"><div class='name'>vue</div><div class='badget'>2</div></a></li>
    
        <li><a class="flat-box" href="/categories/web开发/"><div class='name'>web开发</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/前端工具/"><div class='name'>前端工具</div><div class='badget'>4</div></a></li>
    
        <li><a class="flat-box" href="/categories/算法/"><div class='name'>算法</div><div class='badget'>2</div></a></li>
    
        <li><a class="flat-box" href="/categories/编程基础/"><div class='name'>编程基础</div><div class='badget'>10</div></a></li>
    
        <li><a class="flat-box" href="/categories/通用工具/"><div class='name'>通用工具</div><div class='badget'>4</div></a></li>
    
    </ul>
    
</div>
</section>

  
<div class="m_widget tagcloud">
    <div class="header">Tags</div>
    <div class='content'>
        <a href="/tags/C/" style="font-size: 17.6px; color: #333">C</a> <a href="/tags/CSS/" style="font-size: 16.4px; color: #4d4d4d">CSS</a> <a href="/tags/ECMAScript6/" style="font-size: 15.2px; color: #666">ECMAScript6</a> <a href="/tags/HTML/" style="font-size: 14px; color: #808080">HTML</a> <a href="/tags/HTML5/" style="font-size: 14px; color: #808080">HTML5</a> <a href="/tags/JavaScript/" style="font-size: 20px; color: #000">JavaScript</a> <a href="/tags/OOP/" style="font-size: 15.2px; color: #666">OOP</a> <a href="/tags/css/" style="font-size: 14px; color: #808080">css</a> <a href="/tags/git/" style="font-size: 14px; color: #808080">git</a> <a href="/tags/gulp/" style="font-size: 14px; color: #808080">gulp</a> <a href="/tags/jQuery/" style="font-size: 14px; color: #808080">jQuery</a> <a href="/tags/php/" style="font-size: 14px; color: #808080">php</a> <a href="/tags/sass/" style="font-size: 14px; color: #808080">sass</a> <a href="/tags/webpack/" style="font-size: 14px; color: #808080">webpack</a> <a href="/tags/垂直居中/" style="font-size: 14px; color: #808080">垂直居中</a> <a href="/tags/数据结构/" style="font-size: 18.8px; color: #1a1a1a">数据结构</a> <a href="/tags/框架/" style="font-size: 15.2px; color: #666">框架</a> <a href="/tags/测试/" style="font-size: 14px; color: #808080">测试</a> <a href="/tags/生活杂感/" style="font-size: 14px; color: #808080">生活杂感</a> <a href="/tags/盒子模型/" style="font-size: 14px; color: #808080">盒子模型</a> <a href="/tags/算法/" style="font-size: 15.2px; color: #666">算法</a> <a href="/tags/编辑器/" style="font-size: 15.2px; color: #666">编辑器</a> <a href="/tags/自动化工具/" style="font-size: 14px; color: #808080">自动化工具</a> <a href="/tags/设计模式/" style="font-size: 14px; color: #808080">设计模式</a>
    </div>
</div>



      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/stkevintan" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/kevinsfork" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  
  <div>Theme <a href='https://github.com/stkevintan/hexo-theme-material-flow' class="codename">MaterialFlow</a> designed by <a href="http://keyin.me/" target="_blank">Kevin Tan</a>.</div>
  
</footer>


  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<script src="/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
