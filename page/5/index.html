<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="保持乐观，保持谦虚">
<meta property="og:type" content="website">
<meta property="og:title" content="锁越smile">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="锁越smile">
<meta property="og:description" content="保持乐观，保持谦虚">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="锁越smile">
<meta name="twitter:description" content="保持乐观，保持谦虚">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/"/>





  <title>锁越smile</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">锁越smile</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">邵锁的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/10/book-note9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suoyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="锁越smile">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/10/book-note9/" itemprop="url">《JavaScript高级程序设计》读后记<九>：DOM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-10T22:31:11+08:00">
                2015-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>DOM 为 <strong>Document Object Model</strong> 的缩写，也是 HTML 和 XML 文档的一个 API 接口。描绘的是一个层次化节点树，允许开发人人添加移除和修改页面的某一部分。</p>
<h4 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>用一个图片描述一下</p>
<p>1.Node 类型</p>
<p><strong>属性</strong><br>(1)nodeType<br>JavaScipt中的所有节点类型都继承与Node类型。因此所有节点都共享着相同的基本属性和方法<br>每个节点都有个NodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的下列12个数值常量来表示，任何节点类型必居其一</p>
<ul>
<li>Node.ElEMNRT_NODE</li>
<li>Node.ATTRIBUTE_NODE</li>
<li>Node.TEXT_NODE</li>
<li>Node.CDATASELECTION_NODE</li>
<li>Node.ENTITY_REFERENCE_NODE</li>
<li>Node.ENYIYY_NODE</li>
<li>Node.PROCESSING_INSTUCATION_NODE</li>
<li>Node.COMMENT_NODE</li>
<li>Node.DOCUMNENT_NODE</li>
<li>Node.DOCUMENT_TYPE_NODE</li>
<li>Node.DOCUMENT_FRAGMENT_NODE</li>
<li>Node.NOTATION_NODE</li>
</ul>
<p>通过比较上面这些常量很容易确定节点的类型<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nodeTyep == Node.ELEMENT) &#123;</span><br><span class="line">    alert(<span class="string">"node is element type"</span>); <span class="comment">// ie无效</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以直接与数字比较</span></span><br></pre></td></tr></table></figure></p>
<p>(2)nodeName：保存标签名<br>(3)nodeValue：null<br>(4)childNodes:保存着NodeList对象，一组有序的序列<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstChild = someNode.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> length = someNode.childNodes.length;</span><br></pre></td></tr></table></figure></p>
<p>(5)parentNode:指向文档父节点<br>(6)nextSibling:下一个节点<br>(7)previouSibling:上一个节点<br>(8)ownerDocument:整个文档的文档节点</p>
<p><strong>方法</strong><br>(1)appendChild方法<br>在childNodes列表的末尾添加一个节点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> returnedNode = someNode.appendChild(newNode);</span><br></pre></td></tr></table></figure></p>
<p>(2)insertBefore方法<br>插入特定的位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入到第一个</span></span><br><span class="line"><span class="keyword">var</span> aNode1 = someNode.appendChild(newNode, someNode.firstChild);</span><br><span class="line"><span class="comment">// 插入到倒数第二个</span></span><br><span class="line"><span class="keyword">var</span> aNode2 = someNode.appendChild(newNode, someNode.lastChild);</span><br></pre></td></tr></table></figure></p>
<p>(3)replaceChild方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换第一个</span></span><br><span class="line"><span class="keyword">var</span> aNode1 = someNode.replaceChild(newNode, someNode.firstChild); </span><br><span class="line"><span class="comment">// 替换最后一个</span></span><br><span class="line"><span class="keyword">var</span> aNode2 = someNode.replaceChild(newNode, someNode.lastChild);</span><br></pre></td></tr></table></figure></p>
<p>(4)removeChild方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除第一个</span></span><br><span class="line"><span class="keyword">var</span> aNode1 = someNode.removeChild(newNide, someNode.firstChild);</span><br><span class="line"><span class="comment">// 移除最后一个</span></span><br><span class="line"><span class="keyword">var</span> aNode2 = someNode.removeChild(newNide, someNode.laststChild);</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Document 类型<br>表示文档，在浏览器中document对象是HTMLDocument的一个实例，表示整个HTML页面。document对象是window对象的一个属性，因此document作为全局对象来访问</li>
</ol>
<ul>
<li>nodeType:9</li>
<li>NodeName:#document</li>
<li>nodeValue:null</li>
<li>parentNode:null</li>
<li>ownerDocument:null</li>
</ul>
<p>(1)文档子节点<br>2个快捷访问方式，一个是documentElement属性，一个是childNodes访问文档元素</p>
<ul>
<li><p><code>documentElement</code>属性，指向<code>&lt;html&gt;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="built_in">document</span>.documentElement;</span><br><span class="line"><span class="built_in">console</span>.log(html === <span class="built_in">document</span>.childNodes[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(html === <span class="built_in">document</span>.firstChild);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>body</code>属性，直接指向<code>&lt;body&gt;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>所有浏览器都支持document.documentElement和document.body</p>
<ul>
<li><code>doctype</code>属性，指向<code>&lt;!DOCTYPE&gt;</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> docType = <span class="built_in">document</span>.doctype;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>(2)文档信息</p>
<ul>
<li><code>title</code>属性，指向<code>&lt;title&gt;</code></li>
<li><code>URL</code>属性</li>
<li><code>domain</code>属性</li>
<li><code>referrer</code>属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aTitle = <span class="built_in">document</span>.title;</span><br><span class="line"><span class="comment">// 完整URL</span></span><br><span class="line"><span class="keyword">var</span> aUrl = <span class="built_in">document</span>.url;</span><br><span class="line"><span class="comment">// 域</span></span><br><span class="line"><span class="keyword">var</span> aDomain = <span class="built_in">document</span>.domain;</span><br><span class="line"><span class="comment">// 来源URL</span></span><br><span class="line"><span class="keyword">var</span> aReferrer = <span class="built_in">document</span>.referrer</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>(3)查找元素</p>
<ul>
<li><p><code>getElementById</code>方法:取ID元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">"mydiv"</span>); <span class="comment">// 早期版本不分大小写</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>getElementsByTagName</code>方法:取元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(aLi[<span class="number">0</span>].innerHTML);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部</span></span><br><span class="line"><span class="keyword">var</span> all = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"*"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>getElementsByName</code>方法：取name所有元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> radio = <span class="built_in">document</span>.getElementsByName(<span class="string">"color"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>(4)特殊集合</p>
<ul>
<li>document.anchors: 所有<code>&lt;a&gt;</code></li>
<li>document.applets: 所有带name的<code>&lt;a&gt;</code></li>
<li>document.forms: 所有<code>&lt;form&gt;</code>元素</li>
<li>document.images: 所有<code>&lt;img&gt;</code>元素</li>
<li>document.links: 所有带src的<code>&lt;a&gt;</code>元素</li>
</ul>
<p>(5)DOM 一致性检测<br>DOM 有多个级别。实现DOM检测就有很大必要了,implementation,规定了一个方法hasFeature<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasXmlDom = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"XML"</span>, <span class="string">"1.0"</span>);</span><br></pre></td></tr></table></figure></p>
<p>(6)文档写入</p>
<ul>
<li>write():原样写入</li>
<li>writeln():写入换行</li>
<li>open()</li>
<li>close()</li>
</ul>
<ol>
<li>Element 类型</li>
</ol>
<ul>
<li>nodeType:1</li>
<li>nodeName:标签名</li>
<li>nodeValue:null</li>
<li>parentNode:可是Document或者Element</li>
<li>childNodes:都可能</li>
</ul>
<p>(1)HTML元素</p>
<ul>
<li>id: 元素在文档唯一标识符</li>
<li>title: 附加说明</li>
<li>lang: 语言代码</li>
<li>dir: 语言的方向</li>
<li>className: 与class对应，之所以不用class是因为class是ES保留字</li>
</ul>
<p>这些值都可以用来修改<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"suo"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">title</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">""</span> <span class="attr">lang</span>=<span class="string">""</span> <span class="attr">dir</span>=<span class="string">""</span>&gt;</span>name<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ie8之前不能访问 --&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>(2)特性</p>
<ul>
<li>getAttribute()</li>
<li>setAttrubute()</li>
<li>removeAttribute()</li>
</ul>
<p>(3)创建元素<br>document.createElement方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">div.id = <span class="string">"suo"</span>;</span><br><span class="line">div.className = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="string">"div"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完整插入</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"&lt;div id=\"suo\" class=\"yue\"&gt; &lt;/div&gt;"</span>);</span><br></pre></td></tr></table></figure></p>
<p>(4)元素的子节点<br>不同浏览器解析不一样</p>
<ul>
<li>IE不解析间隔</li>
<li>其他浏览器连间隔也解析</li>
</ul>
<p>4.Text 类型</p>
<ul>
<li>nodeType: 3</li>
<li>nodeName: “#text”</li>
<li>nodeValue: 节点文本</li>
<li>parentNode是一个Element</li>
<li>没有子节点</li>
<li>appendData(text): 插入节点末尾</li>
<li>deleteDate(offset, count): 删除文本</li>
<li>insertData(offset, text): 插入文本</li>
<li>replaceData(offset, count, text): 替换文本</li>
<li>splitText(offset): 分割文本</li>
<li>substringData(offset, count): 提取字符串</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 没有内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 有个空格 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 有内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得文本</span></span><br><span class="line"><span class="keyword">var</span> textNode = div.firstChild;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> textNode = div.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 修改值</span></span><br><span class="line">textNode.nodeValue = <span class="string">"suoyue"</span>;</span><br></pre></td></tr></table></figure>
<p>(1)创建文本节点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"&lt;p&gt;hello world!&lt;/p&gt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分开创建</span></span><br><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</span><br><span class="line">element.className = <span class="string">"color"</span>;</span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"hello world!"</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br></pre></td></tr></table></figure></p>
<p>(2)规范文本节点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.normalize(); <span class="comment">// 将多个文本节点合并成一个文本节点</span></span><br></pre></td></tr></table></figure></p>
<p>5.Comment 类型<br>注释在DOM里面用Comment类型表示</p>
<ul>
<li>nodeType: 8</li>
<li>nodeName: “#comment”</li>
<li>nodeValue: “注释的内容”</li>
<li>parentNode 可能是Document或者Element</li>
<li>不支持子节点</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"mydiv"</span>);</span><br><span class="line"><span class="keyword">var</span> comment = div.firstChild;</span><br><span class="line"><span class="built_in">console</span>.log(comment);</span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line"><span class="keyword">var</span> comment = <span class="built_in">document</span>.createComment(<span class="string">"good job"</span>);</span><br></pre></td></tr></table></figure>
<p>6.CDATASection 类型</p>
<ul>
<li>nodeType: 4</li>
<li>nodeName: “#cdata-section”</li>
<li>nodeValue: CDATA区域内容</li>
<li>parentNode 可能是Document或者Element</li>
<li>不支持子节点</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cdata = <span class="built_in">document</span>.createCDateSection();</span><br></pre></td></tr></table></figure>
<p>7.DocumentType 类型<br>仅FireFox,Safari,Oprea支持</p>
<ul>
<li>nodeType: 10</li>
<li>nodeName: doctype的名称</li>
<li>nodeValue: null</li>
<li>parentNode: Document</li>
<li>不支持子节点</li>
</ul>
<p>8.DocumentFragment 类型<br>轻量级文档，文档片段</p>
<ul>
<li>nodeType: 11</li>
<li>nodeName: “#document-fragment”</li>
<li>nodeValue: null</li>
<li>parentNode: null</li>
<li>子节点可以为各种</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFrament();</span><br><span class="line">va ul = <span class="built_in">document</span>.getElementById(<span class="string">"list"</span>);</span><br><span class="line"><span class="keyword">var</span> li = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">    li.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Item"</span> + (i+<span class="number">1</span>)));</span><br><span class="line">    fragment.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure>
<p>9.Attr 类型</p>
<ul>
<li>nodeType: 2</li>
<li>nodeName: 特性的名称</li>
<li>nodeValue: 特性的值</li>
<li>parentNode: null</li>
<li>HTML没有子节点</li>
<li>XML里面子节点可以是TEXT或者EntityReference</li>
</ul>
<h4 id="DOM-操作技术"><a href="#DOM-操作技术" class="headerlink" title="DOM 操作技术"></a>DOM 操作技术</h4><p>DOM操作比较简明，原本不会很麻烦，但是由于浏览器有个隐性的陷阱和不兼容的问题，JavaScript操作还比较麻烦<br>1.动态脚本<br>动态加载外部文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">script.src = <span class="string">"suo.js"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数封装一下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">$url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">    script.src = $url;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.动态样式<br>与动态脚本一样<br>3.操作表格<br>4.使用NodeList</p>
<h4 id="DOM-选择符API"><a href="#DOM-选择符API" class="headerlink" title="DOM 选择符API"></a>DOM 选择符API</h4><p>1.querySelector 方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受选择符，返回与该模式匹配的第一个元素</span></span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">"body"</span>);</span><br><span class="line"><span class="keyword">var</span> myid = <span class="built_in">document</span>.querySelector(<span class="string">"#myid"</span>);</span><br><span class="line"><span class="keyword">var</span> myclass = <span class="built_in">document</span>.querySelector(<span class="string">".myclass"</span>);</span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.querySelector(<span class="string">"img.myclass"</span>);</span><br></pre></td></tr></table></figure></p>
<p>2.querySelectorAll 方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受选择符，返回的是一个NodeList实例</span></span><br><span class="line"><span class="keyword">var</span> nodeList = <span class="built_in">document</span>.querySelector(<span class="string">".myclass"</span>);</span><br></pre></td></tr></table></figure></p>
<p>3.machesSelector 方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受选择符，返回True或者false</span></span><br><span class="line"><span class="keyword">var</span> hasCLass = <span class="built_in">document</span>.matchesSelector(<span class="string">"body.myclass"</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h4><p>新增的一组属性，为了让IE的行为一致</p>
<ul>
<li>childElementCount: 返回子元素个数</li>
<li>firstElementChild: 指向第一个子元素</li>
<li>lastAElementChild: 指向最后一个子元素</li>
<li>previousElementSibling: 指向后一个同辈元素</li>
<li>nextElementSibling: 指向前一个子元素</li>
</ul>
<h4 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h4><p>1.与类相关的扩充</p>
<ul>
<li>getElementsByClassName()</li>
<li>classList 属性</li>
</ul>
<p>2.焦点管理</p>
<ul>
<li>document.activeElement</li>
</ul>
<p>3.HTMLDocument的变化</p>
<ul>
<li>readyState 属性</li>
<li>兼容模式</li>
<li>head 属性</li>
</ul>
<p>4.字符集属性<br><code>document.charset = &quot;UTF-8</code></p>
<p>5.自定义属性类型<br><code>data-</code></p>
<p>6.插入标记</p>
<ul>
<li>innerHTML 属性</li>
<li>outerHTML 属性</li>
<li>insertAdjacentHTML 方法</li>
<li>内存与性能</li>
<li>scrollIntoView方法</li>
</ul>
<h4 id="扩展（了解）"><a href="#扩展（了解）" class="headerlink" title="扩展（了解）"></a>扩展（了解）</h4><p>1.文档模式</p>
<ul>
<li>IE5: 混杂模式</li>
<li>IE7: IE7标准模式</li>
<li>IE8: IE8标准模式</li>
<li>IE9: IE9标准模式，ES5，CSS3，H5大部分功能</li>
</ul>
<p>2.children 属性<br>3.contains 方法<br>4.插入文本<br>5.滚动</p>
<!-- #### DOM2和DOM3 -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/08/book-note8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suoyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="锁越smile">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/08/book-note8/" itemprop="url">《JavaScript高级程序设计》读后记<八>：BOM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-08T22:31:11+08:00">
                2015-12-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前几章学了 JavaScript 的基础的知识，理论性太强。需要思考理解的东西远远多于实战的。我最近看了 BOM 这一章，才真正的感受到了 JavaScript 真的很强大，特别是在于操作浏览器这方法。不多写了，已经等不急实战了。</p>
<h3 id="理解BOM"><a href="#理解BOM" class="headerlink" title="理解BOM"></a>理解BOM</h3><h4 id="使用-Window-对象"><a href="#使用-Window-对象" class="headerlink" title="使用 Window 对象"></a>使用 Window 对象</h4><p>说明一下，在浏览器中 window 对象有两重身份，一重是 JavaScript 访问浏览器的接口，另一重是 ES 规定的 Global 对象，因此可以访问<code>parseInt()</code>等方法<br>测试一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"suo"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">sayName(); <span class="comment">// suo</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// suo</span></span><br><span class="line"><span class="built_in">window</span>.sayName(); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>说明全局的变量和方法，使用 window均能访问到</p>
<p>全局变量的window的变量有说明差异呢，有一点就是定义在window上的属性可以使用delete删除，而定义的全局变量不可以<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"suo"</span>;</span><br><span class="line"><span class="built_in">window</span>.gender = <span class="string">"male"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> name;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.gender;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// suo</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.gender); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>另外尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的对象是否存在<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newname = oldname; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> newname = <span class="built_in">window</span>.oldname; <span class="comment">// 没报错</span></span><br></pre></td></tr></table></figure></p>
<p>说了这么多，我们来用 window 对象操作窗口<br>(1)控制窗口位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>) ?</span><br><span class="line">    <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>) ?</span><br><span class="line">    <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(leftPos);</span><br><span class="line"><span class="built_in">console</span>.log(topPos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IE(5,7-11) edge firefox 都能正常显示位置</span></span><br><span class="line"><span class="comment">// chorme 始终显示 0 0</span></span><br><span class="line"><span class="comment">// 令人费解</span></span><br></pre></td></tr></table></figure></p>
<p>除此之外还可以改变位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动多少像素</span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"><span class="comment">// 移动到哪个位置</span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试结果，除了IE以外，其他浏览器都默认禁用了</span></span><br></pre></td></tr></table></figure></p>
<p>(2)控制窗口大小<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面视图区大小</span></span><br><span class="line"><span class="comment">// 兼容的处理</span></span><br><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.campatMode == <span class="string">"CSS1Compat"</span>) &#123;</span><br><span class="line">        pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">        pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pageWidth = <span class="built_in">document</span>.body.clientWidth; <span class="comment">// IE6</span></span><br><span class="line">        pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(pageWidth + <span class="string">','</span> + pageHeight); <span class="comment">// 1080,1008</span></span><br></pre></td></tr></table></figure></p>
<p>我们还可以调整窗口大小<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整的像素</span></span><br><span class="line"><span class="built_in">window</span>.resizeBy(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line"><span class="comment">// 调整到多少</span></span><br><span class="line"><span class="built_in">window</span>.resizeTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 仍然除了IE以外其他都禁用了的</span></span><br></pre></td></tr></table></figure></p>
<p>(3)打开窗口<br>使用<code>window.open()</code>函数打开窗口，其中有四个参数：URL， target， 特性字符串，是否取得历史纪录中那个页面。第一个参数不用说，第二个参数有几个可以是特殊值：<code>_self</code>,<code>_parent</code>,<code>_top</code>,<code>_blank</code>。举个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开窗口</span></span><br><span class="line"><span class="keyword">var</span> local = <span class="built_in">window</span>.open(<span class="string">"http://localhost:4000"</span>, <span class="string">"local"</span>, <span class="string">"height=500,width=500,top=100,left=100,resizable=yes"</span>);</span><br><span class="line"><span class="comment">// 关闭窗口</span></span><br><span class="line">local.close()</span><br><span class="line"><span class="comment">// 强制关闭</span></span><br><span class="line">top.close();</span><br></pre></td></tr></table></figure></p>
<p>检测窗口是否被屏蔽<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blocked = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> local = <span class="built_in">window</span>.open(<span class="string">"http://localhost:4000"</span>, <span class="string">"_blank"</span>);</span><br><span class="line">    <span class="keyword">if</span> (local == <span class="literal">null</span>) &#123;</span><br><span class="line">        blocked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"窗口被屏蔽"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(4)使用定时器<br>window 对象提供两种定时器，一种是超时定时器<code>setTimeout()</code>,另一种是间歇定时器<code>setInterval()</code>。它们都提供两个参数，一个是执行的代码，一个是时间毫秒。看一下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超时定时器</span></span><br><span class="line"><span class="keyword">var</span> timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>); <span class="comment">// 经过一秒后ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消超时定时器</span></span><br><span class="line">clearTimeout(timer); <span class="comment">// 没打印</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 间歇定时器</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="number">3</span>; <span class="comment">// 设置最多定时次数</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> interval = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">if</span> (num == max) &#123;</span><br><span class="line">        clearInterval(interval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>); <span class="comment">// 没经过一秒打印一个ok，打印三次后结束打印</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用超时定时器模拟间歇定时器</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timerFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; max) &#123;  </span><br><span class="line">        setTimeout(timerFunction, <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(timerFunction, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<p>开发环境中很少真正使用间歇定时器，一般用超时定时器模拟它，原因在于当执行函数时间大于间歇时间时，后一个间歇定时器在前一个调用结束之前调用。</p>
<p>(5)使用系统对话框<br>由于系统对话框带来的用户体验相当差，现在用的很少，这里随便提一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证框与弹出框</span></span><br><span class="line"><span class="keyword">if</span> (confirm(<span class="string">"are you sure?"</span>)) &#123;</span><br><span class="line">    alert(<span class="string">"baici"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">"shagua"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 文本框</span></span><br><span class="line"><span class="keyword">var</span> name = prompt(<span class="string">"you name?"</span>);</span><br><span class="line">alert(<span class="string">"welcome "</span> + name);</span><br><span class="line"><span class="comment">// 打开find,print</span></span><br><span class="line">find();</span><br><span class="line">print(); <span class="comment">// 打印对话框</span></span><br></pre></td></tr></table></figure></p>
<h4 id="使用-location-对象"><a href="#使用-location-对象" class="headerlink" title="使用 location 对象"></a>使用 location 对象</h4><p>location对象是BOM最有用的对象之一，提供了文档有关的信息，还提供了一些导航功能。它是一个特别的对象，即是window属性，也是document属性，也就是说location,window.location,document.location是同一个东西。我们来试试它的功能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(location.hash); <span class="comment">// 无</span></span><br><span class="line"><span class="built_in">console</span>.log(location.host); <span class="comment">// localhost:4000</span></span><br><span class="line"><span class="built_in">console</span>.log(location.href); <span class="comment">// http://localhost:4000/</span></span><br><span class="line"><span class="built_in">console</span>.log(location.port); <span class="comment">// 4000</span></span><br><span class="line"><span class="built_in">console</span>.log(location.protocol); <span class="comment">// http:</span></span><br><span class="line"><span class="built_in">console</span>.log(location.search);</span><br></pre></td></tr></table></figure></p>
<h4 id="使用-navigator对象"><a href="#使用-navigator对象" class="headerlink" title="使用 navigator对象"></a>使用 navigator对象</h4><h4 id="使用-screen-对象"><a href="#使用-screen-对象" class="headerlink" title="使用 screen 对象"></a>使用 screen 对象</h4><p>用来识别客户端浏览器的，用处不大，表明客户端能力的。一般用于客户端能力检测</p>
<h4 id="使用-history对象"><a href="#使用-history对象" class="headerlink" title="使用 history对象"></a>使用 history对象</h4><p>保存用户上网的历史记录。处于安全考虑，开发人员无法知道历史记录的具体的URL,但是可以通过go()方法在历史记录中任意跳转。这个方法只接受一个参数，正数前进，负数后退<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go方法前进后退</span></span><br><span class="line">history.go(<span class="number">-1</span>);</span><br><span class="line">history.go(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写的两个方法</span></span><br><span class="line">history.back();</span><br><span class="line">history.forword();</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/06/book-note7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suoyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="锁越smile">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/06/book-note7/" itemprop="url">《JavaScript高级程序设计》读后记<七>：继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-06T13:33:12+08:00">
                2015-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇博客，我深入理解了对象，可以通过一些方式来创建对象。而对于 OOP 来说，仅仅做到这些是不够的。我们学过 OOP 都知道，它有三大特性，继承，多态，封装。第一个就是继承，而 JS 却本身没有继承这一方法。所以我们需要通过 JS 其他的特性来实现继承。由于 JS 的函数是没有函数签名的。所以并不能做到“接口继承”，但是我们可以做到“实现继承”。</p>
<h4 id="理解继承"><a href="#理解继承" class="headerlink" title="理解继承"></a>理解继承</h4><p><strong>(1)原型链</strong><br><strong>原型链</strong>是实现继承的主要方法，那么原型链到底是什么样的东西呢？上一篇博客我们重点分析了原型这一属性和对象。并且给出了一个图来说明它们之间的关系。回顾一些，下面给出之前的图<br><a href="/images/dm5.png">img</a><br>现在，我稍微改变一下原型属性的指向，我们让原型属性不指向它自己的原型对象，而是指向另一个函数的原型对象。如同所示，依次如此就构成了 <strong>原型链</strong><br><a href="/images/dm6.png">img</a><br><strong>各个函数之间通过原型对象构成一条链，所以称之为原型链</strong>，下面模拟一下这个过程<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.prototype = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getPersonValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prototype;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subprototype = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承，子类型原型等于父类型实例</span></span><br><span class="line">SubPerson.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">SubPerson.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subprototype;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subperson = <span class="keyword">new</span> SubPerson();</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson.getPersonValue()); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson.getSubValue()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>由上可知，当我们的函数的原型属性等于另一个函数的实例时，我们就继承了它的原型属性和方法。同时我们仍然保留了自己原型属性和方法。</p>
<p>我们现在知道了使用原型链来实现继承，有了继承我们的 <strong>原型搜索机制</strong>也得到了扩展</p>
<ul>
<li>搜索实例本身定义的属性</li>
<li>搜索实例原型</li>
<li>搜索继承的原型(多重继续)</li>
<li>搜索Object的原型(继承链顶端)</li>
</ul>
<p><strong>要注意的方面：</strong></p>
<ul>
<li><strong>子类型给原型添加的方法要在父类型之后添加</strong>(无论是新添加还是重新)</li>
<li><strong>通过原型链实现继承，不能通过对象字面量创建原型方法，这样会重写原型链</strong></li>
</ul>
<p><strong>原型链的缺陷：</strong><br>缺陷一，原型链实现的继承，原型变成了另外一个类型的实例，<strong>原有的实例属性变成了原型属性</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = [<span class="string">"suo"</span>, <span class="string">"yue"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line">SubPerson.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubPerson();</span><br><span class="line">sub1.name.push(<span class="string">"smile"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.name); <span class="comment">// (3) ["suo", "yue", "smile"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> SubPerson();</span><br><span class="line"><span class="built_in">console</span>.log(sub2.name); <span class="comment">// (3) ["suo", "yue", "smile"]</span></span><br></pre></td></tr></table></figure></p>
<p>缺陷二，<strong>子类继承了父类，但是没法给父类传递参数。</strong><br>基于这些缺陷，单一的使用原型链继承不太实用，怎么去解决这些问题呢？</p>
<p><strong>(2)构造函数</strong><br>上面两个缺陷是否有解决方法，结合我们之前学习的知识。我们思考一下，<br><strong>可以传参，而且不使用原型等于实例这种方法，怎么让子类型使用父类型的变量和方法呢呢？</strong><br>由此我们想到了之前学习的两个函数的方法，一个是<code>apply()</code>，一个是<code>call()</code>。<strong>它们可以将函数调用的其他函数绑定本函数的作用域和参数</strong>。现在我们来试试<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = [<span class="string">"suo"</span>, <span class="string">"yue"</span>];</span><br><span class="line">    <span class="keyword">this</span>.addName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name.push(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类函数，并绑定子类函数和参数</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subperson1 = <span class="keyword">new</span> SubPerson(<span class="string">"smile"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">var</span> subperson2 = <span class="keyword">new</span> SubPerson(<span class="string">"cry"</span>, <span class="string">"female"</span>);</span><br><span class="line">subperson1.addName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson1.name); <span class="comment">// ["suo", "yue", "smile"]</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson2.name); <span class="comment">// ["suo", "yue"]</span></span><br></pre></td></tr></table></figure></p>
<p>同理单独使用构造函数实现继承也是不行的，共享属性和变量就谈不上了，所以我们还是结合它们两者的优势重新实现继承吧。这和创建对象的模式有着异曲同工之妙。</p>
<p><strong>(3)组合继承</strong><br>结合以上我们来整合它们的技术，先上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.nameGroup = [<span class="string">"suo"</span>, <span class="string">"yue"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类型函数原型方法</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.addName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nameGroup.push(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造继承，调用父类型函数并绑定作用域和参数</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型链继承，子类型函数原型等于父类型实例</span></span><br><span class="line">SubPerson.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 修正构造属性</span></span><br><span class="line">SubPerson.prototype.constructor = SubPerson;</span><br><span class="line"><span class="comment">// 子类型函数原型方法</span></span><br><span class="line">SubPerson.prototype.getGender = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> subperson1 = <span class="keyword">new</span> SubPerson(<span class="string">"smile"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">var</span> subperson2 = <span class="keyword">new</span> SubPerson(<span class="string">"cry"</span>, <span class="string">"female"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">subperson1.addName();</span><br><span class="line"><span class="built_in">console</span>.log(subperson1.getName());   <span class="comment">// smile</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson1.getGender()); <span class="comment">// male</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson1.nameGroup);   <span class="comment">// ["suo", "yue", ""]</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson2.getName());   <span class="comment">// cry</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson2.getGender()); <span class="comment">// female</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson2.nameGroup);   <span class="comment">// ["suo", "yue"]</span></span><br></pre></td></tr></table></figure></p>
<p><strong>(4)原型式继承</strong><br>基于已有的对象创建新对象，同时还不必因此自定义类型，看看代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    Person.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们可能看不懂，但是结合原型链的思想，改变一下，或许就很明了了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person1是Person的实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">person1</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 子类型的原型等于父类型的实例</span></span><br><span class="line">    SubPerson.prototype = person1;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubPerson;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">subperson1 = object(person1);</span><br></pre></td></tr></table></figure></p>
<p>咋一看这不就是将原型链的继承方法，用函数封装了一下吗。有啥区别<br>确实原理都是样的。区别就在于，<strong>原型链方法是类型到类型。而原型式继承则直接是对象到对象</strong>。测试一下，到底可不可以继承到属性和方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span>,</span><br><span class="line">    nameGroup: [<span class="string">"suo"</span>, <span class="string">"yue"</span>];</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    P.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subperson = createObj(person1);</span><br><span class="line"><span class="built_in">console</span>.log(subperson.getName()); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>很明显当然是可以的，我们由此也想到了，这和复制一个对象有什么区别呢？当然是有区别的，本质来说，这种继承方法是一个 <strong>浅复制</strong>，<strong>虽然复制了对象的属性，但是引用型的属性仍然是共享的</strong>。验证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subperson1 = createObj(person1); </span><br><span class="line"><span class="keyword">var</span> subperson2 = createObj(person1);</span><br><span class="line">subperson1.nameGroup.push(<span class="string">"smile"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subperson2.nameGroup); </span><br><span class="line"><span class="comment">// (3) ["suo", "yue", "smile"]</span></span><br></pre></td></tr></table></figure></p>
<p>ES 新增了一个<code>Object.create()</code>方法规范了这个原型式继承。只有一个参数的情况下两者效果是一样的。第二个参数是可选的，作用是可以设置属性特性。这和我们之前谈到的<code>Object.defineProperties()</code>是同等效果的。测试一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> subperson1 = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">"yue"</span>,</span><br><span class="line">        enumerable: <span class="literal">false</span> <span class="comment">// 设置不可枚举</span></span><br><span class="line">    &#125;,</span><br><span class="line">    gerder: &#123;</span><br><span class="line">        value: <span class="string">"male"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(subperson1.name + <span class="string">','</span> + subperson1.gender); </span><br><span class="line"><span class="comment">// male, undefined 说明不能自己增加属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (prop <span class="keyword">in</span> subperson1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop); <span class="comment">// age </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>(5)寄生式继承</strong><br>寄生式继承与刚刚学习的原型式继承紧密相连，在原型式继承的基础上又封装了一道函数。直接上代码吧<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span>,</span><br><span class="line">    mess: <span class="string">"bye"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 原型式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    P.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寄生式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnobj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = createObj(o);</span><br><span class="line">    clone.sayBye = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o.mess;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> anoperson = createAnobj(person);</span><br><span class="line"><span class="built_in">console</span>.log(anoperson.name + <span class="string">','</span> + anoperson.sayBye());</span><br><span class="line"><span class="comment">// suo,bye</span></span><br></pre></td></tr></table></figure></p>
<p>咋一看，这不就是在原型式的基础上加一个添加方法的函数吗。当然完全是，它还有另一个用途，如果对象不是自定义或者构造函数时，它也是有用的，随便举个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnobj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone =  o; <span class="comment">// 原型式函数不是必须的</span></span><br><span class="line">    o.printFirst = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(o[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr2 = createAnobj(arr);</span><br><span class="line">arr.printFirst(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>(6)寄生组合继承</strong><br>我们知道原型链与构造函数的组合模式是最常见的继承方式，但是它也有不足的地方。它们单独来将每次调用一次父类型，组合起来就是调用了两次父类型。我们现在有一种方法来解决这个问题，就是组合寄生继承模式。<strong>它的思路就是构造函数模式不变，不直接调用父类型函数，而是通过原型模式创建一个副本，然后让子类的原型等于这个副本。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.nameGroup = [<span class="string">"xiao"</span>, <span class="string">"ai"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.addName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nameGroup.push(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继承属性</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="comment">// 自己属性</span></span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型式模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    P.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄生模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">p, subp</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象，浅复制原型对象</span></span><br><span class="line">    <span class="keyword">var</span> prototype = createObj(p.prototype);</span><br><span class="line">    <span class="comment">// 增强对象，修正构造函数</span></span><br><span class="line">    prototype.constructor = subp;</span><br><span class="line">    <span class="comment">// 指向对象，子类型指向创建并修正构造的父类型原型对象</span></span><br><span class="line">    subp.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行寄生模式</span></span><br><span class="line">inheritPrototype(Person, SubPerson);</span><br><span class="line"></span><br><span class="line">SubPerson.prototype.sayBye = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bye"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> subperson1 = <span class="keyword">new</span> SubPerson(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subperson1.getName()); <span class="comment">// 父类型属性和方法</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson1);</span><br><span class="line"><span class="built_in">console</span>.log(subperson1.gender); <span class="comment">// 自己的属性</span></span><br><span class="line">subperson1.addName(); <span class="comment">// 父类型的方法</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson1.nameGroup);</span><br><span class="line">subperson1.sayBye(); <span class="comment">// 自己的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subperson2 = <span class="keyword">new</span> SubPerson(<span class="string">"yue"</span>, <span class="string">"female"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subperson2.nameGroup); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// suo</span></span><br><span class="line"><span class="comment">// male</span></span><br><span class="line"><span class="comment">// bye</span></span><br><span class="line"><span class="comment">// (3) ["xiao", "ai", "suo"]</span></span><br><span class="line"><span class="comment">// (2) ["xiao", "ai"]</span></span><br></pre></td></tr></table></figure></p>
<p>写到这里，只能感叹一句，<strong>寄生组合模式简直就是一个大杂烩啊</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/05/book-note6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suoyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="锁越smile">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/05/book-note6/" itemprop="url">《JavaScript高级程序设计》读后记<六>：对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-05T12:43:11+08:00">
                2015-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上篇博客谈到了引用类型，array, function 等等。它们都有一个共同的特点就是，它们都继承于 object，它们都是对象，拥有属性和方法。我虽然搞清楚了它们的很多特性和方法，也可以用它们做一些事情。但是对象这个东西还是有很多东西是有些模糊的，这些天我看完了面向对象这一章。里面很多设计和 c++, Java 面向对象很相似，有共通的地方，但是也有很多地方是 JS 独有的特性。现在我整理出了一条思路，写下这篇博客，希望能更加透彻的理解面向对象的思想。</p>
<h3 id="理解-JavaScript-面向对象"><a href="#理解-JavaScript-面向对象" class="headerlink" title="理解 JavaScript 面向对象"></a>理解 JavaScript 面向对象</h3><p>前面已经接触过了很多对象，现在稍稍回顾一下，话不多说，上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接new对象</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">person.name = <span class="string">"suo"</span>;</span><br><span class="line">person.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;; </span><br><span class="line">person.getName(); <span class="comment">// suod</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字面量创建对象</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span>,</span><br><span class="line"></span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line">person.getName(); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>这两种创建对象的方法都是最初级的，第二个比一个好那么一点点<br>在使用更高级的创建方法之前要讨论一下对象的属性</p>
<h4 id="理解属性的特性"><a href="#理解属性的特性" class="headerlink" title="理解属性的特性"></a>理解属性的特性</h4><p><strong>ES5 定义了特性(attribute)，它是内部使用的，用来描述属性(property)的特征</strong>。这句话怎么解释呢？特性和属性，我们所知道的属性，就是对象的属性，方法。但是这些属性有一些特征，而把属性的特征称为特性。并且用两对方括号表示 [[Enumerable]]</p>
<p>下面具体谈谈这些属性的特性。<strong>分为两种特性，一种是数据特性，一种是访问器特性</strong></p>
<ul>
<li>[[Configurable]]: 能否删除而重新定义属性，能否修改属性特性</li>
<li>[[Enumerable]]: 能否通过 for-in 返回属性</li>
<li>[[Writable]]: 能否修改属性的值</li>
<li>[[Value]]: 包含属性的值</li>
</ul>
<p>下面我们举个例子具体说明这些特性的意义<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>name</code>是对象<code>person</code>的属性，[[Value]] 的值就应该是<code>&quot;suo&quot;</code>，其中<code>name</code>是可以删除和重新定义的。可以通过 for-in 返回属性，可以修改值，由此我们得出上面三个特性的默认值都是<code>true</code></p>
<p>既然属性的特性有默认的值，那么是否可以修改呢，答案是可以的<br>ES5 有一个方法可以修改属性的特性值<code>Object.defineProperty()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>, <span class="comment">// 设置特性为不能修改</span></span><br><span class="line">    value: <span class="string">"suo"</span>     <span class="comment">// 设置属性的值为"suo"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// suo</span></span><br><span class="line">person.name = <span class="string">"yue"</span>; <span class="comment">// 严格模式下导致错误</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>我们看到我们可以通过这个方法直接为属性设置值，同时设置了只读权限</p>
<p>现在我们知道属性的特性是可以重新定义和修改的，但是我们也知道特性里有一个 [[Configurable]] 可以控制是否可以修改特性，也就是设置<code>Configurable</code>为<code>false</code>，就不能再修改这个对象属性的特性了(除<code>writable</code>以外)，下面我们验证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>, <span class="comment">//设置不能删除属性，不能重新定义特性</span></span><br><span class="line">    value: <span class="string">"suo"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    value: <span class="string">"yue"</span> <span class="comment">// 出错。不能重新定义特性</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">delete</span> person.name; <span class="comment">// 不起作用，严格模式报错</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br></pre></td></tr></table></figure></p>
<p>现在看看访问器特性，包含 getter 和 setter 函数，读取访问器属性调用 getter，写入调用 setter<br>同样的访问器特性也是四个，其中前两个和数据特性一样，后两个如下</p>
<ul>
<li>[[Get]]: 读取属性时调用的函数，默认值是<code>undefined</code></li>
<li>[[set]]: 写入属性时调用的函数，默认也是<code>undefined</code></li>
</ul>
<p>同样我们来看看代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设suo是男生，yue是女生，当改变对象名字的时候，使得性别也改变</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    _name: <span class="string">"suo"</span>, <span class="comment">// 只能通过对象方法访问</span></span><br><span class="line">    gender: <span class="string">"male"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line"></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name === <span class="string">"yue"</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.gender = <span class="string">"fel"</span> + <span class="keyword">this</span>.gender;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">person.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.gender); <span class="comment">// female</span></span><br></pre></td></tr></table></figure></p>
<p><strong>说了这么多，那么使用这些特性有什么好处呢？</strong><br><code>get</code>函数内只能读，<code>set</code>函数内只能写，这样就完美的实现了读写分离，支持这个方法的需要 IE9 以上<br>上面用的都是单个属性的操作，也有可以一次操作多个属性的方法<code>defineProperties()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    _name: <span class="string">"suo"</span>,</span><br><span class="line">    gender: <span class="string">"male"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(person, &#123;</span><br><span class="line">    _name: &#123;</span><br><span class="line">        writable: <span class="literal">false</span>,</span><br><span class="line">        value: <span class="string">"yue"</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    gender: &#123;</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        value: <span class="string">"male"</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    name: &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"yue"</span> === <span class="keyword">this</span>._name) &#123;</span><br><span class="line">                <span class="keyword">this</span>.gender = <span class="string">"fe"</span> + <span class="keyword">this</span>.gender;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">person.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.gender); <span class="comment">// female</span></span><br></pre></td></tr></table></figure></p>
<p>这个方法使用的效果和上面单个方法别无二致，唯一不同的是，这些特性是同一时间创建的<br>现在我们来读取这些特性，使用方法<code>getOwnPropertyDescriptor</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">"_name"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value); <span class="comment">// yue</span></span><br></pre></td></tr></table></figure></p>
<p>前面谈了那么多关于属性的特性，现在我们该进入正题了</p>
<h4 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h4><p><strong>(1)工厂模式</strong><br> 考虑到<code>ES</code>没法创建类，所以就采用了函数封装特定的接口创建对象，下面直接上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂方法：批量生产对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.gender = gender;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o.name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"yue"</span>, <span class="string">"female"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这样写的好处就在于，本来需要单个创建的对象，通过函数的封装，可以批量的创建对象了。<br>其实它是有缺点的，<strong>虽然解决了相似对象创建的问题，但是对象的识别没法解决</strong>。</p>
<p><strong>(2)构造函数</strong><br>我们知道引用类型是通过原生的构造函数创建对象，其实构造函数是可以自定义的。所以我们现在可以通过自定义的方式来创建对象，上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.name = gender;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"yue"</span>, <span class="string">"female"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这种方式和工厂模式其实很相似，大家可能一看就知道了。它们之间有些稍稍不同的地方，这些其实很好解释，知道构造函数生成对象的过程，就很容易理解了，这两种方式其实是一个原理。<br><strong>构造函数，new 的过程</strong>:</p>
<ul>
<li>创建一个新对象</li>
<li>将作用域给新对象</li>
<li>给对象添加属性</li>
<li>返回对象</li>
</ul>
<p>现在也许大家都明白了，原来我们使用的工厂模式，其实就是在模拟构造函数生成对象的过程<br>构造函数生成的对象都有一个 constructor 属性，它就是指向构造函数本身的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.constructor == Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>由此我们可以看出，<strong>构造函数相比工厂模式的好处就在于，它解决了对象的识别问题</strong>，我们可以通过这些方式来判断，这个对象到底是由哪个函数构造的。<br>当然这种模式也是存在缺陷的，虽然我们利用工厂模式和构造函数，生产了很多对象。但是每生产一个对象，就要给对象里的属性和方法分配一块内存，然而对象的方法很多都是一样的。<strong>这样就导致了内存的大量的浪费</strong>，我们能否让这些方法共享呢？现在尝试独立这些共享方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    <span class="keyword">this</span>.getName = getName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125; <span class="comment">// 独立方法</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>虽然这是可行的，但是污染了全局作用域。<code>getName</code>虽然是全局的，单真正确是用在构造函数里面。这在开发中是一种及其不好的做法。</p>
<p><strong>(3)原型模式</strong><br>我们之前谈到函数类型，它都有一个 prototype 属性，当时没有过多的研究，现在可以好好探究一下了。首先这个属性是一个指针，指向一个对象，这个对象里面包含了所有实例共享的属性和方法。到这里你肯定明白了，<strong>原来这个原型属性就是为了解决构造函数无法共享属性和方法的啊</strong>。上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"suo"</span>;</span><br><span class="line">Person.prototype.gender = <span class="string">"male"</span>;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">//suo</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.getName()); <span class="comment">//suo</span></span><br></pre></td></tr></table></figure></p>
<p>很明显，原型对象的属性和方法，对于对象来说都是公有的，大家都一样。<br>下面继续深挖一下原型对象这种东西，有助于之后学习的理解<br><strong>只要创建函数，就会有一个 prototype 属性，这个属性指向了函数的原型对象。默认情况下所有的原型对象都会获得一个 constructor 属性，这个 constructor 是一个指向这个 prototype 所在的函数的指针</strong>。这个关系有点微妙，我还是画个图说明一下吧<br><img src="/images/dm3.png" alt="img"><br>代码验证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor); <span class="comment">// f Person()&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>其中我们可以通过<code>isProtptypeOf()</code>方法验证对象原型的对应关系<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><code>ES5</code>新增了<code>getPrototypeOf()</code>方法来获取原型值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1));</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;  name: "suo", gender: "male", getName: ƒ, constructor: ƒ &#125;</span></span><br><span class="line"><span class="comment">//    gender: "male"</span></span><br><span class="line"><span class="comment">//    getName: ƒ ()name:"suo"</span></span><br><span class="line"><span class="comment">//    constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">//    __proto__: Object</span></span><br></pre></td></tr></table></figure></p>
<p>上面我们通过这个方法把原型的全部内容打印了出来，这些都清楚了是吧<br>虽然可以通过对象访问原型的值，但是不能通过对象重写原型的值，这个原因很简单，因为我们知道，原型的属性和方法都是共享的，如果随便一个实例都能改动的话，原型就乱套了，<strong>改变一个原型的属性就会影响其他的实例</strong>。因此原型是不允许实例改变的。<strong>如果实例的属性名字与原型名字重名的话，它会屏蔽原型的属性</strong>。测试一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person1.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// yue</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.getName()); <span class="comment">// suo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person1.name; <span class="comment">// 删除属性</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>我们现在知道了，实例的属性是可以和原型重名的，那么怎么判断它到底是谁的属性呢，<strong><code>hasOwnProperty()</code>可以来检测这个属性到底是实例的还是原型的</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person1.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// yue</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> person1.name; <span class="comment">// 删除属性</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// suo</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>由此可知，<code>true</code>就是实例的，<code>false</code>就是原型的<br>现在我们没那么严苛，<strong>我们想要判断该属性是否可以被实例访问到，这里就有<code>in</code>方法可以判断</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>除此之外，如果我们还想得到所有实例的属性，也有种方法使用，for-in</strong>，当然有些不可枚举的属性是访问不到的。我们尝试去做一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (prop <span class="keyword">in</span> person1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name</span></span><br><span class="line"><span class="comment">// gender</span></span><br><span class="line"><span class="comment">// getName</span></span><br></pre></td></tr></table></figure></p>
<p>我们发现没有 protptype 属性，原因是它都是不可枚举的，[[enumerable]] 为<code>false</code><br>除此之外我们还可以使用<code>Object.keys()</code>方法来枚举对象属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(Person.prototype));</span><br><span class="line"><span class="comment">// (3) ["name", "gender", "getName"]</span></span><br></pre></td></tr></table></figure></p>
<p>关于原型的写法，同样我们可以通过字面量来批量写原型属性，方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person, // 构造函数还原</span><br><span class="line">    name: "suo",</span><br><span class="line">    gender: "male",</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure></p>
<p>要注意的一点是，字面量本身也是一个对象，<strong>原型指向字面量后指针就跑歪了，所以要我们要让它重新指向函数。这种方式仍然有个问题就是</strong>，本身 prototype 属性是不可枚举的，现在把 constructor 加上去后，导致变成可枚举的了，现在属性的特性的知识就有用武之地了，我们可以直接设置它的特性为不可枚举的，那不就可以了吗。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span>,</span><br><span class="line">    gender: <span class="string">"male"</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 添加属性值并设置特性不可枚举</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: Person</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们之前谈到不能用实例修改原型，但是我们可以直接在原型上做修改啊，修改的原型后会对实例有什么影响呢？测试一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// yue</span></span><br></pre></td></tr></table></figure></p>
<p>由此我们可知，<strong>即使是先创建了实例，修改原型属性后，实例访问的原型属性也会修改，说明原型是动态的</strong>，这其实也很简单说明。实例和原型本身就不是绑定的，我们通过原型访问，是通过指针访问的。原型里的属性改变了，我们再次通过指针访问时，当然也是改变后的属性了。<br>说了这么多，看起来原型挺好的，但是光有原型也是不够的，我们知道原型的方法和属性都是共享的，那么我私人的属性和方法该怎么办呢？<strong>那么为什么不把这两种模式结合起来呢？</strong></p>
<p><strong>(4)组合模式(构造+原型)</strong><br>结合构造和原型，我们来试着创建一个对象吧<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="comment">// constructor: Person,</span></span><br><span class="line">    origin: <span class="string">"monkey"</span>,   <span class="comment">// 起源</span></span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: Person</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"yue"</span>, <span class="string">"female"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.name === person2.name); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.origin === person2.origin);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>我们使用图示来说明这个方式<br><a href="/images/dm4.png">img</a></p>
<p><strong>(5)动态原型</strong><br>学过了其他 oop 语言，像c++，Java 都是用类封装所有的属性和方法，倒是觉得 ES 的比较奇怪了。现在就有一种方法来动态的创造原型，<strong>需要时才创建原型属性和方法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getName != <span class="string">"function"</span>) &#123;</span><br><span class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p><strong>只有当调用这个方法时，这个方法不存在，它才会被添加在原型里</strong>，使用动态模式不能用字面量方法给原型赋值，原因就是，它会将 constructor 导向新的对象，之前也遇到过。</p>
<p><strong>(6)寄生构造</strong><br>一句话，使用构造函数的工厂模式创建对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.gender = gender;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>咋一看，<strong>这不就是在构造函数里再造一个工厂模式吗？</strong>到底有啥用<br>其实这个寄生构造函数的用途，<strong>在于对原生的构造函数进行修改，重新造一个构造函数</strong>，比如下面<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建数组对象</span></span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>;</span><br><span class="line">    <span class="comment">// 添加参数</span></span><br><span class="line">    arr.push.apply(arr, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 添加方法</span></span><br><span class="line">    arr.toUpdateJoin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 返回数组</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> SpecialArray(<span class="string">"suo"</span>, <span class="string">"yue"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.toUpdateJoin()); <span class="comment">// suo|yue</span></span><br></pre></td></tr></table></figure></p>
<p>这样就改造好了，把原来数组的连接改成了<code>|</code>。</p>
<p><strong>(7)稳妥构造</strong><br>某个人发明了稳妥对象概念，什么是稳妥对象呢，<strong>它其实就是没有公共属性，不引用 this 对象</strong>。借鉴寄生构造函数，实现这个稳妥构造，上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name; <span class="comment">//注意这里没this</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>这种模式非常安全，里面没有公共属性和 this ，这样外界要访问到<code>name</code>，只能通过函数来访问了。写了这么多也差不多把面向对象搞清楚了一半，下一篇博客，专门研究面向对象里的 <strong>继承</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/02/book-note5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suoyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="锁越smile">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/02/book-note5/" itemprop="url">《JavaScript高级程序设计》读后记<五>：引用类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-02T16:44:12+08:00">
                2015-12-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前几篇博客，谈到了变量有 2 类数据类型，5 种基本数据类型和引用数据类型。同时也阐述了基本数据类型和引用数据类型的区别。但是一直没有提到具体的引用类型，今天专门看了引用类型一章，发现里面涉及的内容还挺多的。一时难以记住全部的内容，所以在这里写一篇博客，留做以后的学习作参考。</p>
<h3 id="理解引用类型"><a href="#理解引用类型" class="headerlink" title="理解引用类型"></a>理解引用类型</h3><p>引用类型的值(对象)是引用类型的实例，这和基本类型也是一样的，基本类型的值当然也是基本类型的实例。它们唯一的区别在于引用类型是一种数据结构，它的数据的组织更加复杂些。<br>前面也提到过，对象的创建是用 <strong>new</strong> 方法创建的。这里的所有的引用类型都类似，可以用 new 方法创建。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>; <span class="comment">// 同样的括号可以省略</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h4><p>除了上面那种创建 object 方法外还有种方法，使用对象字面量来表示<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name : <span class="string">"suo"</span>,</span><br><span class="line">    gender : <span class="string">"male"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>除此之外还有另一个写法，就是空对象，后添加属性，这也是可以的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">"suo"</span>;</span><br><span class="line">person.gender = <span class="string">"male"</span>;</span><br></pre></td></tr></table></figure></p>
<p>同时我们可以看到，object 访问属性是通过<code>.</code>来访问，其实也有另一种方法，通过<code>[]</code>来访问<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person[<span class="string">"name"</span>] = <span class="string">"suo"</span>;</span><br><span class="line">person[<span class="string">"gender"</span>] = <span class="string">"male"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"name"</span>]+<span class="string">','</span>+person[<span class="string">"gender"</span>]); <span class="comment">// suo,male</span></span><br></pre></td></tr></table></figure></p>
<p><strong>那么问题来了，什么时候用<code>.</code>，什么时候用<code>[]</code>呢？</strong><br><code>[]</code>表示法有个优点，就是他可以通过变量访问属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person[<span class="string">"name"</span>] = <span class="string">"suo"</span>;</span><br><span class="line">person[<span class="string">"gender"</span>] = <span class="string">"male"</span>;</span><br><span class="line"><span class="keyword">var</span> suo = <span class="string">"name"</span>; <span class="comment">// 将属性字符串赋值给变量</span></span><br><span class="line"><span class="built_in">console</span>.log(person[suo]+<span class="string">','</span>+person[<span class="string">"gender"</span>]); <span class="comment">// suo,male</span></span><br></pre></td></tr></table></figure></p>
<p>除此之外，都用<code>.</code>来表示，毕竟<code>.</code>表示更加方便简洁</p>
<h4 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h4><p>上面提到了 object 类型，下面具体谈一下 array 类型。其实感觉他俩挺像的，为什么这么说呢？<br>之前一段时间我一直在学习数据结构。真正的体会到了，很多看似不同的东西，其实在结构上是很相似的，甚至只是改进了一下数据的组织方式而已。<br>我们可以想象一下<code>object</code>的数据结构<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    key1 : value1,</span><br><span class="line">    key2 : value2,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>value</code>也可以是函数，对比一下数组的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="number">0</span> : value1,</span><br><span class="line">    <span class="number">1</span> : value2,</span><br><span class="line">    ...</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>其中数组中的下标是在字面量中省略的<br>很明显，它们的数据结构都是线性的序列，区别在于两点<br>1.object 的元素，可以是任意类型的。array 的一般是同一类类型的元素<br>2.object 是关联容器结构，array 是顺序容器结构。array 是寻秩访问，object 是寻关键码访问。<br><strong>谈到了它们之间的区别与联系，现在具体说一下 array 吧</strong><br>创建 array 也是有两种方法，一种是 new ,一种是字面量。和 object 差别不大<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>; <span class="comment">// 同理可省略</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    arr[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125; <span class="comment">// 1 2 3 4 5 6 7 8 9 10</span></span><br></pre></td></tr></table></figure></p>
<p>省略括号表示创建一个空的数组，数组不仅可以创建空数组，还可以创建想要的形式的数组<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// 创建包含三个元素的数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"hello"</span>); <span class="comment">// 创建包含一项元素"hello"的数组</span></span><br></pre></td></tr></table></figure></p>
<p>另外一种方式是字面量的，这种方式创建数组更加灵活<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []; <span class="comment">// 空数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"!"</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [ , , ]; <span class="comment">// 不建议使用，会生成undefined变量</span></span><br></pre></td></tr></table></figure></p>
<p>数组的长度可以用 length 得到<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.length); <span class="comment">// 4</span></span><br><span class="line">arr1[arr1.length] = <span class="number">5</span>; <span class="comment">// 添加一项</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1[<span class="number">4</span>]); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>
<p>之前谈到可以用<code>instanceof</code>来检测数组，但是它只能在一个全局内检测。所以 ES5 新增了一个方法来检测数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><code>Array</code>有很多类型的方法，我们先归一下类，以后再慢慢细究吧。<br>(1)转换方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(colors.toString()); <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.valueOf()); <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.join(<span class="string">"|"</span>)); <span class="comment">// red|blue|green</span></span><br></pre></td></tr></table></figure></p>
<p>(2)栈方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors.push(<span class="string">"yellow"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["red", "blue", "green", "yellow"]</span></span><br><span class="line">colors.pop(); </span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure></p>
<p>(3)队列方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors.push(<span class="string">"yellow"</span>, <span class="string">"black"</span>);</span><br><span class="line"><span class="keyword">var</span> pop = colors.pop(); <span class="comment">// black </span></span><br><span class="line"><span class="keyword">var</span> head = colors.shift();  <span class="comment">// red</span></span><br><span class="line">colors.unshift(<span class="string">"red"</span>, <span class="string">"black"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(pop+<span class="string">','</span>+head); </span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["red", "black", "blue", "green", "yellow"]</span></span><br></pre></td></tr></table></figure></p>
<p>(4)重排序方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转组项顺序</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>,  <span class="number">4</span>];</span><br><span class="line">num.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 4,5,2,3,1</span></span><br><span class="line"><span class="comment">//升序排序</span></span><br><span class="line">num.sort();</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure></p>
<p>(5)操作方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 粘贴(新数组)</span></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.concat(<span class="string">"yellow"</span>, [<span class="string">"black"</span>, <span class="string">"white"</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(colors2);</span><br><span class="line"><span class="comment">// (6) ["red", "blue", "green", "yellow", "black", "white"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 截切(新数组)</span></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> colors3 = colors.slice(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 不包含1</span></span><br><span class="line"><span class="built_in">console</span>.log(colors2); <span class="comment">// ["blue", "green"]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors3); <span class="comment">// ["red"]co</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换(原数组上操作)</span></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors.splice(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors)</span><br><span class="line">colors.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"yellow"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors)</span><br><span class="line">colors.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors)</span><br><span class="line"><span class="comment">//(2) ["red", "green"]</span></span><br><span class="line"><span class="comment">//(3) ["red", "yellow", "green"]</span></span><br><span class="line"><span class="comment">//(3) ["red", "black", "green"]</span></span><br></pre></td></tr></table></figure></p>
<p>(6)位置方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正向查找</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(num.indexOf(<span class="number">3</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 逆向查找</span></span><br><span class="line"><span class="built_in">console</span>.log(num.lastIndexOf(<span class="number">3</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>(7)迭代方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每项都</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> res = num.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 每项结果</span></span><br><span class="line"><span class="keyword">var</span> res2 = num.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// [3, 5, 4]</span></span><br><span class="line"><span class="comment">// 每项运行</span></span><br><span class="line"><span class="keyword">var</span> res3 = num.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    num = num * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res3);</span><br><span class="line"><span class="comment">// 每次结果数组</span></span><br><span class="line"><span class="keyword">var</span> res4 = num.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item * <span class="number">2</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res4);</span><br><span class="line"><span class="comment">// 任一项</span></span><br><span class="line"><span class="keyword">var</span> res5 = num.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);  </span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res5);</span><br></pre></td></tr></table></figure></p>
<p>(8)归并方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正向归并</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = num.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 逆向归并</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = num.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h4><p>我们可能学习过 Java 中的 Date 类型，其实 ES 也是借鉴它构建的。使用的也是 UTC 来保存日期。保存的日期的范围为 1970.1.1 前后的 1 亿年。<br>使用<code>new</code>创建<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line"><span class="built_in">console</span>.log(now); <span class="comment">// Sun Dec 02 2016 11:10:38 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure></p>
<p><strong>由此得知，Dete对象默认创建的是当前的时间，那怎么得到特定的时间呢?</strong><br>有两种方法：一种是<code>Date.parse()</code>，另一种是<code>Date.UTC()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">"Nov 12, 1995"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(someDate); <span class="comment">// Fri Nov 12 1995 00:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="comment">// 省略Date.parse也是可以的</span></span><br><span class="line"><span class="keyword">var</span> someDate2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"Sep 22, 1996"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(someDate2); <span class="comment">// Sun Sep 22 1996 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure></p>
<p>上面的方法返回的是日期对象，下面再测试一下<code>Date.UTC()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">1995</span>, <span class="number">11</span>, <span class="number">12</span>));</span><br><span class="line"><span class="built_in">console</span>.log(someDate); <span class="comment">// Sun Dec 12 1995 08:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line"><span class="keyword">var</span> someDate2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1995</span>, <span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(someDate2); <span class="comment">//Tue Dec 12 1995 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure></p>
<p>由此我们得知，这两种方法都是可以自动调用的，调用哪一种方法取决于传入的参数。<br><code>ES5</code>新增了一种<code>now()</code>方法，可以取得当前时间的毫秒数，那么我们可以用它做一些有用的事<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    sum = i*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> end = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="keyword">var</span> runtime = end - start;</span><br><span class="line"><span class="built_in">console</span>.log(runtime); <span class="comment">// 10(ms)</span></span><br></pre></td></tr></table></figure></p>
<p>用+操作符也可以达到同等目的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> +<span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure></p>
<p>因为时间本身是毫秒数，所有可以用<code>&gt;</code>或者<code>&lt;</code>比较日期<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2016</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(date1 &gt; date2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>格式化日期<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line"><span class="built_in">console</span>.log(date.toDateString()); <span class="comment">// Sun Dec 02 2016</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toTimeString()); <span class="comment">// 11:53:46 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toLocaleDateString()); <span class="comment">// 2016/12/2</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toUTCString()); <span class="comment">// Sun Dec 02 2016 11:53:46 GMT</span></span><br></pre></td></tr></table></figure></p>
<p>日期组件方法，都是一些 get，set 方法，这里就不一一说了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line"><span class="built_in">console</span>.log(date.getTime()); <span class="comment">// 1506830282288(ms)</span></span><br></pre></td></tr></table></figure></p>
<h4 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h4><p>我学过 PHP 的正则表达式，学过 Java 的正则表达式，很有意思的是现在又学<code>JS</code>的正则表达式，相对来说容易很多了，除了调用的方法名有所不同以外，其他的内容几乎无差别<br>首先创建一个正则表达式，同样是两种方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"pat"</span>,<span class="string">"flags"</span>); <span class="comment">// new对象</span></span><br><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/pat/</span>flags; <span class="comment">// 字面量</span></span><br></pre></td></tr></table></figure></p>
<p>稍微解释一些这个表达式的含义，<code>/</code>这个是表达式的定界符，就是隔离正则与其他字符的一个分界，为其他字符也可以，表达式后面的<code>flags</code>是一个标记，就是来切换正则表达式匹配规则的模式。<br>常见的模式有 g 表示全局模式，i 不区分大小写，m 多行模式，举几个例子说明下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/i</span>;</span><br></pre></td></tr></table></figure></p>
<p>解释一下，<code>suo</code>是正则法则，i 是模式，也就是匹配字符<code>suo</code>,且不区分大小写<br>使用<code>test</code>来测试是否匹配上<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/i</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pat.test(<span class="string">"Suo"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.test(<span class="string">"SUO"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.test(<span class="string">"sso"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>ES5 规定，使用字面量创建正则必须像直接调用 RegExp 构造函数一样，每次都要创建新的实例。<br>下面我们来看看实例的属性和方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/i</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pat.global); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.ignoreCase); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.multiline); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.lastIndex); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.source); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>这些属性都是正则表达式本身具有的一些属性，没啥用，<br>但是它的两个方法是我们要掌握的，<strong>第一个就是<code>exec()</code>它是用来捕获组的</strong>，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/ig</span>; <span class="comment">// 全局模式</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"suo: I am Suoyue"</span>;</span><br><span class="line"><span class="keyword">var</span> matches = pat.exec(str);</span><br><span class="line"><span class="comment">// 第一次捕获</span></span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches.input); <span class="comment">// suo: I am suo yue"</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">// suo</span></span><br><span class="line"><span class="comment">// 第二次捕获</span></span><br><span class="line">matches = pat.exec(str);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">// Suo</span></span><br></pre></td></tr></table></figure></p>
<p>正如上面所说，每一次捕获都要创建实例，都要再执行一遍捕获方法<br><strong>另一种方法是<code>test()</code>方法，他是一个判断是否匹配，正如它的名字，只是测试而已</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/i</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"suo: I am Suoyue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pat.test(str)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>假设我现在捕获到了一个组，我们怎么取得我们想要的东西呢？</strong><br>答案是使用RegExp的构造函数属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/ig</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"ss suo: I am Suoyue"</span>;</span><br><span class="line"><span class="keyword">if</span> (pat.test(str)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$_);    <span class="comment">// 最近一次要匹配的字符串 suo: I am Suoyue</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$`"</span>]); <span class="comment">// 最近匹配项前面的字符串 ss</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$'"</span>]); <span class="comment">// 最近匹配项后面的字符串 : I am Suoyue</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$&amp;"</span>]); <span class="comment">// 最近一次匹配项 suo</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$+"</span>]); <span class="comment">// 最近匹配的捕获组 [空]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$*"</span>]); <span class="comment">// 是否使用多行模式 (未实现)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了上面 6 个以外还有很多，不一一累述了<br>虽 ES 正则表达式功能还是比较完备的，但是对于 PHP 和 Java  还是缺少很多高级特性，作为一个前端的脚本语言，这些已经足够了</p>
<h4 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h4><p>前面我们一直提到函数，他是对象，它可以赋值给变量，它是 ES 中最小的作用域。但是一直我都没有具体研究它，现在我读了函数这章，很多之前的稍有疑问的地方，现在都豁然开朗了。</p>
<p>之前也说过，<strong>函数有两种表达方式，一种是使用函数声明，一种是使用函数表达式</strong>。我们稍微回顾一些这两种形式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//code...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//code...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意的是函数声明是会有函数声明提升的，之前也讲过，这里不在累述了。<br>由上面可以看出，函数包含函数名，函数本体，也就是<code>{}</code>里面的内容</p>
<p>函数实际是对象，<strong>那么函数名实际上是一个指向函数对象的指针，不会与某个函数绑定</strong><br>这句话怎么理解呢？下面给出一个例子来说明这个问题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"suo"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> boo = foo;</span><br><span class="line">foo = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 经测试foo解引用后，运行会出错</span></span><br><span class="line">boo(); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>由上面的代码可以看出，<code>foo</code>只是一个指向函数对象的指针，当使用解引用后，断绝了这个关系了。而<code>boo</code>又指向了函数对象，所以可以运行。</p>
<p>下面我们来探讨另一个问题，既然我们已经得出结论，函数名只是一个指向函数对象的指针。那函数就不应该有重载这个特性。因为同一个函数名是指向同一个函数对象的。就不会指向其他对象的说法<br>下面我们也来例证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"suo"</span>;</span><br><span class="line"><span class="keyword">var</span> gender = <span class="string">"male"</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name+<span class="string">','</span>+gender);</span><br><span class="line">&#125;</span><br><span class="line">foo(name); <span class="comment">// suo,undefined</span></span><br><span class="line">foo(name, gender); <span class="comment">// suo,male</span></span><br></pre></td></tr></table></figure></p>
<p>由上可知，如果函数有重载的话，第一个<code>foo</code>执行的结果应该是<code>suo</code>，但是实际的结果确实<code>suo</code>，<code>undefined</code>。很显然第一个函数执行的也是第二个函数表达式。第二个表达式的函数覆盖了之前的。<br>得出结论，<strong>函数重名会覆盖，不管参数是怎样的</strong></p>
<p>上面也提到了函数是对象，那么函数就可以给其他变量赋值。不仅如此函数还可以作为返回值用。<br>下面看一个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较人的身高</span></span><br><span class="line"><span class="keyword">var</span> suo = &#123;</span><br><span class="line">    height : <span class="number">180</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> yue = &#123;</span><br><span class="line">    height : <span class="number">170</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">campareHeight</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params">suo, yue</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (suo.height &gt; yue.height) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (suo.height &lt; yue.height) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(suo, yue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(campareHeight(<span class="string">"height"</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>这里要提醒下，函数声明是不可以直接做返回值的，只有执行后的函数才能做返回值.一般这种情况我，使用立即执行函数一步来搞定，下面写一个立即执行函数的简单例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明与执行分步写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo()); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 使用立即执行函数一步写</span></span><br><span class="line"><span class="built_in">console</span>.log( (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;)() ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>函数内部有两个特殊的对象：arguments 和 this</strong><br>arguments 是一个类数组对象，包含传入函数的所以参数主要用来保存函数参数的，这个对象有一个叫 callee 的属性，它是一个指针，指向拥有这个 arguments 对象的函数。<br>下面一个例子告诉我们caller的用法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>); <span class="comment">// 3628800</span></span><br></pre></td></tr></table></figure></p>
<p>其实这个就是 10 的阶乘。关键在于这行代码<code>arguments.callee(num-1)</code>，我们再仔细揣摩这句话，<strong>callee 的属性，它是一个指针，指向拥有这个 arguments 对象的函数</strong>，现在明白了<code>arguments.callee(num-1)</code>就等同于<code>foo(num-1)</code>，这样就清楚了。<br>该说说 this 了，我看了半天书上的叙述，总结了一句话，<strong>当在哪个作用域调用函数时，该函数中的 this 就是哪个作用域对象</strong><br>下面验证下这句话的正确性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局调用</span></span><br><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    color: <span class="string">"blue"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">getColor(); <span class="comment">// red</span></span><br><span class="line">o.getColor = getColor;</span><br><span class="line">o.getColor(); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure></p>
<p>另一个是<code>caller</code>，表示调用当前函数的函数的引用，全局作用域为<code>null</code>，验证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    boo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(boo.caller); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.caller); <span class="comment">// null</span></span><br><span class="line">foo(); <span class="comment">// ƒ foo() &#123; boo();&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这里可以看到显示了 foo 的源码，下面用另一种方式实现这个效果(根据 callee 的用法好理解)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    boo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.caller); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.caller); <span class="comment">// null</span></span><br><span class="line">foo(); <span class="comment">// ƒ foo() &#123; boo();&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这种写法虽然现在可以，但是出于安全性考虑，严格模式下已经不许这样做了，另外严格模式下函数的 caller 属性是不能赋值的</p>
<p>都说对象是有属性方法的，函数也不例外，下面谈谈函数的属性和方法吧<br>函数有两个属性一个是 leghth，一个是 prototype ，前面一个是指希望接受参数个数，没什么好说的。关键在于这个 prototype 属性,这个属性是ES搞面向对象专门搞得一个属性，这里不谈太多了，下一篇博客研究对象和继承时。好好探究这个属性。这里就简单提几点，ES5 中，prototype 属性太多，是无法使用 for-in 枚举的。</p>
<p>下面我们聊聊,<strong>函数的两个独有的方法</strong>，说独有是因为它不是其他对象有的，因为它们关系到作用域。我们知道 ES 就只有函数作用域，所以这一切搜说得通了。<br>这两个方法，一个是<code>apply()</code>,一个是<code>call()</code>,这两个函数有很多相似之处。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callFoo</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">callFoo(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>这里我的理解是，apply这个函数，是将 callFoo 的 this 对象和 arguments 传给了 foo，并执行结果返回给 callFoo，也可以不用自己的 arguments 对象，随意传一个数组也可以。因为 arguments 本身也是一个数组。如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callFoo</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.apply(<span class="keyword">this</span>, [<span class="number">3</span>, <span class="number">2</span>]); <span class="comment">// 替换成自己的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不写参数看看</span></span><br><span class="line">callFoo(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>果然是这样，证明我的理解是正确的。<br>理解了 apply，call 也就好理解了，它们区别就在于参数，不同于 apply，一个作用域和一个参数数组。<strong>call 的参数要全部单独写出来</strong>。改变上面的代码，看看<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callFoo</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.call(<span class="keyword">this</span>, <span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 参数数组变成单个参数</span></span><br><span class="line">&#125;</span><br><span class="line">callFoo(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>一切都在意料之中，果然是这样。<br>说了这么这两个方法，它们有啥用呢？<strong>它们的真正用处在于扩充函数的作用域</strong><br>下面看一个例子你就明白了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    color: <span class="string">"blue"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">getColor();            <span class="comment">// red</span></span><br><span class="line">getColor.call(<span class="keyword">this</span>);   <span class="comment">// red</span></span><br><span class="line">getColor.call(<span class="built_in">window</span>); <span class="comment">// red</span></span><br><span class="line">getColor.call(o);      <span class="comment">// blue</span></span><br></pre></td></tr></table></figure></p>
<p>这里你是否明白了呢，<code>getColor</code>本来是全局作用域，本应该是输出<code>red</code>，绑定<code>o</code>后，竟然可以输出对象的变量。这样做的最大好处是函数既访问到了对象的变量，而且和对象没有形成耦合关系。<br>最后说一个 ES 方法<code>bind()</code>。下面看一下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    color: <span class="string">"blue"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oGetColor = getColor.bind(o);</span><br><span class="line">oGetColor(); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure></p>
<p>这个方法比<code>call()</code>更直接，直接实现函数对象绑定的值，并给一个新的函数。这个就牛逼了，具有<code>call()</code>的好处,并且更加直接，好理解。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">suoyue</p>
              <p class="site-description motion-element" itemprop="description">保持乐观，保持谦虚</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">49</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">suoyue</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
