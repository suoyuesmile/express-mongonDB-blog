<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Tag: JavaScript | 锁越smile</title>
  <meta name="description" content="保持乐观，保持谦虚" />
  <meta name="keywords" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/">
  <link rel="alternate" href="/atom.xml" title="锁越smile">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="保持乐观，保持谦虚">
<meta property="og:type" content="website">
<meta property="og:title" content="锁越smile">
<meta property="og:url" content="http://yoursite.com/tags/JavaScript/page/2/index.html">
<meta property="og:site_name" content="锁越smile">
<meta property="og:description" content="保持乐观，保持谦虚">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="锁越smile">
<meta name="twitter:description" content="保持乐观，保持谦虚">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  <link rel="stylesheet" href="/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>

<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/' >
				锁越smile
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/'>
								Home
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/archives'>
								Archives
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-gallery' href='https://photos.google.com/album/AF1QipNoqKYgspQo5O1YhlFXGCQ7p575KBH3Yxf8WHL4?hl=zh-CN'>
								Gallery
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-about' href='/about'>
								About
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search flat-box"></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu flat-box"></span></a></li>
			</ul>
		</div>
		
		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				Word of Forks
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><span class="icon icon-chat_bubble_outline flat-box"></span></a></li>
				<li class='s-top'><a href='javascript:void(0)'><span class="icon icon-arrow_upward flat-box"></span></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><span class="icon icon-format_list_numbered flat-box"></span></a></li>
			</ul>
		</div>
	</div>
</header>
<aside class="menu-phone">
	<nav>
		
			<a href="/" class="nav-home nav">
				Home
			</a>
		
			<a href="/archives" class="nav-archives nav">
				Archives
			</a>
		
			<a href="https://photos.google.com/album/AF1QipNoqKYgspQo5O1YhlFXGCQ7p575KBH3Yxf8WHL4?hl=zh-CN" class="nav-gallery nav">
				Gallery
			</a>
		
			<a href="/about" class="nav-about nav">
				About
			</a>
		
	</nav>
</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        
  <script>
    window.subData= { title:'Tag : JavaScript'}
  </script>

<section class="post-list">
	
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2015/12/08/t-book_js_008/">
        《JavaScript高级程序设计》读后记&lt;八&gt;：BOM
      </a>
    </h2>
    
    <time>
      Dec 8, 2015
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <p>前几章学了 JavaScript 的基础的知识，理论性太强。需要思考理解的东西远远多于实战的。我最近看了 BOM 这一章，才真正的感受到了 JavaScript 真的很强大，特别是在于操作浏览器这方法。不多写了，已经等不急实战了。</p>
<h3 id="理解BOM"><a href="#理解BOM" class="headerlink" title="理解BOM"></a>理解BOM</h3><h4 id="使用-Window-对象"><a href="#使用-Window-对象" class="headerlink" title="使用 Window 对象"></a>使用 Window 对象</h4><p>说明一下，在浏览器中 window 对象有两重身份，一重是 JavaScript 访问浏览器的接口，另一重是 ES 规定的 Global 对象，因此可以访问<code>parseInt()</code>等方法<br>测试一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"suo"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">sayName(); <span class="comment">// suo</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// suo</span></span><br><span class="line"><span class="built_in">window</span>.sayName(); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>说明全局的变量和方法，使用 window均能访问到</p>
<p>全局变量的window的变量有说明差异呢，有一点就是定义在window上的属性可以使用delete删除，而定义的全局变量不可以<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"suo"</span>;</span><br><span class="line"><span class="built_in">window</span>.gender = <span class="string">"male"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> name;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.gender;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// suo</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.gender); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>另外尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的对象是否存在<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newname = oldname; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> newname = <span class="built_in">window</span>.oldname; <span class="comment">// 没报错</span></span><br></pre></td></tr></table></figure></p>
<p>说了这么多，我们来用 window 对象操作窗口<br>(1)控制窗口位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>) ?</span><br><span class="line">    <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>) ?</span><br><span class="line">    <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(leftPos);</span><br><span class="line"><span class="built_in">console</span>.log(topPos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IE(5,7-11) edge firefox 都能正常显示位置</span></span><br><span class="line"><span class="comment">// chorme 始终显示 0 0</span></span><br><span class="line"><span class="comment">// 令人费解</span></span><br></pre></td></tr></table></figure></p>
<p>除此之外还可以改变位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动多少像素</span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"><span class="comment">// 移动到哪个位置</span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试结果，除了IE以外，其他浏览器都默认禁用了</span></span><br></pre></td></tr></table></figure></p>
<p>(2)控制窗口大小<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面视图区大小</span></span><br><span class="line"><span class="comment">// 兼容的处理</span></span><br><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.campatMode == <span class="string">"CSS1Compat"</span>) &#123;</span><br><span class="line">        pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">        pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pageWidth = <span class="built_in">document</span>.body.clientWidth; <span class="comment">// IE6</span></span><br><span class="line">        pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(pageWidth + <span class="string">','</span> + pageHeight); <span class="comment">// 1080,1008</span></span><br></pre></td></tr></table></figure></p>
<p>我们还可以调整窗口大小<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整的像素</span></span><br><span class="line"><span class="built_in">window</span>.resizeBy(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line"><span class="comment">// 调整到多少</span></span><br><span class="line"><span class="built_in">window</span>.resizeTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 仍然除了IE以外其他都禁用了的</span></span><br></pre></td></tr></table></figure></p>
<p>(3)打开窗口<br>使用<code>window.open()</code>函数打开窗口，其中有四个参数：URL， target， 特性字符串，是否取得历史纪录中那个页面。第一个参数不用说，第二个参数有几个可以是特殊值：<code>_self</code>,<code>_parent</code>,<code>_top</code>,<code>_blank</code>。举个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开窗口</span></span><br><span class="line"><span class="keyword">var</span> local = <span class="built_in">window</span>.open(<span class="string">"http://localhost:4000"</span>, <span class="string">"local"</span>, <span class="string">"height=500,width=500,top=100,left=100,resizable=yes"</span>);</span><br><span class="line"><span class="comment">// 关闭窗口</span></span><br><span class="line">local.close()</span><br><span class="line"><span class="comment">// 强制关闭</span></span><br><span class="line">top.close();</span><br></pre></td></tr></table></figure></p>
<p>检测窗口是否被屏蔽<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blocked = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> local = <span class="built_in">window</span>.open(<span class="string">"http://localhost:4000"</span>, <span class="string">"_blank"</span>);</span><br><span class="line">    <span class="keyword">if</span> (local == <span class="literal">null</span>) &#123;</span><br><span class="line">        blocked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"窗口被屏蔽"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(4)使用定时器<br>window 对象提供两种定时器，一种是超时定时器<code>setTimeout()</code>,另一种是间歇定时器<code>setInterval()</code>。它们都提供两个参数，一个是执行的代码，一个是时间毫秒。看一下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超时定时器</span></span><br><span class="line"><span class="keyword">var</span> timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>); <span class="comment">// 经过一秒后ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消超时定时器</span></span><br><span class="line">clearTimeout(timer); <span class="comment">// 没打印</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 间歇定时器</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="number">3</span>; <span class="comment">// 设置最多定时次数</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> interval = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">if</span> (num == max) &#123;</span><br><span class="line">        clearInterval(interval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>); <span class="comment">// 没经过一秒打印一个ok，打印三次后结束打印</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用超时定时器模拟间歇定时器</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timerFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; max) &#123;  </span><br><span class="line">        setTimeout(timerFunction, <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(timerFunction, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<p>开发环境中很少真正使用间歇定时器，一般用超时定时器模拟它，原因在于当执行函数时间大于间歇时间时，后一个间歇定时器在前一个调用结束之前调用。</p>
<p>(5)使用系统对话框<br>由于系统对话框带来的用户体验相当差，现在用的很少，这里随便提一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证框与弹出框</span></span><br><span class="line"><span class="keyword">if</span> (confirm(<span class="string">"are you sure?"</span>)) &#123;</span><br><span class="line">    alert(<span class="string">"baici"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">"shagua"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 文本框</span></span><br><span class="line"><span class="keyword">var</span> name = prompt(<span class="string">"you name?"</span>);</span><br><span class="line">alert(<span class="string">"welcome "</span> + name);</span><br><span class="line"><span class="comment">// 打开find,print</span></span><br><span class="line">find();</span><br><span class="line">print(); <span class="comment">// 打印对话框</span></span><br></pre></td></tr></table></figure></p>
<h4 id="使用-location-对象"><a href="#使用-location-对象" class="headerlink" title="使用 location 对象"></a>使用 location 对象</h4><p>location对象是BOM最有用的对象之一，提供了文档有关的信息，还提供了一些导航功能。它是一个特别的对象，即是window属性，也是document属性，也就是说location,window.location,document.location是同一个东西。我们来试试它的功能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(location.hash); <span class="comment">// 无</span></span><br><span class="line"><span class="built_in">console</span>.log(location.host); <span class="comment">// localhost:4000</span></span><br><span class="line"><span class="built_in">console</span>.log(location.href); <span class="comment">// http://localhost:4000/</span></span><br><span class="line"><span class="built_in">console</span>.log(location.port); <span class="comment">// 4000</span></span><br><span class="line"><span class="built_in">console</span>.log(location.protocol); <span class="comment">// http:</span></span><br><span class="line"><span class="built_in">console</span>.log(location.search);</span><br></pre></td></tr></table></figure></p>
<h4 id="使用-navigator对象"><a href="#使用-navigator对象" class="headerlink" title="使用 navigator对象"></a>使用 navigator对象</h4><h4 id="使用-screen-对象"><a href="#使用-screen-对象" class="headerlink" title="使用 screen 对象"></a>使用 screen 对象</h4><p>用来识别客户端浏览器的，用处不大，表明客户端能力的。一般用于客户端能力检测</p>
<h4 id="使用-history对象"><a href="#使用-history对象" class="headerlink" title="使用 history对象"></a>使用 history对象</h4><p>保存用户上网的历史记录。处于安全考虑，开发人员无法知道历史记录的具体的URL,但是可以通过go()方法在历史记录中任意跳转。这个方法只接受一个参数，正数前进，负数后退<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go方法前进后退</span></span><br><span class="line">history.go(<span class="number">-1</span>);</span><br><span class="line">history.go(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写的两个方法</span></span><br><span class="line">history.back();</span><br><span class="line">history.forword();</span><br></pre></td></tr></table></figure></p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2015/12/06/t-book_js_007/">
        《JavaScript高级程序设计》读后记&lt;七&gt;：继承
      </a>
    </h2>
    
    <time>
      Dec 6, 2015
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <p>上一篇博客，我深入理解了对象，可以通过一些方式来创建对象。而对于 OOP 来说，仅仅做到这些是不够的。我们学过 OOP 都知道，它有三大特性，继承，多态，封装。第一个就是继承，而 JS 却本身没有继承这一方法。所以我们需要通过 JS 其他的特性来实现继承。由于 JS 的函数是没有函数签名的。所以并不能做到“接口继承”，但是我们可以做到“实现继承”。</p>
<h4 id="理解继承"><a href="#理解继承" class="headerlink" title="理解继承"></a>理解继承</h4><p><strong>(1)原型链</strong><br><strong>原型链</strong>是实现继承的主要方法，那么原型链到底是什么样的东西呢？上一篇博客我们重点分析了原型这一属性和对象。并且给出了一个图来说明它们之间的关系。回顾一些，下面给出之前的图<br><a href="/images/dm5.png">img</a><br>现在，我稍微改变一下原型属性的指向，我们让原型属性不指向它自己的原型对象，而是指向另一个函数的原型对象。如同所示，依次如此就构成了 <strong>原型链</strong><br><a href="/images/dm6.png">img</a><br><strong>各个函数之间通过原型对象构成一条链，所以称之为原型链</strong>，下面模拟一下这个过程<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.prototype = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getPersonValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prototype;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subprototype = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承，子类型原型等于父类型实例</span></span><br><span class="line">SubPerson.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">SubPerson.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subprototype;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subperson = <span class="keyword">new</span> SubPerson();</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson.getPersonValue()); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson.getSubValue()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>由上可知，当我们的函数的原型属性等于另一个函数的实例时，我们就继承了它的原型属性和方法。同时我们仍然保留了自己原型属性和方法。</p>
<p>我们现在知道了使用原型链来实现继承，有了继承我们的 <strong>原型搜索机制</strong>也得到了扩展</p>
<ul>
<li>搜索实例本身定义的属性</li>
<li>搜索实例原型</li>
<li>搜索继承的原型(多重继续)</li>
<li>搜索Object的原型(继承链顶端)</li>
</ul>
<p><strong>要注意的方面：</strong></p>
<ul>
<li><strong>子类型给原型添加的方法要在父类型之后添加</strong>(无论是新添加还是重新)</li>
<li><strong>通过原型链实现继承，不能通过对象字面量创建原型方法，这样会重写原型链</strong></li>
</ul>
<p><strong>原型链的缺陷：</strong><br>缺陷一，原型链实现的继承，原型变成了另外一个类型的实例，<strong>原有的实例属性变成了原型属性</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = [<span class="string">"suo"</span>, <span class="string">"yue"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line">SubPerson.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubPerson();</span><br><span class="line">sub1.name.push(<span class="string">"smile"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.name); <span class="comment">// (3) ["suo", "yue", "smile"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> SubPerson();</span><br><span class="line"><span class="built_in">console</span>.log(sub2.name); <span class="comment">// (3) ["suo", "yue", "smile"]</span></span><br></pre></td></tr></table></figure></p>
<p>缺陷二，<strong>子类继承了父类，但是没法给父类传递参数。</strong><br>基于这些缺陷，单一的使用原型链继承不太实用，怎么去解决这些问题呢？</p>
<p><strong>(2)构造函数</strong><br>上面两个缺陷是否有解决方法，结合我们之前学习的知识。我们思考一下，<br><strong>可以传参，而且不使用原型等于实例这种方法，怎么让子类型使用父类型的变量和方法呢呢？</strong><br>由此我们想到了之前学习的两个函数的方法，一个是<code>apply()</code>，一个是<code>call()</code>。<strong>它们可以将函数调用的其他函数绑定本函数的作用域和参数</strong>。现在我们来试试<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = [<span class="string">"suo"</span>, <span class="string">"yue"</span>];</span><br><span class="line">    <span class="keyword">this</span>.addName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name.push(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类函数，并绑定子类函数和参数</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subperson1 = <span class="keyword">new</span> SubPerson(<span class="string">"smile"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">var</span> subperson2 = <span class="keyword">new</span> SubPerson(<span class="string">"cry"</span>, <span class="string">"female"</span>);</span><br><span class="line">subperson1.addName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson1.name); <span class="comment">// ["suo", "yue", "smile"]</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson2.name); <span class="comment">// ["suo", "yue"]</span></span><br></pre></td></tr></table></figure></p>
<p>同理单独使用构造函数实现继承也是不行的，共享属性和变量就谈不上了，所以我们还是结合它们两者的优势重新实现继承吧。这和创建对象的模式有着异曲同工之妙。</p>
<p><strong>(3)组合继承</strong><br>结合以上我们来整合它们的技术，先上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.nameGroup = [<span class="string">"suo"</span>, <span class="string">"yue"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类型函数原型方法</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.addName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nameGroup.push(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造继承，调用父类型函数并绑定作用域和参数</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型链继承，子类型函数原型等于父类型实例</span></span><br><span class="line">SubPerson.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 修正构造属性</span></span><br><span class="line">SubPerson.prototype.constructor = SubPerson;</span><br><span class="line"><span class="comment">// 子类型函数原型方法</span></span><br><span class="line">SubPerson.prototype.getGender = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> subperson1 = <span class="keyword">new</span> SubPerson(<span class="string">"smile"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">var</span> subperson2 = <span class="keyword">new</span> SubPerson(<span class="string">"cry"</span>, <span class="string">"female"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">subperson1.addName();</span><br><span class="line"><span class="built_in">console</span>.log(subperson1.getName());   <span class="comment">// smile</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson1.getGender()); <span class="comment">// male</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson1.nameGroup);   <span class="comment">// ["suo", "yue", ""]</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson2.getName());   <span class="comment">// cry</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson2.getGender()); <span class="comment">// female</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson2.nameGroup);   <span class="comment">// ["suo", "yue"]</span></span><br></pre></td></tr></table></figure></p>
<p><strong>(4)原型式继承</strong><br>基于已有的对象创建新对象，同时还不必因此自定义类型，看看代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    Person.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们可能看不懂，但是结合原型链的思想，改变一下，或许就很明了了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person1是Person的实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">person1</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 子类型的原型等于父类型的实例</span></span><br><span class="line">    SubPerson.prototype = person1;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubPerson;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">subperson1 = object(person1);</span><br></pre></td></tr></table></figure></p>
<p>咋一看这不就是将原型链的继承方法，用函数封装了一下吗。有啥区别<br>确实原理都是样的。区别就在于，<strong>原型链方法是类型到类型。而原型式继承则直接是对象到对象</strong>。测试一下，到底可不可以继承到属性和方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span>,</span><br><span class="line">    nameGroup: [<span class="string">"suo"</span>, <span class="string">"yue"</span>];</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    P.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subperson = createObj(person1);</span><br><span class="line"><span class="built_in">console</span>.log(subperson.getName()); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>很明显当然是可以的，我们由此也想到了，这和复制一个对象有什么区别呢？当然是有区别的，本质来说，这种继承方法是一个 <strong>浅复制</strong>，<strong>虽然复制了对象的属性，但是引用型的属性仍然是共享的</strong>。验证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subperson1 = createObj(person1); </span><br><span class="line"><span class="keyword">var</span> subperson2 = createObj(person1);</span><br><span class="line">subperson1.nameGroup.push(<span class="string">"smile"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subperson2.nameGroup); </span><br><span class="line"><span class="comment">// (3) ["suo", "yue", "smile"]</span></span><br></pre></td></tr></table></figure></p>
<p>ES 新增了一个<code>Object.create()</code>方法规范了这个原型式继承。只有一个参数的情况下两者效果是一样的。第二个参数是可选的，作用是可以设置属性特性。这和我们之前谈到的<code>Object.defineProperties()</code>是同等效果的。测试一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> subperson1 = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">"yue"</span>,</span><br><span class="line">        enumerable: <span class="literal">false</span> <span class="comment">// 设置不可枚举</span></span><br><span class="line">    &#125;,</span><br><span class="line">    gerder: &#123;</span><br><span class="line">        value: <span class="string">"male"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(subperson1.name + <span class="string">','</span> + subperson1.gender); </span><br><span class="line"><span class="comment">// male, undefined 说明不能自己增加属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (prop <span class="keyword">in</span> subperson1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop); <span class="comment">// age </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>(5)寄生式继承</strong><br>寄生式继承与刚刚学习的原型式继承紧密相连，在原型式继承的基础上又封装了一道函数。直接上代码吧<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span>,</span><br><span class="line">    mess: <span class="string">"bye"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 原型式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    P.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寄生式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnobj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = createObj(o);</span><br><span class="line">    clone.sayBye = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o.mess;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> anoperson = createAnobj(person);</span><br><span class="line"><span class="built_in">console</span>.log(anoperson.name + <span class="string">','</span> + anoperson.sayBye());</span><br><span class="line"><span class="comment">// suo,bye</span></span><br></pre></td></tr></table></figure></p>
<p>咋一看，这不就是在原型式的基础上加一个添加方法的函数吗。当然完全是，它还有另一个用途，如果对象不是自定义或者构造函数时，它也是有用的，随便举个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnobj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone =  o; <span class="comment">// 原型式函数不是必须的</span></span><br><span class="line">    o.printFirst = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(o[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr2 = createAnobj(arr);</span><br><span class="line">arr.printFirst(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>(6)寄生组合继承</strong><br>我们知道原型链与构造函数的组合模式是最常见的继承方式，但是它也有不足的地方。它们单独来将每次调用一次父类型，组合起来就是调用了两次父类型。我们现在有一种方法来解决这个问题，就是组合寄生继承模式。<strong>它的思路就是构造函数模式不变，不直接调用父类型函数，而是通过原型模式创建一个副本，然后让子类的原型等于这个副本。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.nameGroup = [<span class="string">"xiao"</span>, <span class="string">"ai"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.addName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nameGroup.push(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继承属性</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="comment">// 自己属性</span></span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型式模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    P.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄生模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">p, subp</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象，浅复制原型对象</span></span><br><span class="line">    <span class="keyword">var</span> prototype = createObj(p.prototype);</span><br><span class="line">    <span class="comment">// 增强对象，修正构造函数</span></span><br><span class="line">    prototype.constructor = subp;</span><br><span class="line">    <span class="comment">// 指向对象，子类型指向创建并修正构造的父类型原型对象</span></span><br><span class="line">    subp.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行寄生模式</span></span><br><span class="line">inheritPrototype(Person, SubPerson);</span><br><span class="line"></span><br><span class="line">SubPerson.prototype.sayBye = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bye"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> subperson1 = <span class="keyword">new</span> SubPerson(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subperson1.getName()); <span class="comment">// 父类型属性和方法</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson1);</span><br><span class="line"><span class="built_in">console</span>.log(subperson1.gender); <span class="comment">// 自己的属性</span></span><br><span class="line">subperson1.addName(); <span class="comment">// 父类型的方法</span></span><br><span class="line"><span class="built_in">console</span>.log(subperson1.nameGroup);</span><br><span class="line">subperson1.sayBye(); <span class="comment">// 自己的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subperson2 = <span class="keyword">new</span> SubPerson(<span class="string">"yue"</span>, <span class="string">"female"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subperson2.nameGroup); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// suo</span></span><br><span class="line"><span class="comment">// male</span></span><br><span class="line"><span class="comment">// bye</span></span><br><span class="line"><span class="comment">// (3) ["xiao", "ai", "suo"]</span></span><br><span class="line"><span class="comment">// (2) ["xiao", "ai"]</span></span><br></pre></td></tr></table></figure></p>
<p>写到这里，只能感叹一句，<strong>寄生组合模式简直就是一个大杂烩啊</strong>。</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
        <a href="/tags/OOP/">OOP</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2015/12/05/t-book_js_006/">
        《JavaScript高级程序设计》读后记&lt;六&gt;：对象
      </a>
    </h2>
    
    <time>
      Dec 5, 2015
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <p>上篇博客谈到了引用类型，array, function 等等。它们都有一个共同的特点就是，它们都继承于 object，它们都是对象，拥有属性和方法。我虽然搞清楚了它们的很多特性和方法，也可以用它们做一些事情。但是对象这个东西还是有很多东西是有些模糊的，这些天我看完了面向对象这一章。里面很多设计和 c++, Java 面向对象很相似，有共通的地方，但是也有很多地方是 JS 独有的特性。现在我整理出了一条思路，写下这篇博客，希望能更加透彻的理解面向对象的思想。</p>
<h3 id="理解-JavaScript-面向对象"><a href="#理解-JavaScript-面向对象" class="headerlink" title="理解 JavaScript 面向对象"></a>理解 JavaScript 面向对象</h3><p>前面已经接触过了很多对象，现在稍稍回顾一下，话不多说，上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接new对象</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">person.name = <span class="string">"suo"</span>;</span><br><span class="line">person.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;; </span><br><span class="line">person.getName(); <span class="comment">// suod</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字面量创建对象</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span>,</span><br><span class="line"></span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line">person.getName(); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>这两种创建对象的方法都是最初级的，第二个比一个好那么一点点<br>在使用更高级的创建方法之前要讨论一下对象的属性</p>
<h4 id="理解属性的特性"><a href="#理解属性的特性" class="headerlink" title="理解属性的特性"></a>理解属性的特性</h4><p><strong>ES5 定义了特性(attribute)，它是内部使用的，用来描述属性(property)的特征</strong>。这句话怎么解释呢？特性和属性，我们所知道的属性，就是对象的属性，方法。但是这些属性有一些特征，而把属性的特征称为特性。并且用两对方括号表示 [[Enumerable]]</p>
<p>下面具体谈谈这些属性的特性。<strong>分为两种特性，一种是数据特性，一种是访问器特性</strong></p>
<ul>
<li>[[Configurable]]: 能否删除而重新定义属性，能否修改属性特性</li>
<li>[[Enumerable]]: 能否通过 for-in 返回属性</li>
<li>[[Writable]]: 能否修改属性的值</li>
<li>[[Value]]: 包含属性的值</li>
</ul>
<p>下面我们举个例子具体说明这些特性的意义<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>name</code>是对象<code>person</code>的属性，[[Value]] 的值就应该是<code>&quot;suo&quot;</code>，其中<code>name</code>是可以删除和重新定义的。可以通过 for-in 返回属性，可以修改值，由此我们得出上面三个特性的默认值都是<code>true</code></p>
<p>既然属性的特性有默认的值，那么是否可以修改呢，答案是可以的<br>ES5 有一个方法可以修改属性的特性值<code>Object.defineProperty()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>, <span class="comment">// 设置特性为不能修改</span></span><br><span class="line">    value: <span class="string">"suo"</span>     <span class="comment">// 设置属性的值为"suo"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// suo</span></span><br><span class="line">person.name = <span class="string">"yue"</span>; <span class="comment">// 严格模式下导致错误</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>我们看到我们可以通过这个方法直接为属性设置值，同时设置了只读权限</p>
<p>现在我们知道属性的特性是可以重新定义和修改的，但是我们也知道特性里有一个 [[Configurable]] 可以控制是否可以修改特性，也就是设置<code>Configurable</code>为<code>false</code>，就不能再修改这个对象属性的特性了(除<code>writable</code>以外)，下面我们验证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>, <span class="comment">//设置不能删除属性，不能重新定义特性</span></span><br><span class="line">    value: <span class="string">"suo"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    value: <span class="string">"yue"</span> <span class="comment">// 出错。不能重新定义特性</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">delete</span> person.name; <span class="comment">// 不起作用，严格模式报错</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br></pre></td></tr></table></figure></p>
<p>现在看看访问器特性，包含 getter 和 setter 函数，读取访问器属性调用 getter，写入调用 setter<br>同样的访问器特性也是四个，其中前两个和数据特性一样，后两个如下</p>
<ul>
<li>[[Get]]: 读取属性时调用的函数，默认值是<code>undefined</code></li>
<li>[[set]]: 写入属性时调用的函数，默认也是<code>undefined</code></li>
</ul>
<p>同样我们来看看代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设suo是男生，yue是女生，当改变对象名字的时候，使得性别也改变</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    _name: <span class="string">"suo"</span>, <span class="comment">// 只能通过对象方法访问</span></span><br><span class="line">    gender: <span class="string">"male"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line"></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name === <span class="string">"yue"</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.gender = <span class="string">"fel"</span> + <span class="keyword">this</span>.gender;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">person.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.gender); <span class="comment">// female</span></span><br></pre></td></tr></table></figure></p>
<p><strong>说了这么多，那么使用这些特性有什么好处呢？</strong><br><code>get</code>函数内只能读，<code>set</code>函数内只能写，这样就完美的实现了读写分离，支持这个方法的需要 IE9 以上<br>上面用的都是单个属性的操作，也有可以一次操作多个属性的方法<code>defineProperties()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    _name: <span class="string">"suo"</span>,</span><br><span class="line">    gender: <span class="string">"male"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(person, &#123;</span><br><span class="line">    _name: &#123;</span><br><span class="line">        writable: <span class="literal">false</span>,</span><br><span class="line">        value: <span class="string">"yue"</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    gender: &#123;</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        value: <span class="string">"male"</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    name: &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"yue"</span> === <span class="keyword">this</span>._name) &#123;</span><br><span class="line">                <span class="keyword">this</span>.gender = <span class="string">"fe"</span> + <span class="keyword">this</span>.gender;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">person.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.gender); <span class="comment">// female</span></span><br></pre></td></tr></table></figure></p>
<p>这个方法使用的效果和上面单个方法别无二致，唯一不同的是，这些特性是同一时间创建的<br>现在我们来读取这些特性，使用方法<code>getOwnPropertyDescriptor</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">"_name"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value); <span class="comment">// yue</span></span><br></pre></td></tr></table></figure></p>
<p>前面谈了那么多关于属性的特性，现在我们该进入正题了</p>
<h4 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h4><p><strong>(1)工厂模式</strong><br> 考虑到<code>ES</code>没法创建类，所以就采用了函数封装特定的接口创建对象，下面直接上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂方法：批量生产对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.gender = gender;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o.name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"yue"</span>, <span class="string">"female"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这样写的好处就在于，本来需要单个创建的对象，通过函数的封装，可以批量的创建对象了。<br>其实它是有缺点的，<strong>虽然解决了相似对象创建的问题，但是对象的识别没法解决</strong>。</p>
<p><strong>(2)构造函数</strong><br>我们知道引用类型是通过原生的构造函数创建对象，其实构造函数是可以自定义的。所以我们现在可以通过自定义的方式来创建对象，上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.name = gender;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"yue"</span>, <span class="string">"female"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这种方式和工厂模式其实很相似，大家可能一看就知道了。它们之间有些稍稍不同的地方，这些其实很好解释，知道构造函数生成对象的过程，就很容易理解了，这两种方式其实是一个原理。<br><strong>构造函数，new 的过程</strong>:</p>
<ul>
<li>创建一个新对象</li>
<li>将作用域给新对象</li>
<li>给对象添加属性</li>
<li>返回对象</li>
</ul>
<p>现在也许大家都明白了，原来我们使用的工厂模式，其实就是在模拟构造函数生成对象的过程<br>构造函数生成的对象都有一个 constructor 属性，它就是指向构造函数本身的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.constructor == Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>由此我们可以看出，<strong>构造函数相比工厂模式的好处就在于，它解决了对象的识别问题</strong>，我们可以通过这些方式来判断，这个对象到底是由哪个函数构造的。<br>当然这种模式也是存在缺陷的，虽然我们利用工厂模式和构造函数，生产了很多对象。但是每生产一个对象，就要给对象里的属性和方法分配一块内存，然而对象的方法很多都是一样的。<strong>这样就导致了内存的大量的浪费</strong>，我们能否让这些方法共享呢？现在尝试独立这些共享方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    <span class="keyword">this</span>.getName = getName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125; <span class="comment">// 独立方法</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>虽然这是可行的，但是污染了全局作用域。<code>getName</code>虽然是全局的，单真正确是用在构造函数里面。这在开发中是一种及其不好的做法。</p>
<p><strong>(3)原型模式</strong><br>我们之前谈到函数类型，它都有一个 prototype 属性，当时没有过多的研究，现在可以好好探究一下了。首先这个属性是一个指针，指向一个对象，这个对象里面包含了所有实例共享的属性和方法。到这里你肯定明白了，<strong>原来这个原型属性就是为了解决构造函数无法共享属性和方法的啊</strong>。上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"suo"</span>;</span><br><span class="line">Person.prototype.gender = <span class="string">"male"</span>;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">//suo</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.getName()); <span class="comment">//suo</span></span><br></pre></td></tr></table></figure></p>
<p>很明显，原型对象的属性和方法，对于对象来说都是公有的，大家都一样。<br>下面继续深挖一下原型对象这种东西，有助于之后学习的理解<br><strong>只要创建函数，就会有一个 prototype 属性，这个属性指向了函数的原型对象。默认情况下所有的原型对象都会获得一个 constructor 属性，这个 constructor 是一个指向这个 prototype 所在的函数的指针</strong>。这个关系有点微妙，我还是画个图说明一下吧<br><img src="/images/dm3.png" alt="img"><br>代码验证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor); <span class="comment">// f Person()&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>其中我们可以通过<code>isProtptypeOf()</code>方法验证对象原型的对应关系<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><code>ES5</code>新增了<code>getPrototypeOf()</code>方法来获取原型值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1));</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;  name: "suo", gender: "male", getName: ƒ, constructor: ƒ &#125;</span></span><br><span class="line"><span class="comment">//    gender: "male"</span></span><br><span class="line"><span class="comment">//    getName: ƒ ()name:"suo"</span></span><br><span class="line"><span class="comment">//    constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">//    __proto__: Object</span></span><br></pre></td></tr></table></figure></p>
<p>上面我们通过这个方法把原型的全部内容打印了出来，这些都清楚了是吧<br>虽然可以通过对象访问原型的值，但是不能通过对象重写原型的值，这个原因很简单，因为我们知道，原型的属性和方法都是共享的，如果随便一个实例都能改动的话，原型就乱套了，<strong>改变一个原型的属性就会影响其他的实例</strong>。因此原型是不允许实例改变的。<strong>如果实例的属性名字与原型名字重名的话，它会屏蔽原型的属性</strong>。测试一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person1.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// yue</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.getName()); <span class="comment">// suo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person1.name; <span class="comment">// 删除属性</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>我们现在知道了，实例的属性是可以和原型重名的，那么怎么判断它到底是谁的属性呢，<strong><code>hasOwnProperty()</code>可以来检测这个属性到底是实例的还是原型的</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person1.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// yue</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> person1.name; <span class="comment">// 删除属性</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// suo</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>由此可知，<code>true</code>就是实例的，<code>false</code>就是原型的<br>现在我们没那么严苛，<strong>我们想要判断该属性是否可以被实例访问到，这里就有<code>in</code>方法可以判断</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>除此之外，如果我们还想得到所有实例的属性，也有种方法使用，for-in</strong>，当然有些不可枚举的属性是访问不到的。我们尝试去做一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (prop <span class="keyword">in</span> person1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name</span></span><br><span class="line"><span class="comment">// gender</span></span><br><span class="line"><span class="comment">// getName</span></span><br></pre></td></tr></table></figure></p>
<p>我们发现没有 protptype 属性，原因是它都是不可枚举的，[[enumerable]] 为<code>false</code><br>除此之外我们还可以使用<code>Object.keys()</code>方法来枚举对象属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(Person.prototype));</span><br><span class="line"><span class="comment">// (3) ["name", "gender", "getName"]</span></span><br></pre></td></tr></table></figure></p>
<p>关于原型的写法，同样我们可以通过字面量来批量写原型属性，方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person, // 构造函数还原</span><br><span class="line">    name: "suo",</span><br><span class="line">    gender: "male",</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure></p>
<p>要注意的一点是，字面量本身也是一个对象，<strong>原型指向字面量后指针就跑歪了，所以要我们要让它重新指向函数。这种方式仍然有个问题就是</strong>，本身 prototype 属性是不可枚举的，现在把 constructor 加上去后，导致变成可枚举的了，现在属性的特性的知识就有用武之地了，我们可以直接设置它的特性为不可枚举的，那不就可以了吗。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"suo"</span>,</span><br><span class="line">    gender: <span class="string">"male"</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 添加属性值并设置特性不可枚举</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: Person</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们之前谈到不能用实例修改原型，但是我们可以直接在原型上做修改啊，修改的原型后会对实例有什么影响呢？测试一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = <span class="string">"yue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// yue</span></span><br></pre></td></tr></table></figure></p>
<p>由此我们可知，<strong>即使是先创建了实例，修改原型属性后，实例访问的原型属性也会修改，说明原型是动态的</strong>，这其实也很简单说明。实例和原型本身就不是绑定的，我们通过原型访问，是通过指针访问的。原型里的属性改变了，我们再次通过指针访问时，当然也是改变后的属性了。<br>说了这么多，看起来原型挺好的，但是光有原型也是不够的，我们知道原型的方法和属性都是共享的，那么我私人的属性和方法该怎么办呢？<strong>那么为什么不把这两种模式结合起来呢？</strong></p>
<p><strong>(4)组合模式(构造+原型)</strong><br>结合构造和原型，我们来试着创建一个对象吧<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="comment">// constructor: Person,</span></span><br><span class="line">    origin: <span class="string">"monkey"</span>,   <span class="comment">// 起源</span></span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: Person</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"yue"</span>, <span class="string">"female"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.name === person2.name); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.origin === person2.origin);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>我们使用图示来说明这个方式<br><a href="/images/dm4.png">img</a></p>
<p><strong>(5)动态原型</strong><br>学过了其他 oop 语言，像c++，Java 都是用类封装所有的属性和方法，倒是觉得 ES 的比较奇怪了。现在就有一种方法来动态的创造原型，<strong>需要时才创建原型属性和方法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getName != <span class="string">"function"</span>) &#123;</span><br><span class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p><strong>只有当调用这个方法时，这个方法不存在，它才会被添加在原型里</strong>，使用动态模式不能用字面量方法给原型赋值，原因就是，它会将 constructor 导向新的对象，之前也遇到过。</p>
<p><strong>(6)寄生构造</strong><br>一句话，使用构造函数的工厂模式创建对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.gender = gender;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>咋一看，<strong>这不就是在构造函数里再造一个工厂模式吗？</strong>到底有啥用<br>其实这个寄生构造函数的用途，<strong>在于对原生的构造函数进行修改，重新造一个构造函数</strong>，比如下面<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建数组对象</span></span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>;</span><br><span class="line">    <span class="comment">// 添加参数</span></span><br><span class="line">    arr.push.apply(arr, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 添加方法</span></span><br><span class="line">    arr.toUpdateJoin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 返回数组</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> SpecialArray(<span class="string">"suo"</span>, <span class="string">"yue"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.toUpdateJoin()); <span class="comment">// suo|yue</span></span><br></pre></td></tr></table></figure></p>
<p>这样就改造好了，把原来数组的连接改成了<code>|</code>。</p>
<p><strong>(7)稳妥构造</strong><br>某个人发明了稳妥对象概念，什么是稳妥对象呢，<strong>它其实就是没有公共属性，不引用 this 对象</strong>。借鉴寄生构造函数，实现这个稳妥构造，上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name; <span class="comment">//注意这里没this</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"suo"</span>, <span class="string">"male"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>这种模式非常安全，里面没有公共属性和 this ，这样外界要访问到<code>name</code>，只能通过函数来访问了。写了这么多也差不多把面向对象搞清楚了一半，下一篇博客，专门研究面向对象里的 <strong>继承</strong>。</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
        <a href="/tags/OOP/">OOP</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2015/12/02/t-book_js_005/">
        《JavaScript高级程序设计》读后记&lt;五&gt;：引用类型
      </a>
    </h2>
    
    <time>
      Dec 2, 2015
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <p>前几篇博客，谈到了变量有 2 类数据类型，5 种基本数据类型和引用数据类型。同时也阐述了基本数据类型和引用数据类型的区别。但是一直没有提到具体的引用类型，今天专门看了引用类型一章，发现里面涉及的内容还挺多的。一时难以记住全部的内容，所以在这里写一篇博客，留做以后的学习作参考。</p>
<h3 id="理解引用类型"><a href="#理解引用类型" class="headerlink" title="理解引用类型"></a>理解引用类型</h3><p>引用类型的值(对象)是引用类型的实例，这和基本类型也是一样的，基本类型的值当然也是基本类型的实例。它们唯一的区别在于引用类型是一种数据结构，它的数据的组织更加复杂些。<br>前面也提到过，对象的创建是用 <strong>new</strong> 方法创建的。这里的所有的引用类型都类似，可以用 new 方法创建。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>; <span class="comment">// 同样的括号可以省略</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h4><p>除了上面那种创建 object 方法外还有种方法，使用对象字面量来表示<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name : <span class="string">"suo"</span>,</span><br><span class="line">    gender : <span class="string">"male"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>除此之外还有另一个写法，就是空对象，后添加属性，这也是可以的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">"suo"</span>;</span><br><span class="line">person.gender = <span class="string">"male"</span>;</span><br></pre></td></tr></table></figure></p>
<p>同时我们可以看到，object 访问属性是通过<code>.</code>来访问，其实也有另一种方法，通过<code>[]</code>来访问<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person[<span class="string">"name"</span>] = <span class="string">"suo"</span>;</span><br><span class="line">person[<span class="string">"gender"</span>] = <span class="string">"male"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"name"</span>]+<span class="string">','</span>+person[<span class="string">"gender"</span>]); <span class="comment">// suo,male</span></span><br></pre></td></tr></table></figure></p>
<p><strong>那么问题来了，什么时候用<code>.</code>，什么时候用<code>[]</code>呢？</strong><br><code>[]</code>表示法有个优点，就是他可以通过变量访问属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person[<span class="string">"name"</span>] = <span class="string">"suo"</span>;</span><br><span class="line">person[<span class="string">"gender"</span>] = <span class="string">"male"</span>;</span><br><span class="line"><span class="keyword">var</span> suo = <span class="string">"name"</span>; <span class="comment">// 将属性字符串赋值给变量</span></span><br><span class="line"><span class="built_in">console</span>.log(person[suo]+<span class="string">','</span>+person[<span class="string">"gender"</span>]); <span class="comment">// suo,male</span></span><br></pre></td></tr></table></figure></p>
<p>除此之外，都用<code>.</code>来表示，毕竟<code>.</code>表示更加方便简洁</p>
<h4 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h4><p>上面提到了 object 类型，下面具体谈一下 array 类型。其实感觉他俩挺像的，为什么这么说呢？<br>之前一段时间我一直在学习数据结构。真正的体会到了，很多看似不同的东西，其实在结构上是很相似的，甚至只是改进了一下数据的组织方式而已。<br>我们可以想象一下<code>object</code>的数据结构<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    key1 : value1,</span><br><span class="line">    key2 : value2,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>value</code>也可以是函数，对比一下数组的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="number">0</span> : value1,</span><br><span class="line">    <span class="number">1</span> : value2,</span><br><span class="line">    ...</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>其中数组中的下标是在字面量中省略的<br>很明显，它们的数据结构都是线性的序列，区别在于两点<br>1.object 的元素，可以是任意类型的。array 的一般是同一类类型的元素<br>2.object 是关联容器结构，array 是顺序容器结构。array 是寻秩访问，object 是寻关键码访问。<br><strong>谈到了它们之间的区别与联系，现在具体说一下 array 吧</strong><br>创建 array 也是有两种方法，一种是 new ,一种是字面量。和 object 差别不大<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>; <span class="comment">// 同理可省略</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    arr[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125; <span class="comment">// 1 2 3 4 5 6 7 8 9 10</span></span><br></pre></td></tr></table></figure></p>
<p>省略括号表示创建一个空的数组，数组不仅可以创建空数组，还可以创建想要的形式的数组<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// 创建包含三个元素的数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"hello"</span>); <span class="comment">// 创建包含一项元素"hello"的数组</span></span><br></pre></td></tr></table></figure></p>
<p>另外一种方式是字面量的，这种方式创建数组更加灵活<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []; <span class="comment">// 空数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"!"</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [ , , ]; <span class="comment">// 不建议使用，会生成undefined变量</span></span><br></pre></td></tr></table></figure></p>
<p>数组的长度可以用 length 得到<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.length); <span class="comment">// 4</span></span><br><span class="line">arr1[arr1.length] = <span class="number">5</span>; <span class="comment">// 添加一项</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1[<span class="number">4</span>]); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>
<p>之前谈到可以用<code>instanceof</code>来检测数组，但是它只能在一个全局内检测。所以 ES5 新增了一个方法来检测数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><code>Array</code>有很多类型的方法，我们先归一下类，以后再慢慢细究吧。<br>(1)转换方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(colors.toString()); <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.valueOf()); <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.join(<span class="string">"|"</span>)); <span class="comment">// red|blue|green</span></span><br></pre></td></tr></table></figure></p>
<p>(2)栈方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors.push(<span class="string">"yellow"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["red", "blue", "green", "yellow"]</span></span><br><span class="line">colors.pop(); </span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure></p>
<p>(3)队列方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors.push(<span class="string">"yellow"</span>, <span class="string">"black"</span>);</span><br><span class="line"><span class="keyword">var</span> pop = colors.pop(); <span class="comment">// black </span></span><br><span class="line"><span class="keyword">var</span> head = colors.shift();  <span class="comment">// red</span></span><br><span class="line">colors.unshift(<span class="string">"red"</span>, <span class="string">"black"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(pop+<span class="string">','</span>+head); </span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["red", "black", "blue", "green", "yellow"]</span></span><br></pre></td></tr></table></figure></p>
<p>(4)重排序方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转组项顺序</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>,  <span class="number">4</span>];</span><br><span class="line">num.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 4,5,2,3,1</span></span><br><span class="line"><span class="comment">//升序排序</span></span><br><span class="line">num.sort();</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure></p>
<p>(5)操作方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 粘贴(新数组)</span></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.concat(<span class="string">"yellow"</span>, [<span class="string">"black"</span>, <span class="string">"white"</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(colors2);</span><br><span class="line"><span class="comment">// (6) ["red", "blue", "green", "yellow", "black", "white"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 截切(新数组)</span></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> colors3 = colors.slice(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 不包含1</span></span><br><span class="line"><span class="built_in">console</span>.log(colors2); <span class="comment">// ["blue", "green"]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors3); <span class="comment">// ["red"]co</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换(原数组上操作)</span></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors.splice(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors)</span><br><span class="line">colors.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"yellow"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors)</span><br><span class="line">colors.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors)</span><br><span class="line"><span class="comment">//(2) ["red", "green"]</span></span><br><span class="line"><span class="comment">//(3) ["red", "yellow", "green"]</span></span><br><span class="line"><span class="comment">//(3) ["red", "black", "green"]</span></span><br></pre></td></tr></table></figure></p>
<p>(6)位置方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正向查找</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(num.indexOf(<span class="number">3</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 逆向查找</span></span><br><span class="line"><span class="built_in">console</span>.log(num.lastIndexOf(<span class="number">3</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>(7)迭代方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每项都</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> res = num.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 每项结果</span></span><br><span class="line"><span class="keyword">var</span> res2 = num.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// [3, 5, 4]</span></span><br><span class="line"><span class="comment">// 每项运行</span></span><br><span class="line"><span class="keyword">var</span> res3 = num.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    num = num * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res3);</span><br><span class="line"><span class="comment">// 每次结果数组</span></span><br><span class="line"><span class="keyword">var</span> res4 = num.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item * <span class="number">2</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res4);</span><br><span class="line"><span class="comment">// 任一项</span></span><br><span class="line"><span class="keyword">var</span> res5 = num.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);  </span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res5);</span><br></pre></td></tr></table></figure></p>
<p>(8)归并方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正向归并</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = num.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 逆向归并</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = num.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h4><p>我们可能学习过 Java 中的 Date 类型，其实 ES 也是借鉴它构建的。使用的也是 UTC 来保存日期。保存的日期的范围为 1970.1.1 前后的 1 亿年。<br>使用<code>new</code>创建<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line"><span class="built_in">console</span>.log(now); <span class="comment">// Sun Dec 02 2016 11:10:38 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure></p>
<p><strong>由此得知，Dete对象默认创建的是当前的时间，那怎么得到特定的时间呢?</strong><br>有两种方法：一种是<code>Date.parse()</code>，另一种是<code>Date.UTC()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">"Nov 12, 1995"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(someDate); <span class="comment">// Fri Nov 12 1995 00:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="comment">// 省略Date.parse也是可以的</span></span><br><span class="line"><span class="keyword">var</span> someDate2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"Sep 22, 1996"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(someDate2); <span class="comment">// Sun Sep 22 1996 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure></p>
<p>上面的方法返回的是日期对象，下面再测试一下<code>Date.UTC()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">1995</span>, <span class="number">11</span>, <span class="number">12</span>));</span><br><span class="line"><span class="built_in">console</span>.log(someDate); <span class="comment">// Sun Dec 12 1995 08:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line"><span class="keyword">var</span> someDate2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1995</span>, <span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(someDate2); <span class="comment">//Tue Dec 12 1995 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure></p>
<p>由此我们得知，这两种方法都是可以自动调用的，调用哪一种方法取决于传入的参数。<br><code>ES5</code>新增了一种<code>now()</code>方法，可以取得当前时间的毫秒数，那么我们可以用它做一些有用的事<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    sum = i*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> end = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="keyword">var</span> runtime = end - start;</span><br><span class="line"><span class="built_in">console</span>.log(runtime); <span class="comment">// 10(ms)</span></span><br></pre></td></tr></table></figure></p>
<p>用+操作符也可以达到同等目的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> +<span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure></p>
<p>因为时间本身是毫秒数，所有可以用<code>&gt;</code>或者<code>&lt;</code>比较日期<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2016</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(date1 &gt; date2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>格式化日期<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line"><span class="built_in">console</span>.log(date.toDateString()); <span class="comment">// Sun Dec 02 2016</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toTimeString()); <span class="comment">// 11:53:46 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toLocaleDateString()); <span class="comment">// 2016/12/2</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toUTCString()); <span class="comment">// Sun Dec 02 2016 11:53:46 GMT</span></span><br></pre></td></tr></table></figure></p>
<p>日期组件方法，都是一些 get，set 方法，这里就不一一说了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line"><span class="built_in">console</span>.log(date.getTime()); <span class="comment">// 1506830282288(ms)</span></span><br></pre></td></tr></table></figure></p>
<h4 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h4><p>我学过 PHP 的正则表达式，学过 Java 的正则表达式，很有意思的是现在又学<code>JS</code>的正则表达式，相对来说容易很多了，除了调用的方法名有所不同以外，其他的内容几乎无差别<br>首先创建一个正则表达式，同样是两种方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"pat"</span>,<span class="string">"flags"</span>); <span class="comment">// new对象</span></span><br><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/pat/</span>flags; <span class="comment">// 字面量</span></span><br></pre></td></tr></table></figure></p>
<p>稍微解释一些这个表达式的含义，<code>/</code>这个是表达式的定界符，就是隔离正则与其他字符的一个分界，为其他字符也可以，表达式后面的<code>flags</code>是一个标记，就是来切换正则表达式匹配规则的模式。<br>常见的模式有 g 表示全局模式，i 不区分大小写，m 多行模式，举几个例子说明下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/i</span>;</span><br></pre></td></tr></table></figure></p>
<p>解释一下，<code>suo</code>是正则法则，i 是模式，也就是匹配字符<code>suo</code>,且不区分大小写<br>使用<code>test</code>来测试是否匹配上<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/i</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pat.test(<span class="string">"Suo"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.test(<span class="string">"SUO"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.test(<span class="string">"sso"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>ES5 规定，使用字面量创建正则必须像直接调用 RegExp 构造函数一样，每次都要创建新的实例。<br>下面我们来看看实例的属性和方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/i</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pat.global); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.ignoreCase); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.multiline); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.lastIndex); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(pat.source); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>这些属性都是正则表达式本身具有的一些属性，没啥用，<br>但是它的两个方法是我们要掌握的，<strong>第一个就是<code>exec()</code>它是用来捕获组的</strong>，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/ig</span>; <span class="comment">// 全局模式</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"suo: I am Suoyue"</span>;</span><br><span class="line"><span class="keyword">var</span> matches = pat.exec(str);</span><br><span class="line"><span class="comment">// 第一次捕获</span></span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches.input); <span class="comment">// suo: I am suo yue"</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">// suo</span></span><br><span class="line"><span class="comment">// 第二次捕获</span></span><br><span class="line">matches = pat.exec(str);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">// Suo</span></span><br></pre></td></tr></table></figure></p>
<p>正如上面所说，每一次捕获都要创建实例，都要再执行一遍捕获方法<br><strong>另一种方法是<code>test()</code>方法，他是一个判断是否匹配，正如它的名字，只是测试而已</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/i</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"suo: I am Suoyue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pat.test(str)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>假设我现在捕获到了一个组，我们怎么取得我们想要的东西呢？</strong><br>答案是使用RegExp的构造函数属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pat = <span class="regexp">/suo/ig</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"ss suo: I am Suoyue"</span>;</span><br><span class="line"><span class="keyword">if</span> (pat.test(str)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$_);    <span class="comment">// 最近一次要匹配的字符串 suo: I am Suoyue</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$`"</span>]); <span class="comment">// 最近匹配项前面的字符串 ss</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$'"</span>]); <span class="comment">// 最近匹配项后面的字符串 : I am Suoyue</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$&amp;"</span>]); <span class="comment">// 最近一次匹配项 suo</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$+"</span>]); <span class="comment">// 最近匹配的捕获组 [空]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$*"</span>]); <span class="comment">// 是否使用多行模式 (未实现)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了上面 6 个以外还有很多，不一一累述了<br>虽 ES 正则表达式功能还是比较完备的，但是对于 PHP 和 Java  还是缺少很多高级特性，作为一个前端的脚本语言，这些已经足够了</p>
<h4 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h4><p>前面我们一直提到函数，他是对象，它可以赋值给变量，它是 ES 中最小的作用域。但是一直我都没有具体研究它，现在我读了函数这章，很多之前的稍有疑问的地方，现在都豁然开朗了。</p>
<p>之前也说过，<strong>函数有两种表达方式，一种是使用函数声明，一种是使用函数表达式</strong>。我们稍微回顾一些这两种形式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//code...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//code...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意的是函数声明是会有函数声明提升的，之前也讲过，这里不在累述了。<br>由上面可以看出，函数包含函数名，函数本体，也就是<code>{}</code>里面的内容</p>
<p>函数实际是对象，<strong>那么函数名实际上是一个指向函数对象的指针，不会与某个函数绑定</strong><br>这句话怎么理解呢？下面给出一个例子来说明这个问题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"suo"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> boo = foo;</span><br><span class="line">foo = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 经测试foo解引用后，运行会出错</span></span><br><span class="line">boo(); <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>由上面的代码可以看出，<code>foo</code>只是一个指向函数对象的指针，当使用解引用后，断绝了这个关系了。而<code>boo</code>又指向了函数对象，所以可以运行。</p>
<p>下面我们来探讨另一个问题，既然我们已经得出结论，函数名只是一个指向函数对象的指针。那函数就不应该有重载这个特性。因为同一个函数名是指向同一个函数对象的。就不会指向其他对象的说法<br>下面我们也来例证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"suo"</span>;</span><br><span class="line"><span class="keyword">var</span> gender = <span class="string">"male"</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name+<span class="string">','</span>+gender);</span><br><span class="line">&#125;</span><br><span class="line">foo(name); <span class="comment">// suo,undefined</span></span><br><span class="line">foo(name, gender); <span class="comment">// suo,male</span></span><br></pre></td></tr></table></figure></p>
<p>由上可知，如果函数有重载的话，第一个<code>foo</code>执行的结果应该是<code>suo</code>，但是实际的结果确实<code>suo</code>，<code>undefined</code>。很显然第一个函数执行的也是第二个函数表达式。第二个表达式的函数覆盖了之前的。<br>得出结论，<strong>函数重名会覆盖，不管参数是怎样的</strong></p>
<p>上面也提到了函数是对象，那么函数就可以给其他变量赋值。不仅如此函数还可以作为返回值用。<br>下面看一个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较人的身高</span></span><br><span class="line"><span class="keyword">var</span> suo = &#123;</span><br><span class="line">    height : <span class="number">180</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> yue = &#123;</span><br><span class="line">    height : <span class="number">170</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">campareHeight</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params">suo, yue</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (suo.height &gt; yue.height) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (suo.height &lt; yue.height) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(suo, yue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(campareHeight(<span class="string">"height"</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>这里要提醒下，函数声明是不可以直接做返回值的，只有执行后的函数才能做返回值.一般这种情况我，使用立即执行函数一步来搞定，下面写一个立即执行函数的简单例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明与执行分步写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo()); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 使用立即执行函数一步写</span></span><br><span class="line"><span class="built_in">console</span>.log( (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;)() ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>函数内部有两个特殊的对象：arguments 和 this</strong><br>arguments 是一个类数组对象，包含传入函数的所以参数主要用来保存函数参数的，这个对象有一个叫 callee 的属性，它是一个指针，指向拥有这个 arguments 对象的函数。<br>下面一个例子告诉我们caller的用法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>); <span class="comment">// 3628800</span></span><br></pre></td></tr></table></figure></p>
<p>其实这个就是 10 的阶乘。关键在于这行代码<code>arguments.callee(num-1)</code>，我们再仔细揣摩这句话，<strong>callee 的属性，它是一个指针，指向拥有这个 arguments 对象的函数</strong>，现在明白了<code>arguments.callee(num-1)</code>就等同于<code>foo(num-1)</code>，这样就清楚了。<br>该说说 this 了，我看了半天书上的叙述，总结了一句话，<strong>当在哪个作用域调用函数时，该函数中的 this 就是哪个作用域对象</strong><br>下面验证下这句话的正确性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局调用</span></span><br><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    color: <span class="string">"blue"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">getColor(); <span class="comment">// red</span></span><br><span class="line">o.getColor = getColor;</span><br><span class="line">o.getColor(); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure></p>
<p>另一个是<code>caller</code>，表示调用当前函数的函数的引用，全局作用域为<code>null</code>，验证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    boo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(boo.caller); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.caller); <span class="comment">// null</span></span><br><span class="line">foo(); <span class="comment">// ƒ foo() &#123; boo();&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这里可以看到显示了 foo 的源码，下面用另一种方式实现这个效果(根据 callee 的用法好理解)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    boo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.caller); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.caller); <span class="comment">// null</span></span><br><span class="line">foo(); <span class="comment">// ƒ foo() &#123; boo();&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这种写法虽然现在可以，但是出于安全性考虑，严格模式下已经不许这样做了，另外严格模式下函数的 caller 属性是不能赋值的</p>
<p>都说对象是有属性方法的，函数也不例外，下面谈谈函数的属性和方法吧<br>函数有两个属性一个是 leghth，一个是 prototype ，前面一个是指希望接受参数个数，没什么好说的。关键在于这个 prototype 属性,这个属性是ES搞面向对象专门搞得一个属性，这里不谈太多了，下一篇博客研究对象和继承时。好好探究这个属性。这里就简单提几点，ES5 中，prototype 属性太多，是无法使用 for-in 枚举的。</p>
<p>下面我们聊聊,<strong>函数的两个独有的方法</strong>，说独有是因为它不是其他对象有的，因为它们关系到作用域。我们知道 ES 就只有函数作用域，所以这一切搜说得通了。<br>这两个方法，一个是<code>apply()</code>,一个是<code>call()</code>,这两个函数有很多相似之处。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callFoo</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">callFoo(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>这里我的理解是，apply这个函数，是将 callFoo 的 this 对象和 arguments 传给了 foo，并执行结果返回给 callFoo，也可以不用自己的 arguments 对象，随意传一个数组也可以。因为 arguments 本身也是一个数组。如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callFoo</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.apply(<span class="keyword">this</span>, [<span class="number">3</span>, <span class="number">2</span>]); <span class="comment">// 替换成自己的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不写参数看看</span></span><br><span class="line">callFoo(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>果然是这样，证明我的理解是正确的。<br>理解了 apply，call 也就好理解了，它们区别就在于参数，不同于 apply，一个作用域和一个参数数组。<strong>call 的参数要全部单独写出来</strong>。改变上面的代码，看看<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callFoo</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.call(<span class="keyword">this</span>, <span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 参数数组变成单个参数</span></span><br><span class="line">&#125;</span><br><span class="line">callFoo(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>一切都在意料之中，果然是这样。<br>说了这么这两个方法，它们有啥用呢？<strong>它们的真正用处在于扩充函数的作用域</strong><br>下面看一个例子你就明白了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    color: <span class="string">"blue"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">getColor();            <span class="comment">// red</span></span><br><span class="line">getColor.call(<span class="keyword">this</span>);   <span class="comment">// red</span></span><br><span class="line">getColor.call(<span class="built_in">window</span>); <span class="comment">// red</span></span><br><span class="line">getColor.call(o);      <span class="comment">// blue</span></span><br></pre></td></tr></table></figure></p>
<p>这里你是否明白了呢，<code>getColor</code>本来是全局作用域，本应该是输出<code>red</code>，绑定<code>o</code>后，竟然可以输出对象的变量。这样做的最大好处是函数既访问到了对象的变量，而且和对象没有形成耦合关系。<br>最后说一个 ES 方法<code>bind()</code>。下面看一下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    color: <span class="string">"blue"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oGetColor = getColor.bind(o);</span><br><span class="line">oGetColor(); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure></p>
<p>这个方法比<code>call()</code>更直接，直接实现函数对象绑定的值，并给一个新的函数。这个就牛逼了，具有<code>call()</code>的好处,并且更加直接，好理解。</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2015/11/29/t-book_js_004/">
        《JavaScript高级程序设计》读后记&lt;四&gt;：垃圾回收
      </a>
    </h2>
    
    <time>
      Nov 29, 2015
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <p>上一篇博客里，阐明了闭包的概念和作用，但是它有个缺点就是容易造成内存泄露，为什么会造成内存泄露呢？内存泄露又是怎样产生的呢？这一切要从 JavaScript 的垃圾回收机制说起</p>
<h3 id="理解JavaScript的垃圾回收机制"><a href="#理解JavaScript的垃圾回收机制" class="headerlink" title="理解JavaScript的垃圾回收机制"></a>理解JavaScript的垃圾回收机制</h3><p>JavaScript 具有自动垃圾回收机制，因此我们可以不必管它，但是也要知道它的原理。<br>垃圾回收机制的原理：<strong>垃圾回收机制会周期性的释放不再使用的变量的内存</strong>。<br>这里我们要知道两点：<br>1.这个周期是多少？是如何决定的？<br>2.如何判断这个变量不再继续使用？</p>
<p>我们先来探究第二个问题，<strong>如何判断这个变量不再使用，并回收</strong>？<br>我们知道，每一个变量都是有生命周期的，如果哪个变量没有的话，就会一直残留下去，总有一天会消耗完内存。这也叫内存泄露。下面我们分析下局部变量的正常生命周期<br>局部变量只在函数执行过程中存在，函数执行结束后，局部变量就没有存在价值了，然后垃圾回收器给无用的局部变量标记。等回收周期到来的时候，回收这个变量。</p>
<p><strong>标记变量有两种策略：一种是标记清除法，另一种是引用计数法</strong><br>这个标记清除法其实很简单解释，当变量进入环境时（变量声明），该变量就被标记为“进入环境”。当变量离开环境时（函数执行完），该变量就被标记为“离开环境”。而这些被标记成离开环境的变量就是无用变量，等着垃圾回收机制回收就可以了</p>
<p>第二个问题清楚了，我们看看第一个问题，<strong>垃圾回收机制的周期是多少？怎么决定的？</strong><br>从 IE 开始谈起，IE 垃圾回收器是根据内存分配量运行的，具体就是 256 个变量，4096 个对象字面量，数组元素，或者 64Kb 的字符串。达到上面任何一个临界值，垃圾回收器就开始运行。但是这样又出现了一个问题，如果一个脚本本来就有那么多变量，垃圾回收器就会一直的运行。每次回收完了又到达临界值，这样导致垃圾回收器频繁的调用，对性能来说是有很大影响的。</p>
<p>等到 IE7 的出现，重写了垃圾回收机制。<strong>固定的临界量改为了动态的分配</strong>。垃圾回收的内存分配量低于 15% 时，临界值就加倍。当内存分配量达 85% 时，临界时恢复为初始的值。简单的来说就是，内存够用时，就不急着回收。内存不够时，就和初始一样，达到就回收。这样一来，即便脚本中的变量很多，只要内存够用，也不会频繁的调用垃圾回收器了。</p>
<p>在 JavaScript 中虽然我们不必担心内存管理的问题，但是我们也需要保证页面的性能更好。这里我们可以去优化内存。<strong>优化内存最佳的方式就是，将无用数据，设置为<code>null</code>,来释放其引用，也就是解除引用</strong>。</p>
<p>下面我们来看一段代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span>  localPerson = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">    localPerson.name = name;</span><br><span class="line">    <span class="keyword">return</span> localPerson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> globalPerson = createPerson(<span class="string">"suo"</span>);</span><br><span class="line"><span class="comment">// 解除引用</span></span><br><span class="line">globalPerson = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>这里我们可以知道的是<code>localPerson</code>是局部的变量，所以垃圾回收器会自动为它解除引用<br>但是<code>globalPerson</code>是全局变量，如果不需要用了，垃圾回收机制不会干，现在我们手动为它解除引用。解除引用之后，它不会立即销毁，只是脱离了执行环境，等待垃圾回收器来回收。</p>
<p>说了这么多，搞清楚了垃圾回收机制。上一篇博客中谈到闭包的缺点，闭包会造成内存泄露。清楚了垃圾回收机制，我们可以知道的是，闭包访问的变量是无法被垃圾回收器回收的。那么我们该怎么办了。恰好刚刚就有种方法。我们可以手动来解除引用。这样就避免了闭包产生的内存泄露了。<br>下面给出闭包和解除引用的实例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHadler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>);</span><br><span class="line">    <span class="keyword">var</span> id = element.id;</span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(id);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 解除引用</span></span><br><span class="line">    element = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2015/11/28/t-book_js_003/">
        《JavaScript高级程序设计》读后记&lt;三&gt;：闭包
      </a>
    </h2>
    
    <time>
      Nov 28, 2015
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <p>在上一篇博客里，谈到了作用域，留下了一个问题，怎样从函数外访问到函数内部的局部变量。这是在我完全理解闭包和函数后，写的一篇博客。</p>
<h3 id="理解函数与闭包"><a href="#理解函数与闭包" class="headerlink" title="理解函数与闭包"></a>理解函数与闭包</h3><p>前面我们知道了作用域最小单位就是函数，那么函数是怎么表示的呢？<br>定义函数有两种方式：一种是函数声明，另一种是函数表达式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg0, arg1, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们知道函数也是一种引用类型，所以函数，也有自己的属性，其中一个就是<code>name</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo.name);  <span class="comment">// foo</span></span><br></pre></td></tr></table></figure></p>
<p>由此我们也更加确定了，函数也是一个对象，里面包含各种属性和方法<br>对于函数还有一个特别的性质，那就是函数声明提升，如同变量声明提升，函数声明也是可以提升的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayBye();  <span class="comment">// bye bye</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayBye</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"bye bye"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数声明提升会带来一个问题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">saybye</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// code...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> (a &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">saybye</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// code...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码，很容易看出来，函数声明提升后，可能产生和预期不一样的效果<br>接下来我们看下函数表达式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">arg0, arg1, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//code..</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>这个表达式怎么解释呢？</strong><br>就如一个赋值语句一样，将后面的匿名函数赋值给<code>foo</code>变量，有人可能有疑问，函数也可以赋值吗？在 js 里面来说，这是可以的，因为 js 里面函数也是一种引用类型，当作对象赋值给变量</p>
<p><strong>那么函数表达式是否也有函数提升呢？</strong><br>下面验证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// VM225:1 Uncaught TypeError: foo is not a function</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"ok"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>答案是没有，函数并没有提升上去，因为在这里函数作为了对象赋值给了变量，并不是声明，这里的赋值同样的也是引用赋值。此时<code>foo</code>指向的是堆中的内存块。</p>
<p><strong>谈谈闭包</strong><br>闭包是有权访问另一个函数作用域中的变量的函数，创建闭包的常见方式，就是在一个函数内部创建另一个函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要访问foo中的a</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a1);</span><br><span class="line"><span class="comment">// VM309:4 Uncaught ReferenceError: a1 is not defined</span></span><br></pre></td></tr></table></figure></p>
<p>显然访问不了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用闭包函数访问</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b();</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p><strong>下面解释一下是怎么做到的</strong><br><code>a2</code>是<code>foo</code>的局部变量，而是<code>b</code>函数的外部变量，而<code>b</code>是可以访问到的，<code>b</code>函数在闭包函数<code>b</code>返回到外部的函数或全局变量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改写成立即执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a3 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a3);</span><br><span class="line">        &#125;)();</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>将<code>b</code>函数改写成立即执行函数更加清晰紧凑了，相当于函数里面将一个执行的函数返回到外部去<br>就好像在函数内外构建了一个桥梁。<br><strong>闭包有闭包的好处，但是它也有不少缺陷</strong><br>闭包会携带包含它的函数的作用域，因此比其他函数占用更多的内存，过度的使用闭包可能会导致内存占用过多<br><strong>闭包的限制与解除</strong>，闭包只能取得包含函数中的任何变量的最后一个值，闭包保存的是整个变量对象，而不是某个特殊的变量<br>下面我们来看看代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        arr[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">alert(foo());</span><br></pre></td></tr></table></figure></p>
<p>谈到闭包的缺点，必须要说的一个东西就是 Js 的垃圾回收机制，下篇博客，我将重点研究关于 JS 的垃圾回收机制，</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2015/11/27/t-book_js_002/">
        《JavaScript高级程序设计》读后记&lt;二&gt;：作用域
      </a>
    </h2>
    
    <time>
      Nov 27, 2015
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <p>在第一篇博客里面，提到过变量是松散变量，决定它只是特定时间保持特定的值的符号而已，而变量的值和数据类型可以在脚本的生命周期内改变的。接下来就是理解这种特性的性质了。</p>
<h3 id="理解引用类型，作用域"><a href="#理解引用类型，作用域" class="headerlink" title="理解引用类型，作用域"></a>理解引用类型，作用域</h3><p>前面我们已经知道了，ES 变量类型包括 5 种基本类型和引用类型。</p>
<p><strong>基本类型与引用类型的区别？</strong></p>
<ul>
<li>基本类型值在内存中占据固定大小的空间，保存在栈中，引用类型的值是对象，被保存在堆中</li>
<li>这 5 种基本类型可以按值访问的，而引用类型的值是按引用访问</li>
<li>基本类型的变量包含的是实际的值，引用对象实际包含的并不是对象本身而是指向对象的指针。</li>
</ul>
<p><strong>这里要解释一下什么是按值访问？什么是按引用访问？</strong><br>如果学过 C++ ,我们就会知道 C++ 传参有两种方式，一种是传值，一种是传引用。</p>
<p><strong>这两种方式有什么区别呢？</strong><br>区别在于传值是将实参拷贝给形参，而传引用并不是简单的赋值，而是将形参与实参绑定在一起，它们同时指向同一内存空间，修改形参相当于修改实参。<strong>引用相当于变量的别名</strong>，理解这句话。<br>我们可能大致知道什么是按值访问，什么是按引用访问了</p>
<p><strong>那么，为什么基本类型是按值访问？而引用类型是按引用访问？</strong><br>我们知道引用类型不同于基本类型，它不是单纯的值，而是一种数据结构，包含有属性和方法。<br>如果按值传递，会拷贝整个对象，这样消耗的空间是否太大了呢，所以<code>ES</code>将这些对象的访问都设置成了按引用访问。</p>
<p><strong>刚才我们提到了，<code>c++</code>的值拷贝方式和引用拷贝方式，<code>JS</code>是否也是这样的呢？</strong><br>的确，<code>JS</code>也是这样的，下面简单的验证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型的拷贝</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(a+<span class="string">','</span>+b); <span class="comment">// hello,hello</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用类型的拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Objcet();</span><br><span class="line"><span class="keyword">var</span> obj1 = obj2;</span><br><span class="line">obj.name = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name+<span class="string">','</span>+obj1.name); <span class="comment">// hello,hello</span></span><br></pre></td></tr></table></figure>
<p>因此我们可以看到，对象<code>obj1</code>是随<code>obj</code>变化的，他们是指向同一个内存块的，而不是简单的拷贝而已</p>
<p><strong>那么传参是否也是在我们的意料之中呢？</strong><br>然而并不是这样的，ES 中所有函数的参数都是按值传递的，基本类型值的传递就像复制一样<br>而引用类型的值的传递，就行引用类型的变量复制一样，为什么会这样呢？<br>这里我们重点看一下传递引用参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">"suo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);   <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>由上可知，对象传递后，通过函数修改对象属性影响了全局变量的值<br>在这里有人可能会觉得，函数传的是引用并非是值吧<br>其实 ES 中所有的函数都是按值传递，并非引用传递，有人肯定会有疑问为什么<code>obj</code>会被改变呢<br>其实这里说的按值传递有点特殊，这个值恰好是指向内存的指针，与引用传递的不同在于，并没有，形参并没有和实参进行引用绑定<br>接下来进一步验证一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">"suo"</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>;   </span><br><span class="line">    obj.name = <span class="string">"yue"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);   <span class="comment">// suo</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码的意义是什么呢？我们在函数内重新定义了这个对象，并给了它一个属性<br>而执行后，结果<code>person</code>并没有和<code>obj</code>的属性一样，也就是说<code>obj</code>并不是<code>person</code>的引用，仅仅是它的地址的值等于<code>person</code>的地址而已</p>
<p>我们已经知道了<code>ES</code>有引用类型和基本类型，而且<code>typeof</code>操作符可以检测基本类型的类型<br><strong>那么我们怎样检测引用类型呢？</strong>其实也有个操作符可以利用，不过它只能判断是或者不是，不能直接得出是什么类型<br>下面我们测试一下几个引用类型检测<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure></p>
<p>刚刚看到了，函数通过传值的形式来传参<br><strong>现在思考一下，函数是怎么执行的呢？</strong><br>原来每个函数都有执行环境，每个执行环境都有与之对应的变量对象，环境中所有的对象和函数都保存在这个对象中。<br>代码在一个环境中执行时，会创建变量对象的作用域链，作用域链控制执行环境访问变量和函数的顺序和权限。<br>下面先看一段代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (color === <span class="string">"red"</span>)</span><br><span class="line">        color = <span class="string">"yellow"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        color = <span class="string">"green"</span>;</span><br><span class="line">&#125;</span><br><span class="line">changeColor();</span><br><span class="line"><span class="built_in">console</span>.log(color); <span class="comment">// yellow</span></span><br></pre></td></tr></table></figure></p>
<p>可知，函数执行时可以访问到外部的变量，这里的作用域包括两个对象：自己的对象，全局环境的对象<br><strong>进一步研究，多层函数套用，执行是怎样的呢？</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor; <span class="comment">// 都能访问</span></span><br><span class="line">    &#125; <span class="comment">// 只能访问color,anothor</span></span><br><span class="line">    swapColor();</span><br><span class="line">&#125; <span class="comment">// 只能访问color</span></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure></p>
<p>可以看出作用域链是由内而外的，也就是说函数是从当前的环境对象向外搜索变量，直至到全局对象。函数可以访问外部的变量，但是无法访问当前环境下函数里的局部变量。<br>用更确切的话说，<strong>ES 的作用域链是单向的，而这个方向是由里向外的访问原则</strong>。<br>下面画一个图式来说明这个问题<br><img src="/images/dm2.png" alt="img"><br>现在问题来了，既然作用域是单向访问，有没有办法访问到由外访问到里面的局部变量呢？<br>答案是有的，下节谈一下闭包，这个特性能很好的解决这个问题。<br>还有一点要说明的是,<strong>JS 没有块级作用域</strong>，不同域 c 语言，花括号括起来的都有作用域，<strong>JS 只有函数作用域</strong><br>下面用代码解释下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a=<span class="number">0</span>; a&lt;<span class="number">10</span>; a++) &#123;</span><br><span class="line">        b++; <span class="comment">// 出错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d"</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error: 'b' was not declared in this scope,b++;</span></span><br><span class="line"><span class="comment">// error: 'a' was not declared in this scope</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> a=<span class="number">0</span>; a&lt;<span class="number">10</span>; a++) &#123;</span><br><span class="line">    b++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a+<span class="string">','</span>+b);</span><br><span class="line"><span class="comment">// 10,10</span></span><br></pre></td></tr></table></figure>
<p>根据上面的运行结果，我们很容易看到 C 中花括号的是单独的作用域，其他作用域是访问不到的，<code>for</code>循环里的变量，循环结束后，也不会保留<br>而 JS 里的不一样，他们虽然有花括号，但是这个花括号如同形式一般，没特别的意义，与去掉花括号是同样的意义。 JS 是通过函数作用域，来实现作用域链，控制访问顺序和权限。所有它的最小执行的单元就是函数。</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2015/11/27/t-book_js_001/">
        《JavaScript高级程序设计》读后记&lt;一&gt;：数据类型
      </a>
    </h2>
    
    <time>
      Nov 27, 2015
    </time>
		
    
    <div class='cats'>
        <a href="/categories/JavaScript/">JavaScript</a>
    </div>

  </section>
  <section class="article typo">
	  <p>经过一段时间的学习，深感 JavaScript 知识点还是挺多。之前一直是看视频教程和博客学习 JavaScript 。但是总觉得缺点什么，不管是视频还是博客，它们强调的始终是单一的知识或者是技术点。并没有对整个语言有一个更加全面的概述。基于这些学习上的不足，我向师哥师姐们询问到了这方面的问题，于是乎他们向我推荐了这本书，《JavaScript高级程序设计》第三版。无奈由于时间原因，一直放在书桌上搁置了好一段时间。就在近几天我终于有机会专心看这本书了。经过一个星期的学习，感觉大有收获，所以写下这篇博客，记录学习中的偏向于重点知识的理解和体会。</p>
<h3 id="理解变量与数据类型"><a href="#理解变量与数据类型" class="headerlink" title="理解变量与数据类型"></a>理解变量与数据类型</h3><p><strong>1.ES的变量是松散变量</strong>，也就是说每一个变量仅仅是用于保存一个值的占位符，它可以保存任何值。变量未声明或未初始化之前的值是<code>undefined</code>,定义之后的值是赋给它的任何值。到这里就一个小疑问，通常我们学习其他语言都会有，一个值和类型相对应，那么问题来了，<code>undefind</code>是值那么它的类型又是啥呢？做个简单的例子测试一下看看<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a; </span><br><span class="line">alert(a); <span class="comment">// undefined</span></span><br><span class="line">alert(<span class="keyword">typeof</span> a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>原来值为<code>undefined</code>的类型也是<code>undefined</code>。<br>由此我们可能会想到另外一个值，那就是<code>null</code>,是不是<code>nUll</code>的类型也是<code>null</code>呢？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>; <span class="comment">// null</span></span><br><span class="line">alert(a); <span class="comment">// object</span></span><br><span class="line">alert(<span class="keyword">typeof</span> a);</span><br></pre></td></tr></table></figure></p>
<p><code>null</code>的类型竟然是<code>object</code>，估计有不少人会大跌眼镜吧，为啥会这样？凭什么？<br>其实这是正确的，<code>JavaScript</code>的<code>null</code>被认为是空对象的引用<br>这里还要解释下什么是空对象的引用？简单的说就是一个变量本该保存一个对象，但是还没有保存对象，这个时候就应该把这个变量来保存<code>null</code>，显示的表示这个变量是一个空对象的变量。</p>
<p><strong>2.<code>undefined</code>和<code>null</code>又有哪些区别和联系呢？</strong><br>首先说联系<code>undefined</code>其实是<code>null</code>派生出来的，在代码层上表现为<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="literal">undefined</span> == <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line">alert(<span class="literal">undefined</span> === <span class="literal">null</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>第<code>2</code>个为<code>false</code>好说，至少是他们类型是不一致的。第一个为什么为<code>true</code>呢？<br>原来这个<code>==</code>符是类似相等符，不是绝对相等，<code>null</code>和u<code>ndefined</code>的值是类似的。<br>区别上面也很容易看出来</p>
<ul>
<li>用途不一致：<code>null</code>用于空对象指针，给还没对象的变量赋值。<code>undefined</code>是来区别变量的未初始化或声明的。</li>
<li>常用于：<code>null</code>常用与显示的赋值变量，<code>undefined</code>不会这么做.</li>
</ul>
<p><strong>3.基本类型</strong><br>ES 中有 5 种简单数据类型和一种复杂数据类型，分别为<code>undefined</code>，<code>null</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>object</code>。其中<code>object</code>实质是一组无序名值对组成的。<br>具体理解的是<code>object</code>这一类型。通过执行<code>new</code>来创建对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>; <span class="comment">// 都可以</span></span><br></pre></td></tr></table></figure></p>
<p><code>object</code>的每一个实例下面都有属性和方法</p>
<ul>
<li><code>constructor</code>:创建当前对象的函数，对于上面就是<code>Object()</code>这个构造函数</li>
<li><code>hasOwnProperty(propertyName)</code>:检查属性在当前对象中是否存在</li>
<li><code>isProtptypeOf(object)</code>:检查属性是否是当前对象原型</li>
<li><code>propertIsEnumerable(propertypeName)</code>:检查对象是否可以用<code>for-in</code>来枚举</li>
<li><code>toLocaleString()</code>:返回对象字符串表示，与执行环境对应</li>
<li><code>toString()</code>:返回对象字符串表示</li>
<li><code>valueOf()</code>:返回对象的字符串，数值，布尔值表示<br>要具体理解这些函数和属性，需要后面面向对象的思想做铺垫。<br>ES 中 Object 是所有对象的基础。因此所有对象都具有这些基本的属性和方法。</li>
</ul>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/JavaScript/">JavaScript</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
</section>


  <nav id="page-nav">
    
    <a class="prev" rel="prev" href="/tags/JavaScript/">
      <span class="icon icon-chevron-left"></span>
      <span class="text">Previous</span>
    </a>
    
    
  </nav>
  

      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<div class='header'>suoyue</div>
<div class='content'>
<div class='desc'>Tempora mutantur, nos et mutamur in illis ...</div>
</div>
</section>

  <section class='m_widget links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="https://ccoooss.com">
            <div class='name'>ClassicOldSong</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://frantic1048.logdown.com/">
            <div class='name'>Frantic1048</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://hclmaster.github.io/">
            <div class='name'>Hclmaster</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://whst.github.io/">
            <div class='name'>WANG Hsü-Tung</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/C/"><div class='name'>C</div><div class='badget'>6</div></a></li>
    
        <li><a class="flat-box" href="/categories/CSS/"><div class='name'>CSS</div><div class='badget'>4</div></a></li>
    
        <li><a class="flat-box" href="/categories/HTML/"><div class='name'>HTML</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/JavaScript/"><div class='name'>JavaScript</div><div class='badget'>14</div></a></li>
    
        <li><a class="flat-box" href="/categories/vue/"><div class='name'>vue</div><div class='badget'>2</div></a></li>
    
        <li><a class="flat-box" href="/categories/web开发/"><div class='name'>web开发</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/前端工具/"><div class='name'>前端工具</div><div class='badget'>4</div></a></li>
    
        <li><a class="flat-box" href="/categories/算法/"><div class='name'>算法</div><div class='badget'>2</div></a></li>
    
        <li><a class="flat-box" href="/categories/编程基础/"><div class='name'>编程基础</div><div class='badget'>10</div></a></li>
    
        <li><a class="flat-box" href="/categories/通用工具/"><div class='name'>通用工具</div><div class='badget'>4</div></a></li>
    
    </ul>
    
</div>
</section>

  
<div class="m_widget tagcloud">
    <div class="header">Tags</div>
    <div class='content'>
        <a href="/tags/C/" style="font-size: 17.6px; color: #333">C</a> <a href="/tags/CSS/" style="font-size: 16.4px; color: #4d4d4d">CSS</a> <a href="/tags/ECMAScript6/" style="font-size: 15.2px; color: #666">ECMAScript6</a> <a href="/tags/HTML/" style="font-size: 14px; color: #808080">HTML</a> <a href="/tags/HTML5/" style="font-size: 14px; color: #808080">HTML5</a> <a href="/tags/JavaScript/" style="font-size: 20px; color: #000">JavaScript</a> <a href="/tags/OOP/" style="font-size: 15.2px; color: #666">OOP</a> <a href="/tags/css/" style="font-size: 14px; color: #808080">css</a> <a href="/tags/git/" style="font-size: 14px; color: #808080">git</a> <a href="/tags/gulp/" style="font-size: 14px; color: #808080">gulp</a> <a href="/tags/jQuery/" style="font-size: 14px; color: #808080">jQuery</a> <a href="/tags/php/" style="font-size: 14px; color: #808080">php</a> <a href="/tags/sass/" style="font-size: 14px; color: #808080">sass</a> <a href="/tags/webpack/" style="font-size: 14px; color: #808080">webpack</a> <a href="/tags/垂直居中/" style="font-size: 14px; color: #808080">垂直居中</a> <a href="/tags/数据结构/" style="font-size: 18.8px; color: #1a1a1a">数据结构</a> <a href="/tags/框架/" style="font-size: 15.2px; color: #666">框架</a> <a href="/tags/测试/" style="font-size: 14px; color: #808080">测试</a> <a href="/tags/生活杂感/" style="font-size: 14px; color: #808080">生活杂感</a> <a href="/tags/盒子模型/" style="font-size: 14px; color: #808080">盒子模型</a> <a href="/tags/算法/" style="font-size: 15.2px; color: #666">算法</a> <a href="/tags/编辑器/" style="font-size: 15.2px; color: #666">编辑器</a> <a href="/tags/自动化工具/" style="font-size: 14px; color: #808080">自动化工具</a> <a href="/tags/设计模式/" style="font-size: 14px; color: #808080">设计模式</a>
    </div>
</div>



      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/stkevintan" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/kevinsfork" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  
  <div>Theme <a href='https://github.com/stkevintan/hexo-theme-material-flow' class="codename">MaterialFlow</a> designed by <a href="http://keyin.me/" target="_blank">Kevin Tan</a>.</div>
  
</footer>


  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<script src="/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
