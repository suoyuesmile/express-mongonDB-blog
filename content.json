{"meta":{"title":"锁越smile","subtitle":"邵锁的博客","description":"保持乐观，保持谦虚","author":"suoyue","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2018-12-23T16:11:10.596Z","updated":"2017-10-07T02:01:17.000Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 - arao'blog"},{"title":"关于博主","date":"2017-10-13T02:01:23.000Z","updated":"2017-11-04T12:24:13.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一枚小小前端工程狗博客问题请联系： qq: 2742604267 weixin: suoyue201314 email: suosmile@163.com 传送门： github 新浪微博 个人小站 ps: 本博主在寻觅合适的工作中，欢迎大佬来推荐工作。"},{"title":"分类云","date":"2017-10-03T08:19:16.000Z","updated":"2017-10-13T01:41:55.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签云","date":"2017-10-03T08:18:58.000Z","updated":"2017-10-13T01:41:43.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"t-note_vue_004","date":"2019-02-26T02:20:55.220Z","updated":"2019-02-26T03:12:41.137Z","comments":true,"path":"2019/02/26/t-note_vue_004/","link":"","permalink":"http://yoursite.com/2019/02/26/t-note_vue_004/","excerpt":"","text":"title: 再探 vue 框架：&lt;上篇&gt;date: 2018-01-05 16:33:33categories: vuetags: [JavaScript, 框架] 再探 vue 框架： &lt;下篇&gt;服务器渲染结合 TypeScript 使用vue 开发感想后续研究读源码相关收获React 相关","categories":[],"tags":[]},{"title":"","slug":"t","date":"2019-02-26T02:09:01.886Z","updated":"2019-02-26T02:09:10.697Z","comments":true,"path":"2019/02/26/t/","link":"","permalink":"http://yoursite.com/2019/02/26/t/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"各大编辑器快捷键收集","slug":"t-note_kj_001","date":"2018-01-17T14:34:22.000Z","updated":"2018-06-30T16:32:58.900Z","comments":true,"path":"2018/01/17/t-note_kj_001/","link":"","permalink":"http://yoursite.com/2018/01/17/t-note_kj_001/","excerpt":"","text":"Sublime text [转载] Mac版 12345678910111213141516171819202122232425262728293031323334353637383940作者：77plus链接：https://www.zhihu.com/question/39190896/answer/264524567cmd+n 新建页面cmd+数字键 切换到对应页面cmd+p 搜索跳转到对应页cmd+w 关闭页面cmd+j 合并一行cmd+d 选中当前单词，继续敲可以选中多个cmd+l 选中当前行cmd+z 撤销cmd+c 复制cmd+v 粘贴cmd+s 保存cmd+x 删除当前行cmd+delete 删除光标定位到当前行起始的一块cmd+]缩进当前行，[回缩当前行，对应tab/shift+tab功能cmd+enter 向下开辟一行cmd+shift+enter 向上开辟一行cmd+f 查询内容cmd+shift+f 全局查询，可替换cmd+g 查询到的内容下一个cmd+鼠标右键 多点编辑cmd+~ 调出控制台cmd+k then u 大写cmd+k then l 小写cmd+shift+p 调出命令面板cmd+⬅️ 光标定位到当前行最前 +shift 选中cmd+➡️ 光标定位到当前行最后 +shift 选中cmd+⬇️ 光标定位到当前页最后 +shift 选中cmd+⬆️ 光标定位到当前页最前 +shift 选中ctrl+g 跳转到对应行号ctrl+tab 切换到下一个页面ctrl+shift+tab 切换到上一个页面ctrl+delete 删除光标定位到当前单词起始的一块opt+鼠标左键 纵向选择编辑opt+⬅️ 光标定位到当前块最前 +shift 选中opt+➡️ 光标定位到当前块最后 +shift 选中 Vim","categories":[{"name":"通用工具","slug":"通用工具","permalink":"http://yoursite.com/categories/通用工具/"}],"tags":[{"name":"编辑器","slug":"编辑器","permalink":"http://yoursite.com/tags/编辑器/"}]},{"title":"各大编辑器快捷键收集","slug":"t-note_tools_001","date":"2018-01-17T14:34:22.000Z","updated":"2018-01-17T02:11:34.950Z","comments":true,"path":"2018/01/17/t-note_tools_001/","link":"","permalink":"http://yoursite.com/2018/01/17/t-note_tools_001/","excerpt":"","text":"Sublime text [转载] Mac版 12345678910111213141516171819202122232425262728293031323334353637383940作者：77plus链接：https://www.zhihu.com/question/39190896/answer/264524567cmd+n 新建页面cmd+数字键 切换到对应页面cmd+p 搜索跳转到对应页cmd+w 关闭页面cmd+j 合并一行cmd+d 选中当前单词，继续敲可以选中多个cmd+l 选中当前行cmd+z 撤销cmd+c 复制cmd+v 粘贴cmd+s 保存cmd+x 删除当前行cmd+delete 删除光标定位到当前行起始的一块cmd+]缩进当前行，[回缩当前行，对应tab/shift+tab功能cmd+enter 向下开辟一行cmd+shift+enter 向上开辟一行cmd+f 查询内容cmd+shift+f 全局查询，可替换cmd+g 查询到的内容下一个cmd+鼠标右键 多点编辑cmd+~ 调出控制台cmd+k then u 大写cmd+k then l 小写cmd+shift+p 调出命令面板cmd+⬅️ 光标定位到当前行最前 +shift 选中cmd+➡️ 光标定位到当前行最后 +shift 选中cmd+⬇️ 光标定位到当前页最后 +shift 选中cmd+⬆️ 光标定位到当前页最前 +shift 选中ctrl+g 跳转到对应行号ctrl+tab 切换到下一个页面ctrl+shift+tab 切换到上一个页面ctrl+delete 删除光标定位到当前单词起始的一块opt+鼠标左键 纵向选择编辑opt+⬅️ 光标定位到当前块最前 +shift 选中opt+➡️ 光标定位到当前块最后 +shift 选中 Vim","categories":[{"name":"通用工具","slug":"通用工具","permalink":"http://yoursite.com/categories/通用工具/"}],"tags":[{"name":"编辑器","slug":"编辑器","permalink":"http://yoursite.com/tags/编辑器/"}]},{"title":"持续集成工具 CI 使用","slug":"t-note_ci_001","date":"2018-01-09T04:22:23.000Z","updated":"2018-01-16T10:32:14.390Z","comments":true,"path":"2018/01/09/t-note_ci_001/","link":"","permalink":"http://yoursite.com/2018/01/09/t-note_ci_001/","excerpt":"","text":"","categories":[{"name":"通用工具","slug":"通用工具","permalink":"http://yoursite.com/categories/通用工具/"}],"tags":[{"name":"自动化工具","slug":"自动化工具","permalink":"http://yoursite.com/tags/自动化工具/"}]},{"title":"git熟练运用","slug":"t-note_git_001","date":"2017-12-23T12:33:23.000Z","updated":"2018-01-17T06:10:59.010Z","comments":true,"path":"2017/12/23/t-note_git_001/","link":"","permalink":"http://yoursite.com/2017/12/23/t-note_git_001/","excerpt":"","text":"git与gitflow使用自从接触 git 来一直用一些简单的命令，但是最近工作经常遇到一些 git 的这种那种麻烦冲突，所以决定一定要熟练使用，先列出一个清单，然后多记多用，直到熟练为止 新建1234# 新建本地 git 仓库git init [repoName]# 克隆远程仓库git clone [repoUrl] 配置12345678# 查看配置内容git config --list# 编辑配置文件git config -e# 配置姓名git config [--global] user.name \"suoyue\"# 配置邮箱 git config [--glabal] .user.email \"email\" 分解平时我们 工作区(workspace):平时编写代码的地方,本地的文件 暂存区(stash):我们在提交到本地仓库前的一个暂存处 本地仓库(repo)：提交后的本地仓库 远程仓库(remote)：远端的一个代码托管的仓库 状态 未跟踪(untracked) 未修改(ummodified) 已修改(modified) 已暂存(stashed) 添加、删除1234567891011121314# 添加工作区改变的到暂存区git add [file1] [file2]# 编辑工作区与本地不同的地方git add -e# 添加所有修改或者删除的文件git add -u# 添加变动的文件到暂存区git add -A# 移除暂存区文件git rm [file1] [file2]# 停止追踪某个文件git rm --cached [file1] [file2]# 改名git mv [oriFile] [distFile] 提交12345678910# 提交暂存区的文件到仓库git commit -m \"test commit\"git commit [file1] [file2] -m \"test commit\"# 全部直接提交git commit -a# 显示diffgit commit -v# 替代上次提交git commit -ament -m \"replace commit last\"git commit -ament [file1] [file2] -m \"replace commit last\" 回滚12345678910111213141516# 使用checkout # 恢复暂存区文件到工作区 stash --&gt; work （撤销暂存）git checkout [file]git checkout# 恢复某个commit到暂存区和工作区git checkout [commit] [file]# 重置暂存区到仓库 stash --&gt; repogit reset [file]git reset [commit]# 回滚commit stash &amp; work --&gt; repo (回滚提交)git reset --hard #上一次git reset --hard [commit] #指定# 回滚commit 但是工作区和暂存区不变git reset --keep [commit] #指定# 新建commit 回滚应用当前分支git revert [commit] 忽略1234567# 编辑 git 忽略配置文件vim .gitignore# 被写 git 忽略文件, git add 会自动忽略它# .gitignore 自动忽略log文件和文件名为suo结尾的文件*.log*suo 分支1234567891011121314151617181920212223# 查看本地分支git branch# 查看远程的分支git branch -vgit# 查看已跟踪到远程和本地所有分支git branch -a# 新建一个分支名为ss的分支（不切换）git branch ss# 新建一个分支名为test的分支并切换过去git checkout -b test# 切换分支并更新工作区git checkout ss# 合并分支到当前git merge test# 如果有冲突手动改代码在添加提交# 删除不用分支git checkout -d test -m# 新建远程分支git push origin ss:ss# 删除远程分支git push origin --delete ss# 建立远程追踪关系git branch --set-upstream-to=origin/ss test 远程1234567891011121314# 下载远程变动git fetch xx # 显示远程分支git remote -v# 显示远程仓库信息git remote show xx# 增加远程仓库git remote add xx[name] xx[url]# 拉取远程变化,合并本地git pull xx[remote] xx[b]# 推送本地到远程仓库git push xx[remote] xx[b]# 强推，全推git push xx[remote] --force/--all 日志123456789101112131415# 显示变更文件git status# 当前分支版本信息git loggit refloggit log --follow [file]git whatchanged [file] # 追踪文件修改git log -p [file] # 文件相关diffgit blame [file] # 追责# 比较git diff # 暂存区与工作区git diff --cached [file] # 暂存区与上一个commitgit diff HEAD # 工作区与最新commitgit show [commit] # commit的内容变化git show [commit] [file] 场景 拉取远程合并本地（切换分支-&gt;拉取-&gt;修改-&gt;提交-&gt;推送） 123456789git commit -am 'xx' [提交] [or] git stash [暂存]git checkout xx [切换分支]git status [查看状态]git pull [拉取远程并合并]git log [查看历史]git diff [对比]git status [查看忽略文件]git commit -am 'xx' [提交修改]git push [推到远程] 本地修复issue分支 (切换并新建分支-&gt;修改-&gt;提交-&gt;切回-&gt;合并-&gt;删除临时分支) 1234567git checkout -b new-issue [切换新分支]git status [重要]git diff [对比]git commit -am \"xx\"git checkout ss [切换]git merge new-issue [合并分支]git checkout -d new-issue [删除分支]","categories":[{"name":"通用工具","slug":"通用工具","permalink":"http://yoursite.com/categories/通用工具/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"一周上手 vue 框架：<下篇>","slug":"t-note_vue_002","date":"2017-12-13T12:33:23.000Z","updated":"2017-12-13T01:39:58.940Z","comments":true,"path":"2017/12/13/t-note_vue_002/","link":"","permalink":"http://yoursite.com/2017/12/13/t-note_vue_002/","excerpt":"","text":"动画1.单组件过渡2.初始渲染过渡3.多组件过渡4.列表过渡5.可复用过渡6.动态过渡7.状态过渡 混合混合mixins 分发vue组件中可复用功能的非常灵活的方式，混合对象可以包含任意组件选项12345678910111213141516myMinxi = &#123; created: function() &#123; this.hello() &#125;, methods: &#123; hello: function() &#123; console.log('hello from mixin!') &#125; &#125;&#125;var Component = Vue.extend(&#123; mixins: [myMixin]&#125;)var component = new Component() 1.选项合并组件和混合对象含有同名选项时，这些选项以恰当的方式混合12345678910111213var mixin = &#123; created: function () &#123; console.log('混合对象的钩子被调用') &#125;&#125;new Vue(&#123; mixins: [mixin], created: function () &#123; console.log('组件的钩子被调用') &#125;&#125;)// 注意，命名冲突取组件对象的键值对 2.全局混合全局注册混合对象，一旦使用全局混合对象，将会影响到所有之后创建的vue 实例。1234567891011Vue.mixin(&#123; created: function() &#123; var myOption = this.$option.myOption if (myOption) &#123; console.log(myOption) &#125; &#125;&#125;)new Vue(&#123; myOption: 'hello'&#125;) 3.自定义选项合并(省) 插件1.开发插件全局插件 添加全局方法或者属性 添加全局资源 通过全局 mixin 方法，添加一些组件选项 添加 Vue 实例方法，通过把他们添加到 Vue.prototype 上实现 一个库，提供自己的API，同时提供提到的一个或者多个功能方法12345678myPlugin.install = function (Vue, options) &#123; Vue.myGlobalMethod = function() &#123; //... &#125; Vue.directive('my-directive', &#123; bind(el, binding, vnode, oldVnode) &#125;)&#125; 2.使用插件通过全局方法使用插件1234Vue.use(MyPlugin)// Vue.use(MyPlugin, &#123; someOption: true &#125;)// 自动阻止多次注册相同插件，只会注册一次 12345// 用 Browserify 或者 webpack 提供的commonJS模块环境时var Vue = require('vue')var VueRouter = require('vue-router')Vue.use(VueRouter) 过滤用于常见的文本格式化，过滤用在两个地方：双花括号插值和v-bind表达式12&#123;&#123; msg | capitalize &#125;&#125;&lt;div v-bind:id=\"rawId|formatId\"&gt;&lt;/div&gt; 路由单页应用非常简单，增加路由后，要将组件映射到路由，然后告诉vue-router在哪里渲染他们123456789101112&lt;div id=\"app\"&gt; &lt;h1&gt;hello App&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航 --&gt; &lt;!-- 通过传人 `to` 属性指定链接 --&gt; &lt;router-link to=\"/foo\"&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=\"/bar\"&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 12345678910111213141516171819// 1.定义组件const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125;// 2.定义路由const routers = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;]// 3.创建 router 实例，然后 `routers` 配置const router = new VueRouter(&#123; routes&#125;)// 4.创建和挂载根实例const app = new Vue(&#123; router&#125;).$mount('#app') 状态部署测试","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"框架","slug":"框架","permalink":"http://yoursite.com/tags/框架/"}]},{"title":"一周上手 vue 框架：<上篇>","slug":"t-note_vue_001","date":"2017-12-12T12:33:23.000Z","updated":"2018-01-17T06:53:47.500Z","comments":true,"path":"2017/12/12/t-note_vue_001/","link":"","permalink":"http://yoursite.com/2017/12/12/t-note_vue_001/","excerpt":"","text":"接触 vue 时间并不长，之前一直用的 react，也很想学习一下 Vue，但是没有什么机会去接触。刚入职不久，公司用的 Vue，用了3-5天的时间学习了下 Vue 的官方教程。知识点还挺多的，现在重新梳理一遍，以备后续查看。 一周内 Vue 框架快速上手首先列一个计划，打算一个星期能上手 Vue 的中型项目，任务还有点重，给自己加下油。 计划表 时间 任务 周一 学习官方教程 周二 vue-demo 周三 vue-todo-list 周四 vue-exam-system 周五 vue-elma-admin 周六 总结 周日 整理 基础准备 HTML 基本标签语法(掌握） CSS 基本语法(掌握） JavaScript ES5以上的语法（掌握) Jslint (掌握） 前端组件化(了解) 前端工程化 webpack(掌握) UMD 模块标准(掌握) Sass css编程式写法 npm 命令基本使用 官方教程知识点汇总环境 直接引入 vue.js 文件新手入门先用引入的js文件来做一些 demo，再过渡到大型的单文件的环境中去 1234&lt;!-- 在线引入 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt;&lt;!-- 本地引入 这个js文件需要到官方网站里面下载，有压缩版的，和非压缩的--&gt;&lt;script src=\"vue.js\"&gt;&lt;/script&gt; 构建工具环境之后学习完路由之后才能理解里面的构建形式 12345678# 全局安装vue-clinpm install --global vue-cli# 创建一个webpack 模版的新项目vue init webpack my-project# 安装依赖cd my-projectnpm installnpm run dev 模板1.插值简单的理解就是，我们现在在 html 里面增加我们的模版的语法，框架后期会帮我编译成原生的 html插入的值的部分就是我们页面中动态的部分，也就是可以变化的。不仅可以插入变量，还可以插入 js 的值表达式，甚至动态的属性12345678&lt;!-- 插文本 --&gt;&lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;!-- 插HTML --&gt;&lt;p v-html=\"rawHtml\"&gt; &lt;/p&gt;&lt;!-- 插特性 --&gt;&lt;div v-bind:id=\"dynamicId\"&gt;suo&lt;/div&gt;&lt;!-- 插js --&gt;&lt;p&gt;&#123;&#123; number + 1 &#125;&#125;&lt;/p&gt; 2.指令（directives）这些带有 v- 前缀的属性就是我们所说的指令。作用是响应式的作用于 dom，也就是让我们可以通过我们插值的变化来改变 dom (1)常用指令汇总 指令 作用 v-model 表单输入绑定 v-html 插入原生html v-bind 对属性绑定值 v-on 对组件绑定事件 v-if 分支判断功能 v-show 切换CSS的display v-for 循环迭代功能 (2)指令的参数每个指令有不同的功能，而每个功能有不同的小功能，所以可以使用参数来，缩小功能的范围，比如1234567&lt;!-- v-bind:参数 --&gt;&lt;!-- 给href绑定一个动态的URL --&gt;&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;!-- v-on:参数 --&gt;&lt;!-- 添加一个点击事件行为 --&gt;&lt;a href=\"\" v-on:click=\"action\" &gt;&lt;/a&gt; (3)指令的修饰符这个是来说明以什么样的方式来绑定12&lt;!-- 告诉v-on指令对于触发的事件调用event.preventDefault --&gt;&lt;form action=\"\" v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt; 3.缩写 v-on 缩写成@ v-bind 缩写成： 实例我们写好了模版，现在要使用 js 来操作这个模版，Vue 已经封装好了一个操作的方法，我们之间实例化就好了1234&lt;div id=\"example\"&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; reversedMsg &#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334new Vue(&#123; // 选择结点 el: '#example', // 数据 data: &#123; msg: 'suo' &#125;, // 计算方法 computed: &#123; reversedMsg: function() &#123; return this.msg.split('').reversedMsg().join('') &#125;, fullname: &#123; get: function() &#123; &#125;, set: function() &#123; &#125; &#125; &#125;, // 通用方法 methods: &#123; &#125;, // 侦听方法 watch: &#123; &#125;, // 组件列表 components: &#123; &#125;&#125;) 渲染1.属性绑定 v-bind(1)Class动态的操作 class, 可以与普通 class共存1&lt;div :class=\"&#123; active: isActive, 'text-danger': hasError&#125;\" class=\"static\"&gt;&lt;/div&gt; 1234567new Vue(&#123; el: '#example', date: &#123; isActive: true, hasError: false &#125;&#125;) (2)Style动态绑定内联样式1&lt;div :style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;&lt;/div&gt; 1234data: &#123; activeColor: 'red', fontSize: 30&#125; 2.条件渲染 v-if 与 v-show简单的判断指令的使用12&lt;h1 v-if=\"name\"&gt;suo&lt;/h1&gt;&lt;h1 v-else&gt;yue&lt;/h1&gt; 使用一组元素123456&lt;template v-if=\"ok\"&gt; &lt;header&gt; &lt;h1&gt;what's app?&lt;/h1&gt; &lt;p&gt;author: shaosuo&lt;/p&gt; &lt;/header&gt;&lt;/template&gt; 新增多分支的判断1234&lt;div v-if=\"type === 'A\"&gt;A&lt;/div&gt;&lt;div v-else-if=\"type === 'B\"&gt;B&lt;/div&gt;&lt;div v-else-if=\"type === 'C\"&gt;C&lt;/div&gt;&lt;div v-else&gt;Not A/B/C&lt;/div&gt; 使用 v-show 来控制显示 3.列表渲染 v-for使用 v-for 指令来循环，减少代码的冗余，每个列表都是一样的，尽量绑定一个id来识别选项123456&lt;!-- 模板中使用 v-for，items 数组中，迭代每一项 --&gt;&lt;lu id=\"example\"&gt; &lt;li v-for=\"item in items\" :key=\"item.id\"&gt; &#123;&#123; item.msg &#125;&#125; &lt;/li&gt;&lt;/lu&gt; 1234567891011// 只要在 data 中写好数组 item 中的值，模板中就会自动添加进去new Vue(&#123; el: '#example', data: &#123; items: [ &#123; msg: 'wo', id: 1 &#125;, &#123; msg: 'shi', id: 2 &#125;, &#123; msg: 'suo', id: 3&#125; ] &#125;&#125;) 4.事件处理 v-on使用 v-on 给组件绑定事件,可以直接用表达式，但是更多的是，写在js的方法里12345&lt;div id=\"example\"&gt; &lt;button @click=\"counter += 1\"&gt;Add 1&lt;/button&gt; &lt;button @click=\"hello\"&gt;hello&lt;/button&gt; &lt;p&gt;&#123;&#123;counter&#125;&#125;times.&lt;/p&gt;&lt;/div&gt; 1234567891011new Vue(&#123; el: '#example', data: &#123; greet: '你好啊' &#125;, methods: &#123; hello: function() &#123; alert(this.greet) &#125; &#125;&#125;) 监听鼠标时，经常会有一些模式，决定事件的触发形式，下面是鼠标修饰符汇总 修饰符 作用 stop 阻止单击事件继续传播 prevent 提交事件不再重载页面 capture 捕获模式 self 事件不是从内部触发 once 点击事件只会触发一次 监听按键事件时，也有一些常见的键值，下面是键值汇总 修饰符 作用 enter enter键 tab tab键 delete 删除键 esc esc键 space 空白符键 up 上方向键 down 下方向键 left 左方向键 right 右方向键 ctrl ctrl键 alt alt键 shift shift键 meta meta键 5.输入绑定 v-model使用 v-model 指令在表单控件上实现双向绑定，负责监听输入事件并更新数据 12&lt;input type=\"text\" v-model=\"msg\" placeholder=\"edit me\"&gt;&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; 其他的用法差不多，不用细写了 组件为了扩展 HTML 元素，封装可重用的代码。有些情况下，组件也可以表现为 is 特性进行了扩展的原生 HTML 元素1.使用组件(1)全局注册123&lt;div id=\"example\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; 12345678Vue.component('my-component', &#123; template: '&lt;div&gt; component &lt;/div&gt;',&#125;)new Vue(&#123; el: '#example'&#125;) (2)局部注册12345678var Child = &#123; template: '&lt;div&gt; A custom component!&lt;/div&gt;'&#125;new Vue(&#123; components: &#123; 'my-component': Child &#125;&#125;) (3)模板限制(4)data函数(5)组件组合 2.Prop(1)传递数据(2)单向数据流(3)prop验证 3.非Prop特性替换/合并现有特性 4.自定义事件(1)使用 v-on 绑定自定义事件(2)给组件绑定原生事件(3).sync 修饰符(4)使用自定义事件的表单输入组件(5)自定义组件的 v-model 5.插槽(1)单插槽(2)具名插槽(3)作用域插槽 6.动态组件 7.杂项(1)编写可复用组件(2)子组件引用(3)异步组件(4)高级异步组件(5)组件名约定(6)递归组件(7)组件间的循环引用(8)内联模板(9)X-Template(10)对低开销的静态组件使用 v-once","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"框架","slug":"框架","permalink":"http://yoursite.com/tags/框架/"}]},{"title":"","slug":"t-note_vue_003","date":"2017-12-12T08:14:39.000Z","updated":"2019-02-26T02:20:58.972Z","comments":true,"path":"2017/12/12/t-note_vue_003/","link":"","permalink":"http://yoursite.com/2017/12/12/t-note_vue_003/","excerpt":"","text":"title: 再探 vue 框架：&lt;上篇&gt;date: 2018-12-15 11:23:26categories: vuetags: [JavaScript, 框架] 再探 vue 框架（上）组件化开发异步路由自动化测试权限管理vuex","categories":[],"tags":[]},{"title":"生活杂感","slug":"l-tell_thought_001","date":"2017-10-22T02:28:51.000Z","updated":"2017-10-23T07:43:38.000Z","comments":true,"path":"2017/10/22/l-tell_thought_001/","link":"","permalink":"http://yoursite.com/2017/10/22/l-tell_thought_001/","excerpt":"","text":"快毕业了，面临着各种各样的选择，同时也不停的思考着，到底自己想过怎样的生活，该拥有怎样的生活态度。经过一番的思考体悟，便写下这一小段杂感。 入门：独善其身 有明确的目标，并为之努力奋斗着 做着自己感兴趣的事情 善待家人，善待自己 进阶：年轻有为 一步一步实现了自己的小目标 做自己喜欢的事情，并小有成就 有着稳固的社交圈，相处和睦融洽 精通：海阔鱼跃 带着一群小伙伴，成就了一番事业 在喜欢的领域中，结交了不少志趣相投的朋友 家庭和睦温馨，社交游刃有余，生活不受拘束，自由自在","categories":[],"tags":[{"name":"生活杂感","slug":"生活杂感","permalink":"http://yoursite.com/tags/生活杂感/"}]},{"title":"浅析设计模式在web开发中的应用<一>：单一职责","slug":"t-book_php_001","date":"2017-09-25T03:13:05.000Z","updated":"2017-10-13T01:53:05.000Z","comments":true,"path":"2017/09/25/t-book_php_001/","link":"","permalink":"http://yoursite.com/2017/09/25/t-book_php_001/","excerpt":"","text":"经过接近两年的前端知识的学习，多多少少积累了不少知识和经验。一直想着写点东西，由于时间和自己学艺不精的原因，没有太多心思去写博客，现在暂时有点闲功夫了。想着还是写一点东西吧，所以这篇博客出来了。 单一职责（SRP）1.简单举个例子一家 2000 人的工厂生产出 1000 辆汽车，如果每 2 个人负责一辆汽车的制造，要完成这个生产任务，可能几十年都完成不了。但是如果把这个任务拆分成一个一个小的任务，这里的每个工人都有自己独有的任务，有着专业的技能，那么每个人的职责是单一的，制作轮子的不必管制作灯泡的。这样效率就大大的提升了。是不是很容易理解呢 2.在敏捷软件开发中，把“职责”定义为“变化的原因”对于一个类而言，应该只有一个引起它变化的原因，这句话怎么理解呢？简单的说：就是一个类只负责一个功能领域里的一个职责，不同变化的原因放在不同的类中。比如说 MVC 框架中，表单插入数据库字段过滤与安全检查应该放在 controller 层还是 model 层？数据库过滤与安全检查是表单插入这一个功能领域里的一个职责，它应该单独封装成类，所以应该放在 model 层。从上面的描述中可以看出，单一职责有 2 层含义：第一是避免相同的职责分散到不同的类中，第二避免一个类承担了太多的职责。 3.单一职责的好处在于: 减少类之间的耦合：需求发生变化时，只修改一个类从而隔离了变化。如果一个类有不同的职责，当这些职责都耦合在一起，当一个职责发生变化时就会影响其他的职责。 提高类的复用性：当需要修改某个职责时，只需要替换掉这个类，不会影响其他的类的职责。现在流行的组件化开发，就是使用了单一职责这一模式。 4.单一职责的体现(1)工厂模式：负责生产对象，提供不同的参数生产不同的对象12345678&lt;?php interface Db_Adapter &#123; public function connect($config) &#123; public function query($query, $handle); &#125; &#125; // 抽象的接口，并未给出具体的实现?&gt; 123456789&lt;?php class Db_Adapter_Mysql implements Db_Adapter &#123; private $_dbLink; public function connect($config) &#123; /** code */ &#125; &#125; // MySQL的操作类，也可以是SQLite或者Oracle等等?&gt; 12345678910111213&lt;?php class sqlFactory &#123; public static function factory($type) &#123; if(include_once 'Drivers/'.$type.'.php') &#123; $classname = 'Db_Adapter_'.$type; return new $classname; &#125; else &#123; throw new Exception('Driver not found'); &#125; &#125; &#125; // 工厂模式，生成不同的对象?&gt; 思考：工厂模式与单一职责有什么关系呢？其实有很大关系的，从上面我们可以看出，MySQL 操作，还有 SQLite 等等数据库的操作，都是用单独的类写出来的，这样做的原因就是，避免这些职责耦合到一个功能类里，所以把这些职责用单独的类封装起来了。但是单独封装了就会有个问题，一旦产生了功能变化，就应该可以自由的切换到各自的类中生成不同的对象。所以使用工厂模式来实现这一性质，当功能发生变化时，在执行的时候，传入恰当的参数就可以切换到相应的类生成相应的对象了。 (2)命令模式命令模式将“命令请求者”和“命令执行者”职责分开，生成单独的职责。举个例子，你去餐馆吃饭，餐馆有员工，厨师等角色，作为顾客，你需要把菜单投递给员工，由员工去通知厨师主管去实现，厨师收到菜单后，就按照菜单上的内容开始做菜。这里命令的请求和实现就完成了解耦。代码模拟这一过程123456789101112131415161718&lt;?php// 模拟厨师class cooker &#123; public function meal() &#123; echo 'meal'; &#125; public function drink() &#123; echo 'drink'; &#125; public function over() &#123; echo 'ok'; &#125; interface Command &#123; public function execute(); &#125;&#125;?&gt; 1234567891011121314151617181920&lt;?php// 模拟员工和厨师,绑定命令接受者class MealCommand implements Command &#123; public function __construct(cooker $cooker) &#123; $this-&gt;cooker = $cooker; &#125; public function execute() &#123; $this-&gt;cooker-&gt;meal(); &#125;&#125;?&gt;class DrinkCommand implements Command &#123; public function __construct(cooker $cooker) &#123; $this-&gt;cooker = $cooker; &#125; public function execute() &#123; $this-&gt;cooker-&gt;drink(); &#125;&#125;?&gt; 123456789101112131415// 模拟员工与顾客class cookerControl &#123; private $mealcommand; private $drinkcommand; public function addCommand(Command $mealcommand, Command $drinkcommand) &#123; $this-&gt;mealcommand = $mealcommand; $this-&gt;drinkcommand = $drinkcommand; &#125; public function calldrink() &#123; $this-&gt;mealcommand-&gt;execute(); &#125; public function calldrink() &#123; $this-&gt;drinkcommand-&gt;exexute(); &#125;&#125; 12345678// 实现命令模式$control = new cookControl;$cooker = new cooker;$mealcommand = new MealCommand($cooker);$drinkcommand = new DrinkCommand($cooker);$control-&gt;addCommand($mealCommand, $drinkcommand);$control-&gt;callmeal();$control-&gt;calldrink(); 代码模拟出来了，为啥要这么写呢?当然是解耦啦，但这是怎么个解耦法呢？这样做有好处呢？由上可以看出，第一个好处，厨师的做饭和做喝的是分离的，是两个不同的类，做饭这一职责和做菜这一职责相互独立互不影响。第二个好处，顾客的命令和厨师的执行是分离的，一旦厨师的执行出现了问题，重新执行就可以了，但是如果顾客未与厨师功能分离开来，这整个命令的过程都会受到影响。(3)MVC 模式由上图可知，这些业务是非常复杂的，各层之间分层很细，有很多子模块，系统的总体设计的原则是，把复杂的业务逻辑分成各种子模块，子系统。这样的架构更加利用，各个模块之间的解耦和分工合作。","categories":[{"name":"web开发","slug":"web开发","permalink":"http://yoursite.com/categories/web开发/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"框架初探：jQuery 初体验","slug":"t-book_jq_001","date":"2017-03-13T14:34:22.000Z","updated":"2017-10-18T04:38:41.000Z","comments":true,"path":"2017/03/13/t-book_jq_001/","link":"","permalink":"http://yoursite.com/2017/03/13/t-book_jq_001/","excerpt":"","text":"学过一段时间，也用过一段时间 JavaScript，总感觉原生的 JS 需要处理太多的兼容问题。有没有一个好的工具，把这些麻烦事件都给封装起来。当然是有的，自从用了 jQuery， 代码敲得少了，处理的事情却更多。现在写一个入门的博客，以便以后翻阅。 jQuery 是啥jQuery 本身是很小型框架的，这个有点像我们学习 C++ 中的 STL (标准模板库)，简单来说就是大神们帮我们把一些复杂的实现逻辑封装成一个函数或者类直接供我们来用。其中也考虑了健壮性和兼容性以及性能问题，真的是很好很方便的工具。就让我站在巨人们的身上敲代码吧。 jQuery 原理jQuery3.0.0 现在采用的是 ES5 语法并没有采用 ES6 语法的,而且全部采用的是严格模式，我仔细看了下未压缩源码总共有 10038 行，规模还算不小。但是整体的结构的设计变化不大。 jQuery 的核心是一个 立即执行的匿名函数，接收两个参数，一个是 global 对象，一个是 factory 的函数对象。下面是它的核心的源码结构，核心函数是507行完，大部分代码其实是在扩展里面12345678910111213141516171819( function( global, factory ) &#123; \"using strict\"; if ( typeof module === \"object\" &amp;&amp; typeof module.exports === \"object\" ) &#123; // 定义模块对象 module.exports = global.document ? factory( global, true ) : function( w ) &#123; if ( !w.document ) &#123; throw new Error( \"jQuery requires a window with a document\" ); &#125; return factory( w ); &#125;; &#125; else &#123; factory( global ); &#125;&#125; )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) &#123; \"using strict\"; // 代码&#125; ); 这段代码的主要作用是判断 global.document 是否存在，不存在就抛出错误，存在就定义的模块为传进来的 factory 对象。所以其实真正的操作全在 factory 的函数里。比较在意的是 jQuery 的代码风格和我们大多数人平时的风格不一样，松散性太高，有些不习惯 下面我们看看 factory 函数里到底写了些什么呢1234567891011121314151617181920212223242526function ( window, noGlobal ) &#123; \"using strict\"; var arr = []; var document = window.document; var getProto = Object.getPrototypeOf; var slice = arr.slice; // code // 这里是把一些数组的方法作了简化 var varsion = \"3.0.0\", jQuery = function( selector, context ) &#123; return jQuery.fn.init( selector, context ); &#125;, // code fcamelCase = function( all, letter ) &#123; return letter.toUpperCase(); &#125;; jQuery.fn = jQuery.prototype = &#123; // code &#125;; jQuery.extend = jQuery.fn.extend = function() &#123; // code &#125;; // code&#125; 这 500 多行整体的结构大致就是这样的，学了 ES5 理解这些代码也不难，它首先处理了基本类型数组的一些方法，然后定义了 jQuery 选择器的方法初始化过程，然后定义 jQuery 的核心方法和原型的调用过程，最后增加了 jQuery 的扩展。具体 10000 多行代码也不细说了。下面看看怎么用吧。 开始用 jQuery开始 jQuery 真的很简单 引用两种方式引用1.下载后引用本地库我们到官网下载jQuery的不同版本，然后把文件放到我的项目目录中，供调用12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jQuery初探测试&lt;/title&gt; &lt;script src=\"lib/jquery-3.0.0.js\"&gt;&lt;/script&gt; &lt;script src=\"test.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 我下载的是最新的3.0.0版本，在html引用，后写一个js测试一下1234// test.js$(document).ready(function() &#123; console.log(\"hello world\");&#125;); // hello world 2.在线直接引用12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jQuery初探测试&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-3.0.0.min.js\"&gt;&lt;/script&gt; &lt;script src=\"test.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 测试结果相同说明：中间有个 min 是压缩版，就是生产版本，没有的就是开发版本。不同场景使用不同版本，开发版本可以直接修改内容，生产版本已经压缩好了，一般就是直接用于产品了。 基本用法选择一个元素或者元素集合，对选中的元素进行操作，比如123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jQuery初探测试&lt;/title&gt; &lt;script src=\"lib/jquery-3.0.0.js\"&gt;&lt;/script&gt; &lt;script src=\"test.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;click me&lt;/h1&gt; &lt;h2&gt;can't see me&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819// 正常写法$(document).ready(function() &#123; $(\"h1\").click(function() &#123; $(this).addClass(\"color\"); &#125;); $(\"h2\").mouseover(function() &#123; $(this).hide(); &#125;);&#125;);// 简写$(function() &#123; $(\"h1\").click(function() &#123; $(this).addClass(\"color\"); &#125;); $(\"h2\").mouseover(function() &#123; $(this).hide(); &#125;);&#125;); 也可在线测试 jquery在线测试 基本用法具体全面的使用，参照API;我现在一个方面实现几个简单的 demo 模板先写一个模板1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"dome\"&gt; &lt;script src=\"lib/jquery.3.0.0.js\"&gt;&lt;/script&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;demo1&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 1234// 给body添加css$(function() &#123; $(document.body).css(\"color\", \"red\");&#125;); 选择器$(selector, [context]),第一个参数为选择器，第二个对象是可选项，选择器的当前环境123456789101112131415// 实例1$(function() &#123; // 给div p 增加 css $(\"div p\").addCss(\"color\", \"red\"); // 鼠标移动上去就隐藏 $(\"div.myclass\").mouseover(function() &#123; $(this).hide(); &#125;); // 找到页面中的第一个表单，选择里面的input,点击改变值 $(\"input\", document.forms[0]).click(function() &#123; $(this).attr(\"value\", \"出来了\"); &#125;);&#125;); 动态创建$(html, [ownerdocument])第一个参数为 html 片段，第二个是可选项，为 html 所属文档文档1234567891011121314151617181920212223// 创建一个hello的div插入到.hide中$(\"&lt;div&gt;&lt;p&gt;hello&lt;/p&gt;&lt;/div&gt;\").appendTo(\".hide\");// 创建div元素并声明对象的属性$(\"&lt;div&gt;\", &#123; \"class\": \"test\", text: \"click me\", click: function() &#123; $(this).toggleClass('test'); &#125;&#125;).appendTo(\"body\");// 创建一个imput$(\"&lt;input&gt;\", &#123; type: \"text\", val: \"Test\", focusin: function() &#123; $(this).addClass(\"active\"); &#125;, focusout: function() &#123; $(this).removeClass(\"active\"); &#125;&#125;).appendTo(\"form\"); AJAX简单的使用，jQuery.ajax(url, [setting])12345678910111213 // 发送一个ajax请求// Ajax var data = $.ajax(&#123; type: \"get\", url: \"demo1.php\", data: \"name=suo&amp;gender=male\", asyns: true, cache: false, success: function() &#123; console.log(\"good\"); &#125; &#125;).reponseText; console.log(data); 使用AJAX进行跨域请求123456789101112131415 $(function() &#123; $(\"input[name='username']\").keyup(function() &#123; var username = $(this).val(); $.ajax(&#123; url: \"http://101.132.34.184/demo/demo1.php\", dataType: \"json\", type: \"post\", data: &#123; \"username\": username &#125;, crossDomain: true, success: function(data) &#123; console.log(data); &#125; &#125;); &#125;);&#125;); 12345678910111213//demo/demo1.php&lt;?php // 允许跨域 header(\"Access-Control-Allow-Origin:*\"); $userDB = [\"shaosuo\", \"suoyue\", \"yue\"]; if(isset($_POST[\"username\"])) &#123; if(in_array($_POST[\"username\"], $userDB)) &#123; echo 0; &#125; else &#123; echo 1; &#125; &#125;php?&gt; 还有一些用法，这里不一一测试了，做到这些也算是入门了，多查文档多熟悉语法，jQuery 用熟练了才算真正的好用","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"前端自动化测试","slug":"t-test","date":"2017-01-16T12:33:23.000Z","updated":"2018-01-16T06:51:41.860Z","comments":true,"path":"2017/01/16/t-test/","link":"","permalink":"http://yoursite.com/2017/01/16/t-test/","excerpt":"","text":"","categories":[{"name":"前端工具","slug":"前端工具","permalink":"http://yoursite.com/categories/前端工具/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/测试/"}]},{"title":"ECMAScript 6 之 Module","slug":"t-book_js_0","date":"2016-09-15T11:25:23.000Z","updated":"2017-10-13T01:55:32.000Z","comments":true,"path":"2016/09/15/t-book_js_0/","link":"","permalink":"http://yoursite.com/2016/09/15/t-book_js_0/","excerpt":"","text":"Module在 ES6 以前，JavaScript 始终没有模块体系，无法将一个大程序拆分成相互依赖的小程序，再用简单的方法拼装起来。而其它语言却都有这样的功能。如 Ruby的require,Python的import,甚至 css 都有@import。因此社区制定了一些模块加载方案，主要有 CommonJS 和 AMD 两种，前者用于服务器，后者用于浏览器。 ES6 在语言标准层面上，实现了模块功能，而且相当简单，完全可以替代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 ES6 模块设计思想是尽量的静态化，使得编译时就能确定模块之间的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 CommonJS 写法123456let &#123; stat, exist, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exist = _fs.exist;let readFile = _fs.readFile; ES6 模块写法1import &#123; stat, exist, readFile &#125; from 'fs'; 编译时加载方法，使得静态分析成为可能，效率也更高它的好处 不需要 UMD 模块格式，将来服务器和浏览器都会支持 将来浏览器的新 API 就能用模块格式来提供 不再需要对象作为命令空间 严格模式ES6 模块自动采用严格模式 变量必须声明后使用 函数参数不能同名 不能使用with 不能对const变量赋值 不能用0表示八进制 不能删除不可删除属性 eval不会在外层作用域引入变量 eval和agrgument不能重新赋值 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局变量 增加保留字protected, static, interface import与export 命令import和export构成模块的对外接口 1.import1234567891011121314// mian.jsimport &#123;name, gender, age&#125; from './person';function getName() &#123; return name;&#125;// 重命名import &#123;name as n&#125; from './person';// 只加载不输入import './person';// 模块整体加载import * as person from './person'; 注意： 不能使用表达式，静态效果 可以提升到头部 加载两次同样的模块，只执行一次 2.export12345678910111213141516171819202122232425262728293031323334353637// 单次定义export var name = \"suo\";export var gender = \"male\";export var age = 10;// 批量定义var name = 'suo';var gender = \"male\";var age = 10;export &#123;name, gender, age&#125;;// 重命名export &#123; name as n, gender as g, age as a&#125;;// 函数export function sum(x, y) &#123; return x + y;&#125;function sum(x, y) &#123; return x + y; &#125;export &#123; sum &#125;export &#123; sum as s;&#125;;// 默认输出// export-default.jsexport default function() &#123; console.log(\"ok\");&#125; // 非匿名也可以import foo from './export-default';foo(); // ok 注意：后两种就算只有一个变量或者函数也要花括号 3.复合写法12345678910111213141516export &#123;name, gender&#125; from 'person';// 等同于import &#123;name, gender&#125; from 'person';export &#123;name, gender&#125;;// 重命名export &#123;name as n&#125; from 'person';// 整体export * from 'person';// 默认export &#123;default&#125; from 'person';// 具名改默认export &#123;name as default&#125; from 'person';// 默认改具名export &#123;default as name&#125; from 'person'; 模块的继承12export &#123;getName as personName&#125; from 'person';// 输出其中的一部分，并改名 跨模块常量123456789101112131415161718192021// main.jsexport const A = 1;export const B = 2;// test1.jsimport * from 'main';// test2.jsimport &#123;A, B&#125; from 'main';// db.jsexport const db = &#123; name: \"suo\", paw: \"suoyue\", info: \"ok\"&#125;// user.jsexport const user = ['suo', 'yue', 'smile'];import &#123;db&#125; from 'db';import &#123;user&#125; from 'user';","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"http://yoursite.com/tags/ECMAScript6/"}]},{"title":"ECMAScript 6 之 let 和 const 命令","slug":"t-book_js_012","date":"2016-09-10T11:25:23.000Z","updated":"2017-10-13T01:55:39.000Z","comments":true,"path":"2016/09/10/t-book_js_012/","link":"","permalink":"http://yoursite.com/2016/09/10/t-book_js_012/","excerpt":"","text":"学习前端有一段时间了，ECMAScript5 也算是掌握的差不多了。经过了这段时间的实践，也从中发现ECMAScript5 有很多不方便的地方。比如只有函数作用域，块级作用域需要模拟，还有面向对象也是不足够的，等等。后来我接触到了 ECMAScript6 果然在这个新版本中，很多 ES5 的遗留问题都得到改善。所以我近期找了一些 ES6 的资料书来学习。其中入门最佳的书籍，要推阮一峰老师的 《ECMAScript 6入门》 了。感谢一峰老师的知识的整理，提升了我学习 ES6 的效率。 let命令类似于var，只在块中有效。变相的新增了块级作用域有没有1234567&#123; let name = \"suo\"; var gender = \"male\"; console.log(name); // suo&#125;console.log(name); //console.log(gender); // yue 1.适合使用for循环1234567for(let i = 0; i &lt; 3; i++) &#123; let i = \"suo\"; console.log(i);&#125;// suo suo suo// 2. 知道注意的地方是，let用在for循环中是输出了三次suo，说明for中的两个let的作用域也不一样 2.不存在变量声明提升123console.log(name);let name = \"suo\";// Uncaught ReferenceError: name is not defined 变量使用一定要在声明后使用，否则报错 3.暂时性死区123456var name = \"suo\";&#123; name =\"yue\"; let name = \"suo yue\";&#125;// Uncaught ReferenceError: name is not defined 一旦块中有let声明的变量，该变量即与块绑定，不受外界变量干扰 4.不允许重复声明12345&#123; let name = \"suo\"; let name = \"yue\";&#125;// Uncaught SyntaxError: Identifier 'name' has already been declared 块级作用域let 实际是给 JavaScript 新增了块级作用域1.作用域嵌套12345678&#123; let name = \"suo\" &#123; let name =\"yue\"; console.log(name); // yue &#125; console.log(name); // yue&#125; 作用域之间任意嵌套互不影响 2.块级作用域域函数声明12345678910function foo() &#123; console.log(\"suo\");&#125;&#123; function foo() &#123; console.log(\"yue\"); &#125; foo(); // suo&#125;foo(); // suo 函数声明互不影响，不同环境运行不一样。避免使用函数声明，用函数表达式替代 3.do表达式(提案)12345let x = do &#123; let a = 1; a = a + 1;&#125;console.log(x); // Uncaught SyntaxError: Unexpected token do const 命令与 c++ 类似，const 声明一个只读常量，一旦声明不可改变，同时也意味着声明必须初始化12345const PI = 3.1415926;PI = 3; //Assignment to constant variableconst LENGTH; // Uncaught SyntaxError: Missing initializer in const declaration 1.只在声明所在的块级作用域内有效1234&#123; const PI = 3.14;&#125;console.log(PI); // VM143:4 Uncaught ReferenceError: PI is not defined 2.不可重复声明123const PI = 3.14;const PI = 3;// Uncaught SyntaxError: Identifier 'PI' has already been declared 3.const的本质const保证的是变量指向的内存地址不改变。对于引用类型来说，变量名本身就是一个指向实际的内存指针。所以总结来说const是让变量名与它指向的内存的地址，这一关系不变。相当于 C 语言中的指针常量而不是常量指针。12345678910111213const person = &#123; name: \"suo\", gender: \"male\"&#125;;person.name = \"yue\";console.log(person.name); // yueperson1 = &#123; name: \"yue\", gender: \"female\"&#125;;person = person1; // Uncaught TypeError: Assignment to constant variable","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"http://yoursite.com/tags/ECMAScript6/"}]},{"title":"JavaScript 写常见算法之二分查找","slug":"t-note_ar_001","date":"2016-06-23T12:33:23.000Z","updated":"2017-10-18T12:32:33.000Z","comments":true,"path":"2016/06/23/t-note_ar_001/","link":"","permalink":"http://yoursite.com/2016/06/23/t-note_ar_001/","excerpt":"","text":"学习数据结构时，写过很多二分查找，具体细节已经忘的差不多了。现在重新用 JavaScript 捡起来，这其实和我之前写的快排有异曲同工之妙。 二分查找原理1.思想：减而治之同样先选择一个轴点，左边比轴点小，右边比轴点大。目标大于左边，则缩减整体规模为左边，反之缩减至右边规模。 2.方法：迭代简单分为 2 步 确定中间轴点 迭代深入，轴点替换换上下界 JavaScript 代码代码如下12345678910111213141516171819202122232425// 原始数组var originArr = [1, 3, 4, 5, 7, 8, 10, 11, 13, 14];function binSearch(arr, target) &#123; var mi, // 轴点下标 lo = 0, // 下界下标 hi = arr.length; // 上界下标 while (hi - lo &gt;= 1) &#123; // 取整处理 mi = Math.floor((hi + lo) / 2); if (target &lt; arr[mi]) &#123; hi = mi; &#125; else if (arr[mi] &lt; target)&#123; lo = mi; &#125; else &#123; return mi; &#125; &#125; return -1;&#125;// 测试console.log(binSearch(originArr, 4));// 2","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"JavaScript 写常见算法之快速排序","slug":"t-note_ar_002","date":"2016-06-22T12:33:23.000Z","updated":"2017-10-18T13:16:59.000Z","comments":true,"path":"2016/06/22/t-note_ar_002/","link":"","permalink":"http://yoursite.com/2016/06/22/t-note_ar_002/","excerpt":"","text":"之前学习数据结构的时候，用 C++ 的模板写过快速排序，而且还写了不少的变种。现在将用 JavaScipt 再重新复习一遍吧 快速排序原理1.思想： 分而治之选择一个数作为轴点，将整个序列分为左右两侧，左边不比轴点大，右边不比轴点小，对左右两边的子集迭代或递归直至缩减为最小规模。 2.方法： 递归简单分为4 步 求平凡解 选取轴点 左右分组 递归连接 JavaScipt 代码代码如下1234567891011121314151617181920212223242526272829// 原始序列var originArr = [2, 4, 5, 7, 3, 8, 1, 10, 9, 6];function quickSort(arr) &#123; // 1.最小规模 if (arr.length &lt;= 1) return arr; // 2.确定轴点 var povitIndex = Math.floor(arr.length / 2); var pivot = arr.splice(povitIndex, 1)[0]; // 3.遍历集合分类 var leftArr = [], rightArr = []; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; pivot) &#123; leftArr.push(arr[i]); &#125; else &#123; rightArr.push(arr[i]); &#125; &#125; // 4.递归子集并连接 return quickSort(leftArr).concat(pivot, quickSort(rightArr));&#125;// 测试console.log(quickSort(originArr));// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"前端工程化之路：初探 Gulp流式构建工具","slug":"t-note_gulp_001","date":"2016-06-10T12:33:23.000Z","updated":"2017-10-18T12:31:29.000Z","comments":true,"path":"2016/06/10/t-note_gulp_001/","link":"","permalink":"http://yoursite.com/2016/06/10/t-note_gulp_001/","excerpt":"","text":"用了一段事件的 webpack，感觉挺好用的，现在也试一下 gulp，这个工具上手起来其实也很快的。虽然它和 webpack 的原理相差很大，但是都能出色的完成任务。所以写一篇入门博客供以后参考。 什么是 gulp流式自动化构建工具，简单的说就是，把输入的某些东西，经过某个管道处理后，输出需要的形式。 为什么要用 gulp简单来说，就是减少我们一个一个构建的时间，使用这个工具自动化构建，如：scss 转化成 css, ES6 转化成 ES5, 等等，只要装了插件都能完成，最后就是把这些功能都写在一个函数里面，一起处理。 gulp 安装和其他 npm 一样，直接输入命令全局安装1npm install --global gulp 工程安装1npm install --save-dev gulp gulp 使用1.在工程目录里新建文件 gulpfile, 然后引入gulp1var gulp = require('gulp'); 2.gulp 四个核心方法 task() : 执行的任务 src() : 输入的文件 pipe() : 执行的管道方法，接在源后面或者其他管道后面 dest() : 输出的位置 1234567var gulp = require('gulp');// 第一个参数为任务名（默认为default)， 第一个是任务内容gulp.task('default', function() &#123; gulp.src('../source/*.js') .pipe(gulp.dest('../dest'));&#125;); 3.gulp 插件使用 安装压缩插件1npm install --global gulp-uglify 使用插件12345678var gulp = require('gulp');var uglify = require('gulp-uglify');gulp.task('compess', function() &#123; gulp.src('../source/js/*.js') .pipe(uglify()) .pipe(gulp.dest('../dest/js'))&#125;); 执行任务1gulp compress gulp 实践根据需要搜索想要的插件并安装gulp文档与gulp插件任务列表： 任务 插件 检测js gulp-jshint scss =&gt; css gulp-sass jsx =&gt; js gulp-react es6 =&gt; es5 gulp-babel 文件拷贝 gulp-copy 文件合并 gulp-concat 压缩js gulp-uglify 压缩css gulp-cssmin 压缩html gulp-htmlmin 压缩img gulp-imagemin 安装各种插件12npm insatll --global gulp-sass ... 写构建任务123456789101112131415161718var gulp = require('gulp');var sass = require('gulp-sass');var jsinit = require('gulp-jsinit');// ...gulp.task('all', function() &#123; gulp.src('../source/js') .pipe(react()) .pipe(babel()) .pipe(concat()) .pipe(uglify()) .pipe(gulp('../dest/js')); gulp.src('../source/css') .pipe(sass()) .pipe(concat()) .pipe(cssmin()) .pipe('../dest/css'); //...&#125;); 执行任务1gulp all","categories":[{"name":"前端工具","slug":"前端工具","permalink":"http://yoursite.com/categories/前端工具/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]},{"title":"前端工程化之路：初探 Webpack 打包工具","slug":"t-note_webpack_001","date":"2016-04-01T12:33:23.000Z","updated":"2017-10-19T04:52:41.000Z","comments":true,"path":"2016/04/01/t-note_webpack_001/","link":"","permalink":"http://yoursite.com/2016/04/01/t-note_webpack_001/","excerpt":"","text":"最近一段时间前端的工具越来越多，让人不禁眼花缭绕。其中也不乏好的工具，比如 Webpack 和 Gulp 两种不同风格的前端工具。感觉再不学都跟不上技术的节奏了。所以最近尝试的去学习了一些。收获也是颇丰。现在记下笔记，以便日后，查看。 Webpack 作用Webpack 被称为前端打包工具。将项目当作一个整体，通过给定主文件，使用 loaders 处理后生成浏览器可识别的 JavaScript 文件 Webpack 原理 模块化，处理依赖关系 CommonJs 标准 加载工具，集成在一起 Webpack 安装1234# 全局安装npm install -g webpack# 安装到项目目录npm install --save-dev webpack Webpack 使用1.建立npn环境1npm init 2.使用webpack工具1webpack &#123;entry file&#125; &#123;destination file&#125; 3.添加配置文件12345678// webpack.config.jsmodule.exports = &#123; entry: _dirname + \"/app/main.js\", output: &#123; path: _dirname + \"/public\", filename: \"bundle.js\" &#125;&#125; 4.添加调试工具(1)安装1npm install --save-dev webpack-dev-server (2)配置1234567891011121314// webpack.config.jsmodule.exports = &#123; devtools: \"eval-source-map\", entry: _dirname + \"/app/main.js\", output: &#123; path: _dirname + \"/public\", filename: \"bundle.js\" &#125; devServer: &#123; contentBase: \"./public\", historyApiFallback: true, inline: true &#125;&#125; (3)开启服务器1234// package.json\"script\": &#123; \"server\": \"webpack-dev-server --open\"&#125; (4)运行1npm run server 5.使用loaders","categories":[{"name":"前端工具","slug":"前端工具","permalink":"http://yoursite.com/categories/前端工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"前端工程化之路：初探 Sass 技术","slug":"t-note_sass_001","date":"2016-03-23T11:25:23.000Z","updated":"2017-10-18T13:49:11.000Z","comments":true,"path":"2016/03/23/t-note_sass_001/","link":"","permalink":"http://yoursite.com/2016/03/23/t-note_sass_001/","excerpt":"","text":"对于 CSS 来说这门语言就如同是写给设计者们的。语言本身是不需要编译的。而且写起来简单明了，但是对于程序员来说没有一种编程的感觉。对于一些重复冗余的代码，无力提高编写效率。现在推出了两个工具 Sass 和 Less，决定尝试一下，慢慢的适应用编程的方式来写 css。因此写了这篇入门的博客，以便以后忘记了的地方能很快捡起来。 Sass 语法变量1234567891011121314151617181920212223// 普通变量：全局使用属性值$mainColor: #666666;$color: #ff0000;body &#123;background-color: $mainColor; color: $ color;&#125;// 默认变量$color: #ff0000;$color: #000 !default; // 组件化开发时有用// 特殊变量：名字属性或者其他的$borderDire = top;.border-#&#123;$borderDire&#125; &#123; border-#&#123;$borderDire&#125;: $color 1px solid;&#125;// 多值变量$pList = 5px 10px 15px 20px;p &#123;margin: $pList;&#125;$hSize = (h1: 10px, h2: 15px, h3: 20px);// 全局变量(将新增)$color: #333333;$color: #666666 !global; 嵌套123456789101112131415161718192021222324// 选择器嵌套body &#123; .main &#123; color: $color; &#125;&#125;// 等同于body .main &#123;color: $color;&#125;// 属性嵌套.main &#123; border: &#123; left: &#123; width: 2px; &#125; top: &#123; width: 3px; &#125; &#125;&#125;// 等同于.main &#123;border-left-width: 2px; border-top-width: 3px;&#125; 导入1234567891011121314// file: _reset.scss* &#123;margin: 0; padding: 0;&#125;// file: test.scss@import 'reset';body &#123; .main &#123; color: $color; &#125;&#125;//等同于* &#123;margin: 0; padding 0;&#125;body .main &#123;color: #color;&#125; 混合1234567891011121314151617181920212223242526272829303132333435363738// 无参@mixin center-block &#123; margin: 0 auto;&#125;.main &#123; width: 600px; height: 300px; @include center-block;&#125;// 有参@mixin box-sizing ($sizing) &#123; -webkit-box-sizing: $sizing; -moz-bix-sizing: $sizing; sizing: $sizing;&#125;.box-border &#123; border: 1px $color solid; @include box-sizing(border-box);&#125;// 多参@mixin border-default($borderWidth: 1px, $borderStyle: dashed) &#123; border: $borderWidth $borderStyle #666;&#125;div p &#123;@include border-default;&#125;// media问题@mixin screen-max($res) &#123; @media only screen and (max-width: $res) &#123; @content; &#125;&#125;@include screen-max(600px) &#123; body &#123; color: red; &#125;&#125; 函数1234567891011$baseFontSize: 10px !default;$greyColor: #cccccc !default;@function pxToRem($px) &#123; @return $px / $baseFontSize * 1rem;&#125;p &#123; font-size: pxToRem(20px); // 自定义 color: darken($greyColor, 20%); // 内置函数&#125; 继承123.main &#123;height: $height; width: $width;&#125;.left &#123;@extend .main; color: $color;&#125;.right &#123;@extend .main; color: #777777;&#125; 运算123.main &#123;width: 500px;&#125;.left &#123;width: 200px;&#125;.right &#123;width: 500px - 200px - 30px;&#125; 条件123456789101112131415161718192021// 双目判断$size = 10;$color = red;p &#123; @if $size &lt; 10 &#123; font-size: 10px; &#125;&#125;p div &#123; @if $color == yellow &#123; color: darken(yellow, 20%); &#125; @else if $color == green &#123; color: darken(green, 30%); &#125; @else &#123; color: $color; &#125;&#125;// 三目判断if(true, 1px, 2px) // 1px 循环123456789101112// 1-10@for $i from 1 through 10 &#123; .item-#&#123;$i&#125;: &#123; display: none; &#125;&#125;// 1-10@for $i from 1 to 11 &#123; .item-#&#123;$i&#125;: &#123; display: none; &#125;&#125; Sass 安装1.安装 Ruby2.安装 Sass1gem install sass Sass 编译123456# 单文件编译sass test.scss test.css# 文件夹监听编译sass --watch scssDir:cssDir # 逆向转换sass-convert test.css test.scss Sass 调试123# 开启调试sass --watch scssDir:cssDir --debug-infosass --watch scssDir:cssDir --sourcemap","categories":[{"name":"前端工具","slug":"前端工具","permalink":"http://yoursite.com/categories/前端工具/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"sass","slug":"sass","permalink":"http://yoursite.com/tags/sass/"}]},{"title":"学习新技术：从 HTML4 到 HTML5 的改变","slug":"t-note_h5_001","date":"2016-03-13T14:34:22.000Z","updated":"2017-10-13T01:56:18.000Z","comments":true,"path":"2016/03/13/t-note_h5_001/","link":"","permalink":"http://yoursite.com/2016/03/13/t-note_h5_001/","excerpt":"","text":"很长时间都在和 HTML5 打交道，但是并没有区分 HTML5 和 HTML4 。但是今天我偶然看了一本 H5 的书籍 《H5网页设计入门必读》 ，读完之后，才想到原来这么多特性是 HTML5 的。由此我在这里做一个分类总结。总结一下 HTML5 到底有什么新的地方。 很久之前，我读了一本CSS的书籍《CSS权威指南》，里面详细概述了关于 结构和表现分离的思想。为什么谈到这个呢？原因是现在我们说的 H5 的改变很多都是基于这种思想。为了将 HTML 从表现化中脱离出来。 HTML5新增特性H5总得来说从6个方面做出了改变：1.弃用过时元素标签2.新增结构元素标签3.新增富媒体元素标签4.增强表单属性5.新增JavaScript API6.语义化，容错性提高 弃用过时标签12345678910111213141516171819&lt;!-- 框架家族 --&gt;&lt;frame&gt;&lt;/frame&gt;&lt;frameset&gt;&lt;/frameset&gt;&lt;noframes&gt;&lt;/noframes&gt;&lt;!-- 弃用 --&gt;&lt;!-- 首字母缩写 --&gt;&lt;acronym title=\"Suo Yue\"&gt;SY&lt;/acronym&gt; &lt;!-- 弃用 --&gt;&lt;abbr ttile=\"Suo Yue\"&gt;SY&lt;/abbr&gt; &lt;!-- 替代 --&gt;&lt;!-- 显示元素 --&gt;&lt;!-- 弃用 --&gt;&lt;font&gt;&lt;/font&gt;&lt;big&gt;&lt;/big&gt;&lt;center&gt;&lt;/center&gt;&lt;strike&gt;&lt;/strike&gt;&lt;!-- css替代--&gt; 新增结构元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- section:集合理论上相关的内容 --&gt;&lt;section&gt; &lt;h1&gt;锁的博客&lt;/h1&gt; &lt;p&gt;这是邵锁的博客&lt;/p&gt;&lt;/section&gt; &lt;!-- header:介绍和导航的辅助工具 --&gt;&lt;section&gt; &lt;header&gt; &lt;h1&gt;邵锁&lt;/h1&gt; &lt;/header&gt; &lt;p&gt;邵锁的博客&lt;/p&gt;&lt;/section&gt;&lt;!-- footer:内部元素信息，作者版权相关内容 --&gt;&lt;section&gt; &lt;header&gt; &lt;h1&gt;邵锁&lt;/h1&gt; &lt;/header&gt; &lt;p&gt;邵锁的博客&lt;/p&gt; &lt;footer&gt; &lt;p&gt;作者：邵锁&lt;/p&gt; &lt;/footer&gt;&lt;/section&gt;&lt;!-- aside: 侧边栏，相关性不大的内容 --&gt;&lt;aside&gt; &lt;p&gt;总计文章12篇&lt;/p&gt;&lt;/aside&gt;&lt;!-- nav:全站导航信息 --&gt;&lt;section&gt; &lt;header&gt; &lt;nav&gt; &lt;/nav&gt; &lt;/header&gt;&lt;/section&gt;&lt;!-- article:与aection相似，是section一个特殊类别，用于自包含内容 --&gt;&lt;article&gt; &lt;header&gt; &lt;nav&gt; &lt;/nav&gt; &lt;/header&gt;&lt;/article&gt;&lt;!-- hgroup:不希望内容现在在文件大纲内 --&gt;&lt;hgroup&gt; &lt;h1&gt;suo yue&lt;/h1&gt; &lt;h2&gt;suo suo&lt;/h2&gt;&lt;/hgroup&gt; 新增富媒体元素标签1234567891011121314151617181920212223242526&lt;!-- canvas:创建动态图像的环境 --&gt;&lt;canvas id=\"suo\" width=\"200\" height=\"200\"&gt; var canvas = dociment.getElementById('suo');var context = canvas.getContext('2d');context.strokeStyle = '#666666';context.strokeRect(20, 20, 100, 100);&lt;!-- 绘制一个正方形 --&gt;&lt;/canvas&gt;&lt;!-- audio:音频 --&gt;&lt;audio src=\"canon.mp3\" autoplay&gt;&lt;/audio&gt;&lt;audio src=\"canon.mp3\" controls&gt;&lt;/audio&gt;&lt;audio src=\"canon.mp3\" autobuffer&gt;&lt;/audio&gt;&lt;!-- 兼容音频格式 --&gt;&lt;audio controls&gt; &lt;source src=\"canon.ogg\" type=\"audio/ogg\"&gt; &lt;source src=\"canon.mp3\" type=\"audio/mp3\"&gt;&lt;/audio&gt;&lt;!-- video:视频 --&gt;&lt;video src=\"movie.mp4\" width=\"200\" height=\"200\"&gt;&lt;/video&gt;&lt;!-- 兼容视频格式 --&gt;&lt;video width=\"200\" height=\"200\"&gt; &lt;source src=\"movie.ogv\" type=\"video/ogv\"&gt; &lt;source src=\"movie.mp4\" type=\"video/mp4\"&gt;&lt;/video&gt; 增强表单属性1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!-- 以前的常规表单 --&gt;&lt;form action=\"login.php\" method=\"post\"&gt; &lt;input type=\"text\" name=\"username\"&gt; &lt;input type=\"password\" name=\"password\"&gt;&lt;/form&gt;&lt;!-- placeholder:没有值则插入占位符，定位后删除，离开恢复 --&gt;&lt;input type=\"text\" name=\"username\" placeholder=\"username\"&gt;&lt;!-- autofocus:自动聚焦模式,文件加载后自动聚焦到某一表单栏 --&gt;&lt;input type=\"text\" name=\"username\" autofocus&gt;&lt;!-- required:将脚本变为标记 --&gt;&lt;input type=\"text\" name=\"username\" required&gt;&lt;!-- autocomplete:自动填写表单 --&gt;&lt;input type=\"text\" name=\"username\" autocomplete=\"on\"&gt;&lt;!-- datalist:一系列选项关联到输入栏 --&gt;&lt;input type=\"text\" name=\"username\" list=\"suoyue\"&gt;&lt;datalist id=\"suoyue\"&gt; &lt;option value=\"suoyue\"&gt;&lt;/option&gt; &lt;option value=\"suo\"&gt;&lt;/option&gt; &lt;option value=\"shaosuo\"&gt;&lt;/option&gt; &lt;option value=\"yue\"&gt;&lt;/option&gt; &lt;option value=\"shaosuoyue\"&gt;&lt;/option&gt;&lt;/datalist&gt;&lt;!-- type:新增类型 --&gt;&lt;input type=\"search\"&gt; &lt;input type=\"email\"&gt; &lt;input type=\"url\"&gt; &lt;input type=\"tel\"&gt; &lt;input type=\"range\" min=\"1\" max=\"10\"&gt; &lt;input type=\"number\" min=\"1\" max=\"10\"&gt; &lt;input type=\"date\"&gt; &lt;input type=\"datetime\"&gt; &lt;input type=\"datetime-local\"&gt; &lt;input type=\"time\"&gt; &lt;input type=\"month\"&gt; &lt;input type=\"color\"&gt; &lt;!-- 自定类型:正则表达式 --&gt;&lt;input pattern=\"[\\d]5\"&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"《JavaScript高级程序设计》读后记<十一>：跨域","slug":"t-book_js_011","date":"2015-12-15T14:31:11.000Z","updated":"2017-10-18T04:06:56.000Z","comments":true,"path":"2015/12/15/t-book_js_011/","link":"","permalink":"http://yoursite.com/2015/12/15/t-book_js_011/","excerpt":"","text":"终于到了收官之作了，学了这么长时间的 JavaScript ，对这门语言也有一个全面的认识。虽然你没有 C 系列经典健全，没有 Java 系列流行应用广泛，也许也没有 PHP 广受追捧。甚至天生的不完美给开发者带来不少麻烦，各个浏览器不同的支持兼容性也很让人头疼。但是随着前端的发展，作为一门脚本语言，你变化越来越大也越来越完善，同时好的工具也层出不穷，各种开源技术遍地开花。因此我始终相信你会成为一门理想的编程语言，让前端这个领域始终朝气蓬勃。 同源策略什么是跨域？为什么跨域？这一切都要从它谈起：同源策略。同源策略：同协议，同域，同端口如果三个条件满足就是同源，两个不同源的站点是无法获取数据的。这是浏览器的一种策略。目的是为了保护用户信息安全，防止窃取数据。具体是以下行为被禁止 Cookie 和 LocalStroage ，indexDB 无法读取 Dom 无法获得 Ajax 请求无法获得下面我们具体了解下 Ajax AJAX全称 Asynchronous JavaScript + XML，这个技术能够向服务器请求额外的数据而无需卸载页面，简单的说就是无刷新技术，不需要刷新页面就可以获得新数据并显示在页面上。这个技术的核心是XMLHttpRequest对象 XMLHttpRequest直接上代码吧1.创建 XHR 对象12345678910111213141516171819202122232425// 创建XHR对象function createXHR() &#123; if (typeof XMLHttpRequest != \"undefined\") &#123; // IE7 以上版本 return new XMLHttpRequest(); &#125; else if (typeof ActiveXObject != \"undefined\") &#123; // IE7 之前的版本 if (typeof arguments.callee.activeXString != \"string\") &#123; var versions = [\"MSXML2.XMLHttp6.0\", \"MSXML2.XMLHTTP.3.0\", \"MSXML2.XMLHttp\"]; var 1, len; for (i = 0, len = versions.length; i &lt; len; i++) &#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex) &#123; // 跳过 &#125; &#125; &#125; return new ActivaXObject(arguments.callee.activeXString); &#125; else &#123; throw new Error(\"no xhr object avaiable\"); &#125;&#125; 2.使用 XHR 方法和属性发送同步请求123456789101112131415// 创建XHR对象var xhr = createXHR();// 启动请求(同步)xhr.open(\"get\", \"login.php\", false);// 发送请求xhr.send(null);// 服务器收到请求后自动填充xhr对象的属性if (xhr.status &gt;= 200 &amp;&amp; xhr status &lt; 300 || xhr.status == 304) &#123; console.log(xhr.responseText);&#125; else &#123; console.log(\"request fail!\" + xhr.status);&#125; 发送异步请求123456789101112131415161718192021var xhr = createXHR(); // 0状态xhr.onreadystatechange = function() &#123; // 检测请求状态 if (xhr.readyState == 4) &#123; // 检测状态码，确认响应成功返回 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; console.log(\"xhr.responseText\"); &#125; else &#123; console.log(\"fail\" + xhr.status); &#125; &#125;&#125;// 1状态xhr.open(\"get\", \"login.php\", \"true\");// 2状态xhr.send(null)// 使用xhr.about()可以取消异步请求 说明： responseText: 响应主体被返回的文本 responseXML: 响应的XML DOM 文档 status: 响应的HTTP状态，200成功，304资源未修改 statusText: HTTP状态说明 readyState: 0未初始-1启动-2发送-3接收-4完成 3.HTTP 头部信息(1)发送 XHR 时还会发送相应的头部信息 Accept: 浏览器能处理的内容 Accept-Charset: 能处理的字符集 Accept-Encoding: 压缩编码 Accept-Language: 语言 Connection: 连接类型 Cookie: 设置的 Cookie Host: 所在的域 Referer: 请求的 URL (Referrer拼写正确的单词) User-Agent: 用户代理字符串 (2)设置获取头部信息123456// send方法之前xhr.setRequestHeader(\"User-Agent\", \"suo\"); // 设置xhr.getRequestHeader(\"User-Agent\"); // 获取xhr.getRequestHeader(); // 获取所有 (3)Get 请求关键在于处理字符格式123456789101112// 处理字符函数function addURLParam(url, name, value) &#123; url += (url.indexOf(\"?\") == -1 ? \"?\" : \"&amp;\"); url += encodeURLComponent(name) + \"=\" + encodeURLComponent(value); return url;&#125;// 处理var url = \"index.php\";url = addURLParam(url, \"name\", \"suo\");url = addURLParam(url, \"friend\", \"yue\");// 请求xhr.open(); (4)Post 请求模仿表单提交1234xhr.open(\"post\", \"login\", true);xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");var form = document.getElementById(\"user-info\");xhr.send(serialize(form)); XMLHttpRequest21.FromData2.超时设定3.进度事件4.progress 事件 进度事件CORS全称为Cross-Origin Resource Sharing, 跨域资源共享，W3C新出来的一个规范的跨域方法在发送请求的时候添加一个 origin 头部，服务器根据头部信息决定是否响应Origin: http://suosmile.cn服务器判断是否要响应，可以接受就回发一个Access-Control-Allow-Origin: http://suosmile.cn IE 实现 CORSIE8 中引入了 XDR 类型 cookie 不会随请求发出，也不会响应返回 只能设置请求头部信息中的 Content-Type 字段 不能访问响应头部信息 只支持 GET 和 POST 默认异步 123456789101112131415161718192021// 创建XDRvar xdr = new XDomainRequest();// 成功触发xdr.onload = function() &#123; console.log(xdr.responseText);&#125;// 错误返回xdr.onerror = function() &#123; console.log(\"error\");&#125;// 超时xdr.timeout = 1000;xdr.ontimeout = function() &#123; console.log(\"timeout\");&#125;// 启动xdr.open(\"post\", \"http://suosmile.cn\");// 设置post格式xdr.contentType = \"application/x-www-form-urlencoded\";// 发送xdr.send(null); 其他浏览器实现只需要把XMLHttpRequest对象中的open方法的url改写成绝对地址就可以了，但是会有一些限制 不能使用setRequestHeader()和getAllResponseHeaders()方法 不能发送和接收cookie 跨浏览器实现图片 Ping一个网页可以从任何网页加载图片12345var img = new Image();img.onload = img.onerror = function() &#123; console.log(\"ok\");&#125;;img.src = \"http://suosmile.cn?name=suo\"; // ok JSONP全称Json with padding的简写，是应用JSON的一种新方法1callback(&#123;\"name\":\"suo\"&#125;); 有两个部分组成，一个是回调函数和数据通过动态操作脚本实现123456function handleResponse(response) &#123; console.log(response.ip + \",\" + response.city + ',' + response.region_name);&#125;var script = document.createElement(\"script\");script.src = \"http://suosmile.cn?callback=handleResponse\";document.body.insertBefore(script, document.body.firstChild); Comet一种高级的Comet，高级的AJAX 服务器发送SSE Web SocketsSSEXSS","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"《JavaScript高级程序设计》读后记<十>：事件","slug":"t-book_js_010","date":"2015-12-12T14:31:11.000Z","updated":"2017-10-13T01:48:36.000Z","comments":true,"path":"2015/12/12/t-book_js_010/","link":"","permalink":"http://yoursite.com/2015/12/12/t-book_js_010/","excerpt":"","text":"事件流事件冒泡事件捕获DOM 事件流事件处理程序HTML 事件处理程序DOM0 级事件处理程序DOM2 级事件处理程序IE 事件处理跨浏览器事件处理事件对象DOM 事件对象IE 事件对象跨浏览器事件对象事件类型UI 事件焦点事件鼠标滚轮事件键盘文本事件复合事件变动事件HTML5事件设备事件触摸手势事件内存与性能事件委托移除事件处理程序模拟事件模拟鼠标事件模拟键盘事件模拟其他事件","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"《JavaScript高级程序设计》读后记<九>：DOM","slug":"t-book_js_009","date":"2015-12-10T14:31:11.000Z","updated":"2017-10-13T01:48:03.000Z","comments":true,"path":"2015/12/10/t-book_js_009/","link":"","permalink":"http://yoursite.com/2015/12/10/t-book_js_009/","excerpt":"","text":"DOM 为 Document Object Model 的缩写，也是 HTML 和 XML 文档的一个 API 接口。描绘的是一个层次化节点树，允许开发人人添加移除和修改页面的某一部分。 节点层次123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;hello world&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 用一个图片描述一下 1.Node 类型 属性(1)nodeTypeJavaScipt中的所有节点类型都继承与Node类型。因此所有节点都共享着相同的基本属性和方法每个节点都有个NodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的下列12个数值常量来表示，任何节点类型必居其一 Node.ElEMNRT_NODE Node.ATTRIBUTE_NODE Node.TEXT_NODE Node.CDATASELECTION_NODE Node.ENTITY_REFERENCE_NODE Node.ENYIYY_NODE Node.PROCESSING_INSTUCATION_NODE Node.COMMENT_NODE Node.DOCUMNENT_NODE Node.DOCUMENT_TYPE_NODE Node.DOCUMENT_FRAGMENT_NODE Node.NOTATION_NODE 通过比较上面这些常量很容易确定节点的类型1234if (someNode.nodeTyep == Node.ELEMENT) &#123; alert(\"node is element type\"); // ie无效&#125;// 也可以直接与数字比较 (2)nodeName：保存标签名(3)nodeValue：null(4)childNodes:保存着NodeList对象，一组有序的序列12var firstChild = someNode.childNodes[0];var length = someNode.childNodes.length; (5)parentNode:指向文档父节点(6)nextSibling:下一个节点(7)previouSibling:上一个节点(8)ownerDocument:整个文档的文档节点 方法(1)appendChild方法在childNodes列表的末尾添加一个节点1var returnedNode = someNode.appendChild(newNode); (2)insertBefore方法插入特定的位置1234// 插入到第一个var aNode1 = someNode.appendChild(newNode, someNode.firstChild);// 插入到倒数第二个var aNode2 = someNode.appendChild(newNode, someNode.lastChild); (3)replaceChild方法1234// 替换第一个var aNode1 = someNode.replaceChild(newNode, someNode.firstChild); // 替换最后一个var aNode2 = someNode.replaceChild(newNode, someNode.lastChild); (4)removeChild方法1234// 移除第一个var aNode1 = someNode.removeChild(newNide, someNode.firstChild);// 移除最后一个var aNode2 = someNode.removeChild(newNide, someNode.laststChild); Document 类型表示文档，在浏览器中document对象是HTMLDocument的一个实例，表示整个HTML页面。document对象是window对象的一个属性，因此document作为全局对象来访问 nodeType:9 NodeName:#document nodeValue:null parentNode:null ownerDocument:null (1)文档子节点2个快捷访问方式，一个是documentElement属性，一个是childNodes访问文档元素 documentElement属性，指向&lt;html&gt; 123var html = document.documentElement;console.log(html === document.childNodes[0]);console.log(html === document.firstChild); body属性，直接指向&lt;body&gt; 1var body = document.body; 所有浏览器都支持document.documentElement和document.body doctype属性，指向&lt;!DOCTYPE&gt;1var docType = document.doctype; (2)文档信息 title属性，指向&lt;title&gt; URL属性 domain属性 referrer属性1234567var aTitle = document.title;// 完整URLvar aUrl = document.url;// 域var aDomain = document.domain;// 来源URLvar aReferrer = document.referrer (3)查找元素 getElementById方法:取ID元素 1var oDiv = document.getElementById(\"mydiv\"); // 早期版本不分大小写 getElementsByTagName方法:取元素 12345var lis = document.getElementsByTagName(\"li\");console.log(aLi[0].innerHTML);// 全部var all = document.getElementsByTagName(\"*\"); getElementsByName方法：取name所有元素 1var radio = document.getElementsByName(\"color\"); (4)特殊集合 document.anchors: 所有&lt;a&gt; document.applets: 所有带name的&lt;a&gt; document.forms: 所有&lt;form&gt;元素 document.images: 所有&lt;img&gt;元素 document.links: 所有带src的&lt;a&gt;元素 (5)DOM 一致性检测DOM 有多个级别。实现DOM检测就有很大必要了,implementation,规定了一个方法hasFeature1var hasXmlDom = document.implementation.hasFeature(\"XML\", \"1.0\"); (6)文档写入 write():原样写入 writeln():写入换行 open() close() Element 类型 nodeType:1 nodeName:标签名 nodeValue:null parentNode:可是Document或者Element childNodes:都可能 (1)HTML元素 id: 元素在文档唯一标识符 title: 附加说明 lang: 语言代码 dir: 语言的方向 className: 与class对应，之所以不用class是因为class是ES保留字 这些值都可以用来修改12&lt;a href=\"\" id=\"suo\" name=\"\" title=\"\" class=\"\" lang=\"\" dir=\"\"&gt;name&lt;/a&gt;&lt;!-- ie8之前不能访问 --&gt; (2)特性 getAttribute() setAttrubute() removeAttribute() (3)创建元素document.createElement方法1234567var div = document.createElement(\"div\");div.id = \"suo\";div.className = \"yue\";document.body.appendChild(\"div\");// 完整插入var div = document.createElement(\"&lt;div id=\\\"suo\\\" class=\\\"yue\\\"&gt; &lt;/div&gt;\"); (4)元素的子节点不同浏览器解析不一样 IE不解析间隔 其他浏览器连间隔也解析 4.Text 类型 nodeType: 3 nodeName: “#text” nodeValue: 节点文本 parentNode是一个Element 没有子节点 appendData(text): 插入节点末尾 deleteDate(offset, count): 删除文本 insertData(offset, text): 插入文本 replaceData(offset, count, text): 替换文本 splitText(offset): 分割文本 substringData(offset, count): 提取字符串 123456&lt;!-- 没有内容 --&gt;&lt;div&gt;&lt;/div&gt; &lt;!-- 有个空格 --&gt;&lt;div&gt; &lt;/div&gt;&lt;!-- 有内容 --&gt;&lt;div&gt;hello world&lt;/div&gt; 123456// 取得文本var textNode = div.firstChild;// 或者var textNode = div.childNodes[0];// 修改值textNode.nodeValue = \"suoyue\"; (1)创建文本节点12345678var textNode = document.createTextNode(\"&lt;p&gt;hello world!&lt;/p&gt;\");// 分开创建var element = document.createElement(\"p\");element.className = \"color\";var textNode = document.createTextNode(\"hello world!\");element.appendChild(textNode);document.body.appendChild(element); (2)规范文本节点1element.normalize(); // 将多个文本节点合并成一个文本节点 5.Comment 类型注释在DOM里面用Comment类型表示 nodeType: 8 nodeName: “#comment” nodeValue: “注释的内容” parentNode 可能是Document或者Element 不支持子节点 123456// 获得var div = document.getElementById(\"mydiv\");var comment = div.firstChild;console.log(comment);// 添加var comment = document.createComment(\"good job\"); 6.CDATASection 类型 nodeType: 4 nodeName: “#cdata-section” nodeValue: CDATA区域内容 parentNode 可能是Document或者Element 不支持子节点 1var cdata = document.createCDateSection(); 7.DocumentType 类型仅FireFox,Safari,Oprea支持 nodeType: 10 nodeName: doctype的名称 nodeValue: null parentNode: Document 不支持子节点 8.DocumentFragment 类型轻量级文档，文档片段 nodeType: 11 nodeName: “#document-fragment” nodeValue: null parentNode: null 子节点可以为各种 123456789var fragment = document.createDocumentFrament();va ul = document.getElementById(\"list\");var li = null;for (var i = 0; i &lt; 3; i++) &#123; li = document.createElement(\"li\"); li.appendChild(document.createTextNode(\"Item\" + (i+1))); fragment.appendChild(li);&#125;ul.appendChild(fragment); 9.Attr 类型 nodeType: 2 nodeName: 特性的名称 nodeValue: 特性的值 parentNode: null HTML没有子节点 XML里面子节点可以是TEXT或者EntityReference DOM 操作技术DOM操作比较简明，原本不会很麻烦，但是由于浏览器有个隐性的陷阱和不兼容的问题，JavaScript操作还比较麻烦1.动态脚本动态加载外部文件123456789101112var script = document.createElement(\"script\");script.type = \"text/javascript\";script.src = \"suo.js\";document.body.appendChild(script);// 使用函数封装一下function loadScript($url) &#123; var script = document.createElement(\"script\"); script.type = \"text/javascript\"; script.src = $url; document.body.appendChild(script);&#125; 2.动态样式与动态脚本一样3.操作表格4.使用NodeList DOM 选择符API1.querySelector 方法12345// 接受选择符，返回与该模式匹配的第一个元素var body = document.querySelector(\"body\");var myid = document.querySelector(\"#myid\");var myclass = document.querySelector(\".myclass\");var img = document.querySelector(\"img.myclass\"); 2.querySelectorAll 方法12// 接受选择符，返回的是一个NodeList实例var nodeList = document.querySelector(\".myclass\"); 3.machesSelector 方法12// 接受选择符，返回True或者falsevar hasCLass = document.matchesSelector(\"body.myclass\"); 元素遍历新增的一组属性，为了让IE的行为一致 childElementCount: 返回子元素个数 firstElementChild: 指向第一个子元素 lastAElementChild: 指向最后一个子元素 previousElementSibling: 指向后一个同辈元素 nextElementSibling: 指向前一个子元素 HTML51.与类相关的扩充 getElementsByClassName() classList 属性 2.焦点管理 document.activeElement 3.HTMLDocument的变化 readyState 属性 兼容模式 head 属性 4.字符集属性document.charset = &quot;UTF-8 5.自定义属性类型data- 6.插入标记 innerHTML 属性 outerHTML 属性 insertAdjacentHTML 方法 内存与性能 scrollIntoView方法 扩展（了解）1.文档模式 IE5: 混杂模式 IE7: IE7标准模式 IE8: IE8标准模式 IE9: IE9标准模式，ES5，CSS3，H5大部分功能 2.children 属性3.contains 方法4.插入文本5.滚动","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"《JavaScript高级程序设计》读后记<八>：BOM","slug":"t-book_js_008","date":"2015-12-08T14:31:11.000Z","updated":"2017-10-13T01:48:06.000Z","comments":true,"path":"2015/12/08/t-book_js_008/","link":"","permalink":"http://yoursite.com/2015/12/08/t-book_js_008/","excerpt":"","text":"前几章学了 JavaScript 的基础的知识，理论性太强。需要思考理解的东西远远多于实战的。我最近看了 BOM 这一章，才真正的感受到了 JavaScript 真的很强大，特别是在于操作浏览器这方法。不多写了，已经等不急实战了。 理解BOM使用 Window 对象说明一下，在浏览器中 window 对象有两重身份，一重是 JavaScript 访问浏览器的接口，另一重是 ES 规定的 Global 对象，因此可以访问parseInt()等方法测试一下1234567var name = \"suo\";function sayName() &#123; console.log(this.name);&#125;sayName(); // suoconsole.log(window.name); // suowindow.sayName(); // suo 说明全局的变量和方法，使用 window均能访问到 全局变量的window的变量有说明差异呢，有一点就是定义在window上的属性可以使用delete删除，而定义的全局变量不可以12345678var name = \"suo\";window.gender = \"male\";delete name;delete window.gender;console.log(name); // suoconsole.log(window.gender); // undefined 另外尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的对象是否存在12var newname = oldname; // 报错var newname = window.oldname; // 没报错 说了这么多，我们来用 window 对象操作窗口(1)控制窗口位置1234567891011var leftPos = (typeof window.screenLeft == \"number\") ? window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == \"number\") ? window.screenTop : window.screenY;console.log(leftPos);console.log(topPos);// IE(5,7-11) edge firefox 都能正常显示位置// chorme 始终显示 0 0// 令人费解 除此之外还可以改变位置123456// 移动多少像素window.moveBy(20, 30);// 移动到哪个位置window.moveTo(100, 100);// 测试结果，除了IE以外，其他浏览器都默认禁用了 (2)控制窗口大小1234567891011121314// 页面视图区大小// 兼容的处理var pageWidth = window.innerWidth, pageHeight = window.innerHeight;if (typeof pageWidth != \"number\") &#123; if (document.campatMode == \"CSS1Compat\") &#123; pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; &#125; else &#123; pageWidth = document.body.clientWidth; // IE6 pageHeight = document.body.clientHeight; &#125;&#125;console.log(pageWidth + ',' + pageHeight); // 1080,1008 我们还可以调整窗口大小12345// 调整的像素window.resizeBy(300, 200);// 调整到多少window.resizeTo(100,100);// 仍然除了IE以外其他都禁用了的 (3)打开窗口使用window.open()函数打开窗口，其中有四个参数：URL， target， 特性字符串，是否取得历史纪录中那个页面。第一个参数不用说，第二个参数有几个可以是特殊值：_self,_parent,_top,_blank。举个例子123456// 打开窗口var local = window.open(\"http://localhost:4000\", \"local\", \"height=500,width=500,top=100,left=100,resizable=yes\");// 关闭窗口local.close()// 强制关闭top.close(); 检测窗口是否被屏蔽123456789101112var blocked = false;try&#123; var local = window.open(\"http://localhost:4000\", \"_blank\"); if (local == null) &#123; blocked = true; &#125;&#125; catch (ex) &#123; blocked = true;&#125;if (blocked) &#123; console.log(\"窗口被屏蔽\");&#125; (4)使用定时器window 对象提供两种定时器，一种是超时定时器setTimeout(),另一种是间歇定时器setInterval()。它们都提供两个参数，一个是执行的代码，一个是时间毫秒。看一下代码1234567891011121314151617181920212223242526272829303132// 超时定时器var timer = setTimeout(function() &#123; console.log(\"ok\"); &#125;, 1000); // 经过一秒后ok// 取消超时定时器clearTimeout(timer); // 没打印// 间歇定时器var max = 3; // 设置最多定时次数var num = 0;var interval = setInterval(function() &#123; num++; if (num == max) &#123; clearInterval(interval); &#125; console.log(\"ok\"); &#125;, 1000); // 没经过一秒打印一个ok，打印三次后结束打印// 使用超时定时器模拟间歇定时器var max = 3;var num = 0;function timerFunction()&#123; console.log(\"ok\"); num++; if (num &lt; max) &#123; setTimeout(timerFunction, 1000); &#125; else &#123; console.log(\"done\"); &#125;&#125;setTimeout(timerFunction, 1000); 开发环境中很少真正使用间歇定时器，一般用超时定时器模拟它，原因在于当执行函数时间大于间歇时间时，后一个间歇定时器在前一个调用结束之前调用。 (5)使用系统对话框由于系统对话框带来的用户体验相当差，现在用的很少，这里随便提一下123456789101112// 验证框与弹出框if (confirm(\"are you sure?\")) &#123; alert(\"baici\");&#125; else &#123; alert(\"shagua\");&#125;// 文本框var name = prompt(\"you name?\");alert(\"welcome \" + name);// 打开find,printfind();print(); // 打印对话框 使用 location 对象location对象是BOM最有用的对象之一，提供了文档有关的信息，还提供了一些导航功能。它是一个特别的对象，即是window属性，也是document属性，也就是说location,window.location,document.location是同一个东西。我们来试试它的功能。123456console.log(location.hash); // 无console.log(location.host); // localhost:4000console.log(location.href); // http://localhost:4000/console.log(location.port); // 4000console.log(location.protocol); // http:console.log(location.search); 使用 navigator对象使用 screen 对象用来识别客户端浏览器的，用处不大，表明客户端能力的。一般用于客户端能力检测 使用 history对象保存用户上网的历史记录。处于安全考虑，开发人员无法知道历史记录的具体的URL,但是可以通过go()方法在历史记录中任意跳转。这个方法只接受一个参数，正数前进，负数后退1234567// go方法前进后退history.go(-1);history.go(1);// 简写的两个方法history.back();history.forword();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"《JavaScript高级程序设计》读后记<七>：继承","slug":"t-book_js_007","date":"2015-12-06T05:33:12.000Z","updated":"2017-10-13T01:54:56.000Z","comments":true,"path":"2015/12/06/t-book_js_007/","link":"","permalink":"http://yoursite.com/2015/12/06/t-book_js_007/","excerpt":"","text":"上一篇博客，我深入理解了对象，可以通过一些方式来创建对象。而对于 OOP 来说，仅仅做到这些是不够的。我们学过 OOP 都知道，它有三大特性，继承，多态，封装。第一个就是继承，而 JS 却本身没有继承这一方法。所以我们需要通过 JS 其他的特性来实现继承。由于 JS 的函数是没有函数签名的。所以并不能做到“接口继承”，但是我们可以做到“实现继承”。 理解继承(1)原型链原型链是实现继承的主要方法，那么原型链到底是什么样的东西呢？上一篇博客我们重点分析了原型这一属性和对象。并且给出了一个图来说明它们之间的关系。回顾一些，下面给出之前的图img现在，我稍微改变一下原型属性的指向，我们让原型属性不指向它自己的原型对象，而是指向另一个函数的原型对象。如同所示，依次如此就构成了 原型链img各个函数之间通过原型对象构成一条链，所以称之为原型链，下面模拟一下这个过程123456789101112131415161718192021// 父类型function Person() &#123; this.prototype = true;&#125;Person.prototype.getPersonValue = function() &#123; return this.prototype;&#125;;// 子类型function SubPerson() &#123; this.subprototype = false;&#125;// 继承，子类型原型等于父类型实例SubPerson.prototype = new Person();SubPerson.prototype.getSubValue = function() &#123; return this.subprototype;&#125;;var subperson = new SubPerson();// 测试console.log(subperson.getPersonValue()); // trueconsole.log(subperson.getSubValue()); // false 由上可知，当我们的函数的原型属性等于另一个函数的实例时，我们就继承了它的原型属性和方法。同时我们仍然保留了自己原型属性和方法。 我们现在知道了使用原型链来实现继承，有了继承我们的 原型搜索机制也得到了扩展 搜索实例本身定义的属性 搜索实例原型 搜索继承的原型(多重继续) 搜索Object的原型(继承链顶端) 要注意的方面： 子类型给原型添加的方法要在父类型之后添加(无论是新添加还是重新) 通过原型链实现继承，不能通过对象字面量创建原型方法，这样会重写原型链 原型链的缺陷：缺陷一，原型链实现的继承，原型变成了另外一个类型的实例，原有的实例属性变成了原型属性1234567891011121314function Person() &#123; this.name = [\"suo\", \"yue\"];&#125;function SubPerson() &#123;&#125;// 继承SubPerson.prototype = new Person();// 实例var sub1 = new SubPerson();sub1.name.push(\"smile\");console.log(sub1.name); // (3) [\"suo\", \"yue\", \"smile\"]var sub2 = new SubPerson();console.log(sub2.name); // (3) [\"suo\", \"yue\", \"smile\"] 缺陷二，子类继承了父类，但是没法给父类传递参数。基于这些缺陷，单一的使用原型链继承不太实用，怎么去解决这些问题呢？ (2)构造函数上面两个缺陷是否有解决方法，结合我们之前学习的知识。我们思考一下，可以传参，而且不使用原型等于实例这种方法，怎么让子类型使用父类型的变量和方法呢呢？由此我们想到了之前学习的两个函数的方法，一个是apply()，一个是call()。它们可以将函数调用的其他函数绑定本函数的作用域和参数。现在我们来试试12345678910111213141516171819202122// 父类型function Person(name) &#123; this.name = [\"suo\", \"yue\"]; this.addName = function() &#123; this.name.push(name); &#125;&#125;// 子类型function SubPerson(name, gender) &#123; // 调用父类函数，并绑定子类函数和参数 Person.call(this, name); this.gender = gender;&#125;var subperson1 = new SubPerson(\"smile\", \"male\");var subperson2 = new SubPerson(\"cry\", \"female\");subperson1.addName();// testconsole.log(subperson1.name); // [\"suo\", \"yue\", \"smile\"]console.log(subperson2.name); // [\"suo\", \"yue\"] 同理单独使用构造函数实现继承也是不行的，共享属性和变量就谈不上了，所以我们还是结合它们两者的优势重新实现继承吧。这和创建对象的模式有着异曲同工之妙。 (3)组合继承结合以上我们来整合它们的技术，先上代码12345678910111213141516171819202122232425262728293031323334353637// 父类型function Person(name) &#123; this.name = name; this.nameGroup = [\"suo\", \"yue\"];&#125;// 父类型函数原型方法Person.prototype.getName = function() &#123; return this.name;&#125;;Person.prototype.addName = function() &#123; this.nameGroup.push(this.name);&#125;// 子类型function SubPerson(name, gender) &#123; // 构造继承，调用父类型函数并绑定作用域和参数 Person.call(this, name); this.gender = gender;&#125;// 原型链继承，子类型函数原型等于父类型实例SubPerson.prototype = new Person();// 修正构造属性SubPerson.prototype.constructor = SubPerson;// 子类型函数原型方法SubPerson.prototype.getGender = function() &#123; return this.gender;&#125;var subperson1 = new SubPerson(\"smile\", \"male\");var subperson2 = new SubPerson(\"cry\", \"female\");// testsubperson1.addName();console.log(subperson1.getName()); // smileconsole.log(subperson1.getGender()); // maleconsole.log(subperson1.nameGroup); // [\"suo\", \"yue\", \"\"]console.log(subperson2.getName()); // cryconsole.log(subperson2.getGender()); // femaleconsole.log(subperson2.nameGroup); // [\"suo\", \"yue\"] (4)原型式继承基于已有的对象创建新对象，同时还不必因此自定义类型，看看代码12345function object(o) &#123; function F() &#123;&#125; Person.prototype = o; return new F();&#125; 现在我们可能看不懂，但是结合原型链的思想，改变一下，或许就很明了了12345678910// person1是Person的实例function object(person1) &#123; function SubPerson() &#123;&#125; // 子类型的原型等于父类型的实例 SubPerson.prototype = person1; return new SubPerson;&#125;// testsubperson1 = object(person1); 咋一看这不就是将原型链的继承方法，用函数封装了一下吗。有啥区别确实原理都是样的。区别就在于，原型链方法是类型到类型。而原型式继承则直接是对象到对象。测试一下，到底可不可以继承到属性和方法1234567891011121314151617var person1 = &#123; name: \"suo\", nameGroup: [\"suo\", \"yue\"]; getName: function() &#123; return this.name; &#125;&#125;;// 继承方法function createObj(o) &#123; function P() &#123;&#125;; P.prototype = o; return new P();&#125;var subperson = createObj(person1);console.log(subperson.getName()); // suo 很明显当然是可以的，我们由此也想到了，这和复制一个对象有什么区别呢？当然是有区别的，本质来说，这种继承方法是一个 浅复制，虽然复制了对象的属性，但是引用型的属性仍然是共享的。验证一下12345var subperson1 = createObj(person1); var subperson2 = createObj(person1);subperson1.nameGroup.push(\"smile\");console.log(subperson2.nameGroup); // (3) [\"suo\", \"yue\", \"smile\"] ES 新增了一个Object.create()方法规范了这个原型式继承。只有一个参数的情况下两者效果是一样的。第二个参数是可选的，作用是可以设置属性特性。这和我们之前谈到的Object.defineProperties()是同等效果的。测试一下12345678910111213141516171819var person = &#123; name: \"suo\", age: 18&#125;;var subperson1 = Object.create(person, &#123; name: &#123; value: \"yue\", enumerable: false // 设置不可枚举 &#125;, gerder: &#123; value: \"male\" &#125;&#125;);console.log(subperson1.name + ',' + subperson1.gender); // male, undefined 说明不能自己增加属性for (prop in subperson1) &#123; console.log(prop); // age &#125; (5)寄生式继承寄生式继承与刚刚学习的原型式继承紧密相连，在原型式继承的基础上又封装了一道函数。直接上代码吧12345678910111213141516171819202122var person = &#123; name: \"suo\", mess: \"bye\"&#125;;// 原型式继承function creatObj(o) &#123; function P() &#123;&#125;; P.prototype = o; return new P();&#125;// 寄生式继承function createAnobj(o) &#123; var clone = createObj(o); clone.sayBye = function() &#123; return o.mess; &#125;; return clone;&#125;// 测试var anoperson = createAnobj(person);console.log(anoperson.name + ',' + anoperson.sayBye());// suo,bye 咋一看，这不就是在原型式的基础上加一个添加方法的函数吗。当然完全是，它还有另一个用途，如果对象不是自定义或者构造函数时，它也是有用的，随便举个例子12345678910var arr = [1, 2, 3];function createAnobj(o) &#123; var clone = o; // 原型式函数不是必须的 o.printFirst = function() &#123; console.log(o[0]); &#125; return clone;&#125;var arr2 = createAnobj(arr);arr.printFirst(); // 1 (6)寄生组合继承我们知道原型链与构造函数的组合模式是最常见的继承方式，但是它也有不足的地方。它们单独来将每次调用一次父类型，组合起来就是调用了两次父类型。我们现在有一种方法来解决这个问题，就是组合寄生继承模式。它的思路就是构造函数模式不变，不直接调用父类型函数，而是通过原型模式创建一个副本，然后让子类的原型等于这个副本。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 父类型function Person(name) &#123; this.name = name; this.nameGroup = [\"xiao\", \"ai\"];&#125;Person.prototype.getName = function() &#123; return this.name;&#125;Person.prototype.addName = function() &#123; this.nameGroup.push(this.name);&#125;// 子类型function SubPerson(name, gender) &#123; // 继承属性 Person.call(this, name); // 自己属性 this.gender = gender;&#125;// 原型式模式function createObj(o) &#123; function P() &#123;&#125; P.prototype = o; return new P();&#125;// 寄生模式function inheritPrototype(p, subp) &#123; // 创建对象，浅复制原型对象 var prototype = createObj(p.prototype); // 增强对象，修正构造函数 prototype.constructor = subp; // 指向对象，子类型指向创建并修正构造的父类型原型对象 subp.prototype = prototype;&#125;// 执行寄生模式inheritPrototype(Person, SubPerson);SubPerson.prototype.sayBye = function() &#123; console.log(\"bye\");&#125;// 测试var subperson1 = new SubPerson(\"suo\", \"male\");console.log(subperson1.getName()); // 父类型属性和方法console.log(subperson1);console.log(subperson1.gender); // 自己的属性subperson1.addName(); // 父类型的方法console.log(subperson1.nameGroup);subperson1.sayBye(); // 自己的方法var subperson2 = new SubPerson(\"yue\", \"female\");console.log(subperson2.nameGroup); // 输出// suo// male// bye// (3) [\"xiao\", \"ai\", \"suo\"]// (2) [\"xiao\", \"ai\"] 写到这里，只能感叹一句，寄生组合模式简直就是一个大杂烩啊。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"OOP","slug":"OOP","permalink":"http://yoursite.com/tags/OOP/"}]},{"title":"《JavaScript高级程序设计》读后记<六>：对象","slug":"t-book_js_006","date":"2015-12-05T04:43:11.000Z","updated":"2017-10-13T01:55:03.000Z","comments":true,"path":"2015/12/05/t-book_js_006/","link":"","permalink":"http://yoursite.com/2015/12/05/t-book_js_006/","excerpt":"","text":"上篇博客谈到了引用类型，array, function 等等。它们都有一个共同的特点就是，它们都继承于 object，它们都是对象，拥有属性和方法。我虽然搞清楚了它们的很多特性和方法，也可以用它们做一些事情。但是对象这个东西还是有很多东西是有些模糊的，这些天我看完了面向对象这一章。里面很多设计和 c++, Java 面向对象很相似，有共通的地方，但是也有很多地方是 JS 独有的特性。现在我整理出了一条思路，写下这篇博客，希望能更加透彻的理解面向对象的思想。 理解 JavaScript 面向对象前面已经接触过了很多对象，现在稍稍回顾一下，话不多说，上代码1234567891011121314151617// 直接new对象var person = new Object;person.name = \"suo\";person.getName = function() &#123; console.log(this.name);&#125;; person.getName(); // suod// 字面量创建对象var person1 = &#123; name: \"suo\", getName: function() &#123; console.log(this.name); &#125;&#125;; person.getName(); // suo 这两种创建对象的方法都是最初级的，第二个比一个好那么一点点在使用更高级的创建方法之前要讨论一下对象的属性 理解属性的特性ES5 定义了特性(attribute)，它是内部使用的，用来描述属性(property)的特征。这句话怎么解释呢？特性和属性，我们所知道的属性，就是对象的属性，方法。但是这些属性有一些特征，而把属性的特征称为特性。并且用两对方括号表示 [[Enumerable]] 下面具体谈谈这些属性的特性。分为两种特性，一种是数据特性，一种是访问器特性 [[Configurable]]: 能否删除而重新定义属性，能否修改属性特性 [[Enumerable]]: 能否通过 for-in 返回属性 [[Writable]]: 能否修改属性的值 [[Value]]: 包含属性的值 下面我们举个例子具体说明这些特性的意义123var person = &#123; name: \"suo\"&#125;; name是对象person的属性，[[Value]] 的值就应该是&quot;suo&quot;，其中name是可以删除和重新定义的。可以通过 for-in 返回属性，可以修改值，由此我们得出上面三个特性的默认值都是true 既然属性的特性有默认的值，那么是否可以修改呢，答案是可以的ES5 有一个方法可以修改属性的特性值Object.defineProperty()12345678var person = &#123;&#125;;Object.defineProperty(person, \"name\", &#123; writable: false, // 设置特性为不能修改 value: \"suo\" // 设置属性的值为\"suo\"&#125;);console.log(person.name); // suoperson.name = \"yue\"; // 严格模式下导致错误console.log(person.name); // suo 我们看到我们可以通过这个方法直接为属性设置值，同时设置了只读权限 现在我们知道属性的特性是可以重新定义和修改的，但是我们也知道特性里有一个 [[Configurable]] 可以控制是否可以修改特性，也就是设置Configurable为false，就不能再修改这个对象属性的特性了(除writable以外)，下面我们验证一下12345678910var person = &#123;&#125;;Object.defineProperty(person, \"name\", &#123; configurable: false, //设置不能删除属性，不能重新定义特性 value: \"suo\"&#125;);Object.defineProperty(person, \"name\", &#123; value: \"yue\" // 出错。不能重新定义特性&#125;);delete person.name; // 不起作用，严格模式报错console.log(person.name); 现在看看访问器特性，包含 getter 和 setter 函数，读取访问器属性调用 getter，写入调用 setter同样的访问器特性也是四个，其中前两个和数据特性一样，后两个如下 [[Get]]: 读取属性时调用的函数，默认值是undefined [[set]]: 写入属性时调用的函数，默认也是undefined 同样我们来看看代码12345678910111213141516171819// 假设suo是男生，yue是女生，当改变对象名字的时候，使得性别也改变var person = &#123; _name: \"suo\", // 只能通过对象方法访问 gender: \"male\"&#125;;Object.defineProperty(person, \"name\", &#123; get: function() &#123; return this._name; &#125;, set: function(name) &#123; if (name === \"yue\") &#123; this.gender = \"fel\" + this.gender; &#125; &#125;&#125;);person.name = \"yue\";console.log(person.gender); // female 说了这么多，那么使用这些特性有什么好处呢？get函数内只能读，set函数内只能写，这样就完美的实现了读写分离，支持这个方法的需要 IE9 以上上面用的都是单个属性的操作，也有可以一次操作多个属性的方法defineProperties()1234567891011121314151617181920212223242526272829var person = &#123; _name: \"suo\", gender: \"male\"&#125;;Object.defineProperties(person, &#123; _name: &#123; writable: false, value: \"yue\" &#125;, gender: &#123; writable: true, value: \"male\" &#125;, name: &#123; get: function() &#123; return this._name; &#125;, set: function(name) &#123; if (\"yue\" === this._name) &#123; this.gender = \"fe\" + this.gender; &#125; &#125; &#125;&#125;);person.name = \"yue\";console.log(person.gender); // female 这个方法使用的效果和上面单个方法别无二致，唯一不同的是，这些特性是同一时间创建的现在我们来读取这些特性，使用方法getOwnPropertyDescriptor12var descriptor = Object.getOwnPropertyDescriptor(person, \"_name\");console.log(descriptor.value); // yue 前面谈了那么多关于属性的特性，现在我们该进入正题了 创建对象的方法(1)工厂模式 考虑到ES没法创建类，所以就采用了函数封装特定的接口创建对象，下面直接上代码123456789101112// 工厂方法：批量生产对象function createPerson(name, gender) &#123; var o = new Object; o.name = name; o.gender = gender; o.getName = function() &#123; return o.name; &#125;; return o;&#125;var person1 = createPerson(\"suo\", \"male\");var person2 = createPerson(\"yue\", \"female\"); 这样写的好处就在于，本来需要单个创建的对象，通过函数的封装，可以批量的创建对象了。其实它是有缺点的，虽然解决了相似对象创建的问题，但是对象的识别没法解决。 (2)构造函数我们知道引用类型是通过原生的构造函数创建对象，其实构造函数是可以自定义的。所以我们现在可以通过自定义的方式来创建对象，上代码123456789function Person(name, gender) &#123; this.name = name; this.name = gender; this.getName = function() &#123; return this.name; &#125;;&#125;var person1 = new Person(\"suo\", \"male\");var person2 = new Person(\"yue\", \"female\"); 这种方式和工厂模式其实很相似，大家可能一看就知道了。它们之间有些稍稍不同的地方，这些其实很好解释，知道构造函数生成对象的过程，就很容易理解了，这两种方式其实是一个原理。构造函数，new 的过程: 创建一个新对象 将作用域给新对象 给对象添加属性 返回对象 现在也许大家都明白了，原来我们使用的工厂模式，其实就是在模拟构造函数生成对象的过程构造函数生成的对象都有一个 constructor 属性，它就是指向构造函数本身的12console.log(person1.constructor == Person); // trueconsole.log(person1 instanceof Person); // true 由此我们可以看出，构造函数相比工厂模式的好处就在于，它解决了对象的识别问题，我们可以通过这些方式来判断，这个对象到底是由哪个函数构造的。当然这种模式也是存在缺陷的，虽然我们利用工厂模式和构造函数，生产了很多对象。但是每生产一个对象，就要给对象里的属性和方法分配一块内存，然而对象的方法很多都是一样的。这样就导致了内存的大量的浪费，我们能否让这些方法共享呢？现在尝试独立这些共享方法12345678910function Person(name, gender) &#123; this.name = name; this.gender = gender; this.getName = getName;&#125;function getName() &#123; return this.name;&#125; // 独立方法var person1 = new Person(\"suo\", \"male\");console.log(person1.getName()); // suo 虽然这是可行的，但是污染了全局作用域。getName虽然是全局的，单真正确是用在构造函数里面。这在开发中是一种及其不好的做法。 (3)原型模式我们之前谈到函数类型，它都有一个 prototype 属性，当时没有过多的研究，现在可以好好探究一下了。首先这个属性是一个指针，指向一个对象，这个对象里面包含了所有实例共享的属性和方法。到这里你肯定明白了，原来这个原型属性就是为了解决构造函数无法共享属性和方法的啊。上代码1234567891011function Person() &#123;&#125;Person.prototype.name = \"suo\";Person.prototype.gender = \"male\";Person.prototype.getName = function() &#123; return this.name;&#125;;var person1 = new Person();var person2 = new Person();console.log(person1.getName()); //suoconsole.log(person2.getName()); //suo 很明显，原型对象的属性和方法，对于对象来说都是公有的，大家都一样。下面继续深挖一下原型对象这种东西，有助于之后学习的理解只要创建函数，就会有一个 prototype 属性，这个属性指向了函数的原型对象。默认情况下所有的原型对象都会获得一个 constructor 属性，这个 constructor 是一个指向这个 prototype 所在的函数的指针。这个关系有点微妙，我还是画个图说明一下吧代码验证一下12console.log(Person.prototype.constructor); // f Person()&#123;&#125;console.log(Person.prototype.constructor == Person); // true 其中我们可以通过isProtptypeOf()方法验证对象原型的对应关系1console.log(Person.prototype.isPrototypeOf(person1)); // true ES5新增了getPrototypeOf()方法来获取原型值1234567console.log(Object.getPrototypeOf(person1));// &#123; name: \"suo\", gender: \"male\", getName: ƒ, constructor: ƒ &#125;// gender: \"male\"// getName: ƒ ()name:\"suo\"// constructor: ƒ Person()// __proto__: Object 上面我们通过这个方法把原型的全部内容打印了出来，这些都清楚了是吧虽然可以通过对象访问原型的值，但是不能通过对象重写原型的值，这个原因很简单，因为我们知道，原型的属性和方法都是共享的，如果随便一个实例都能改动的话，原型就乱套了，改变一个原型的属性就会影响其他的实例。因此原型是不允许实例改变的。如果实例的属性名字与原型名字重名的话，它会屏蔽原型的属性。测试一下123456person1.name = \"yue\";console.log(person1.getName()); // yueconsole.log(person2.getName()); // suodelete person1.name; // 删除属性console.log(person1.getName()); // suo 我们现在知道了，实例的属性是可以和原型重名的，那么怎么判断它到底是谁的属性呢，hasOwnProperty()可以来检测这个属性到底是实例的还是原型的123456person1.name = \"yue\";console.log(person1.getName()); // yueconsole.log(person1.hasOwnProperty(\"name\")); // truedelete person1.name; // 删除属性console.log(person1.getName()); // suoconsole.log(person1.hasOwnProperty(\"name\")); // false 由此可知，true就是实例的，false就是原型的现在我们没那么严苛，我们想要判断该属性是否可以被实例访问到，这里就有in方法可以判断1234person1.name = \"yue\";console.log(\"name\" in person1); // truedelete person1.name;console.log(\"name\" in person1); // true 除此之外，如果我们还想得到所有实例的属性，也有种方法使用，for-in，当然有些不可枚举的属性是访问不到的。我们尝试去做一下123456for (prop in person1) &#123; console.log(prop);&#125;// name// gender// getName 我们发现没有 protptype 属性，原因是它都是不可枚举的，[[enumerable]] 为false除此之外我们还可以使用Object.keys()方法来枚举对象属性12console.log(Object.keys(Person.prototype));// (3) [\"name\", \"gender\", \"getName\"] 关于原型的写法，同样我们可以通过字面量来批量写原型属性，方法12345678910function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, // 构造函数还原 name: \"suo\", gender: \"male\", getName: function() &#123; return this.name; &#125;&#125;;var person1 = new Person(); 要注意的一点是，字面量本身也是一个对象，原型指向字面量后指针就跑歪了，所以要我们要让它重新指向函数。这种方式仍然有个问题就是，本身 prototype 属性是不可枚举的，现在把 constructor 加上去后，导致变成可枚举的了，现在属性的特性的知识就有用武之地了，我们可以直接设置它的特性为不可枚举的，那不就可以了吗。1234567891011121314function Person() &#123;&#125;Person.prototype = &#123; name: \"suo\", gender: \"male\", getName: function() &#123; return this.name; &#125;&#125;;var person1 = new Person();// 添加属性值并设置特性不可枚举Object.defineProperty(Person.prototype, \"constructor\", &#123; enumerable: false, value: Person &#125;); 我们之前谈到不能用实例修改原型，但是我们可以直接在原型上做修改啊，修改的原型后会对实例有什么影响呢？测试一下12Person.prototype.name = \"yue\";console.log(person1.name); // yue 由此我们可知，即使是先创建了实例，修改原型属性后，实例访问的原型属性也会修改，说明原型是动态的，这其实也很简单说明。实例和原型本身就不是绑定的，我们通过原型访问，是通过指针访问的。原型里的属性改变了，我们再次通过指针访问时，当然也是改变后的属性了。说了这么多，看起来原型挺好的，但是光有原型也是不够的，我们知道原型的方法和属性都是共享的，那么我私人的属性和方法该怎么办呢？那么为什么不把这两种模式结合起来呢？ (4)组合模式(构造+原型)结合构造和原型，我们来试着创建一个对象吧12345678910111213141516171819202122function Person(name, gender) &#123; this.name = name; this.gender = gender; &#125;Person.prototype = &#123; // constructor: Person, origin: \"monkey\", // 起源 getName: function() &#123; return this.name; &#125;&#125;;Object.defineProperty(Person.prototype, \"constructor\", &#123; enumerable: false, value: Person&#125;);var person1 = new Person(\"suo\", \"male\");var person2 = new Person(\"yue\", \"female\");console.log(person1.name === person2.name); // falseconsole.log(person1.origin === person2.origin); // true 我们使用图示来说明这个方式img (5)动态原型学过了其他 oop 语言，像c++，Java 都是用类封装所有的属性和方法，倒是觉得 ES 的比较奇怪了。现在就有一种方法来动态的创造原型，需要时才创建原型属性和方法123456789101112function Person(name, gender) &#123; this.name = name; this.gender = gender;&#125;if (typeof this.getName != \"function\") &#123; Person.prototype.getName = function() &#123; return this.name; &#125;;&#125;var person1 = new Person(\"suo\", \"male\");console.log(person1.getName()); // suo 只有当调用这个方法时，这个方法不存在，它才会被添加在原型里，使用动态模式不能用字面量方法给原型赋值，原因就是，它会将 constructor 导向新的对象，之前也遇到过。 (6)寄生构造一句话，使用构造函数的工厂模式创建对象123456789function Person(name, gender) &#123; var o = new Object; o.name = name; o.gender = gender; o.getName = function() &#123; return this.name; &#125; return o;&#125; 咋一看，这不就是在构造函数里再造一个工厂模式吗？到底有啥用其实这个寄生构造函数的用途，在于对原生的构造函数进行修改，重新造一个构造函数，比如下面1234567891011121314function SpecialArray() &#123; // 创建数组对象 var arr = new Array; // 添加参数 arr.push.apply(arr, arguments); // 添加方法 arr.toUpdateJoin = function() &#123; return this.join(\"|\"); &#125;; // 返回数组 return arr;&#125;var arr = new SpecialArray(\"suo\", \"yue\");console.log(arr.toUpdateJoin()); // suo|yue 这样就改造好了，把原来数组的连接改成了|。 (7)稳妥构造某个人发明了稳妥对象概念，什么是稳妥对象呢，它其实就是没有公共属性，不引用 this 对象。借鉴寄生构造函数，实现这个稳妥构造，上代码123456789function Person(name, gender) &#123; var o = new Object; o.getName = function() &#123; return name; //注意这里没this &#125;; return o;&#125;var person = new Person(\"suo\", \"male\");console.log(person.getName()); // suo 这种模式非常安全，里面没有公共属性和 this ，这样外界要访问到name，只能通过函数来访问了。写了这么多也差不多把面向对象搞清楚了一半，下一篇博客，专门研究面向对象里的 继承。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"OOP","slug":"OOP","permalink":"http://yoursite.com/tags/OOP/"}]},{"title":"《JavaScript高级程序设计》读后记<五>：引用类型","slug":"t-book_js_005","date":"2015-12-02T08:44:12.000Z","updated":"2017-10-13T01:48:19.000Z","comments":true,"path":"2015/12/02/t-book_js_005/","link":"","permalink":"http://yoursite.com/2015/12/02/t-book_js_005/","excerpt":"","text":"前几篇博客，谈到了变量有 2 类数据类型，5 种基本数据类型和引用数据类型。同时也阐述了基本数据类型和引用数据类型的区别。但是一直没有提到具体的引用类型，今天专门看了引用类型一章，发现里面涉及的内容还挺多的。一时难以记住全部的内容，所以在这里写一篇博客，留做以后的学习作参考。 理解引用类型引用类型的值(对象)是引用类型的实例，这和基本类型也是一样的，基本类型的值当然也是基本类型的实例。它们唯一的区别在于引用类型是一种数据结构，它的数据的组织更加复杂些。前面也提到过，对象的创建是用 new 方法创建的。这里的所有的引用类型都类似，可以用 new 方法创建。1var person = new Object; // 同样的括号可以省略 Object类型除了上面那种创建 object 方法外还有种方法，使用对象字面量来表示1234var person = &#123; name : \"suo\", gender : \"male\"&#125;; 除此之外还有另一个写法，就是空对象，后添加属性，这也是可以的123var person = &#123;&#125;;person.name = \"suo\";person.gender = \"male\"; 同时我们可以看到，object 访问属性是通过.来访问，其实也有另一种方法，通过[]来访问1234var person = &#123;&#125;;person[\"name\"] = \"suo\";person[\"gender\"] = \"male\";console.log(person[\"name\"]+','+person[\"gender\"]); // suo,male 那么问题来了，什么时候用.，什么时候用[]呢？[]表示法有个优点，就是他可以通过变量访问属性12345var person = &#123;&#125;;person[\"name\"] = \"suo\";person[\"gender\"] = \"male\";var suo = \"name\"; // 将属性字符串赋值给变量console.log(person[suo]+','+person[\"gender\"]); // suo,male 除此之外，都用.来表示，毕竟.表示更加方便简洁 Array类型上面提到了 object 类型，下面具体谈一下 array 类型。其实感觉他俩挺像的，为什么这么说呢？之前一段时间我一直在学习数据结构。真正的体会到了，很多看似不同的东西，其实在结构上是很相似的，甚至只是改进了一下数据的组织方式而已。我们可以想象一下object的数据结构12345&#123; key1 : value1, key2 : value2, ...&#125;; 其中value也可以是函数，对比一下数组的12345[ 0 : value1, 1 : value2, ...]; 其中数组中的下标是在字面量中省略的很明显，它们的数据结构都是线性的序列，区别在于两点1.object 的元素，可以是任意类型的。array 的一般是同一类类型的元素2.object 是关联容器结构，array 是顺序容器结构。array 是寻秩访问，object 是寻关键码访问。谈到了它们之间的区别与联系，现在具体说一下 array 吧创建 array 也是有两种方法，一种是 new ,一种是字面量。和 object 差别不大12345var arr = new Array; // 同理可省略for (var i = 0; i &lt; 10; i++) &#123; arr[i] = i + 1; console.log(arr[i]);&#125; // 1 2 3 4 5 6 7 8 9 10 省略括号表示创建一个空的数组，数组不仅可以创建空数组，还可以创建想要的形式的数组12var arr = new Array(3); // 创建包含三个元素的数组var arr1 = new Array(\"hello\"); // 创建包含一项元素\"hello\"的数组 另外一种方式是字面量的，这种方式创建数组更加灵活1234var arr = []; // 空数组var arr1 = [1, 2, 3, 4];var arr2 = [\"hello\", \"world\", \"!\"];var arr3 = [ , , ]; // 不建议使用，会生成undefined变量 数组的长度可以用 length 得到1234var arr1 = [1, 2, 3, 4];console.log(arr1.length); // 4arr1[arr1.length] = 5; // 添加一项console.log(arr1[4]); // 5 之前谈到可以用instanceof来检测数组，但是它只能在一个全局内检测。所以 ES5 新增了一个方法来检测数组。12var arr = [1, 2];console.log(Array.isArray(arr)); // true Array有很多类型的方法，我们先归一下类，以后再慢慢细究吧。(1)转换方法12345var colors = [\"red\", \"blue\", \"green\"];console.log(colors.toString()); // red,blue,greenconsole.log(colors.valueOf()); // red,blue,greenconsole.log(colors); // red,blue,greenconsole.log(colors.join(\"|\")); // red|blue|green (2)栈方法12345var colors = [\"red\", \"blue\", \"green\"];colors.push(\"yellow\")console.log(colors); // [\"red\", \"blue\", \"green\", \"yellow\"]colors.pop(); console.log(colors); // [\"red\", \"blue\", \"green\"] (3)队列方法1234567var colors = [\"red\", \"blue\", \"green\"];colors.push(\"yellow\", \"black\");var pop = colors.pop(); // black var head = colors.shift(); // redcolors.unshift(\"red\", \"black\")console.log(pop+','+head); console.log(colors); // [\"red\", \"black\", \"blue\", \"green\", \"yellow\"] (4)重排序方法1234567// 反转组项顺序var num = [1, 3, 2, 5, 4];num.reverse();console.log(num); // 4,5,2,3,1//升序排序num.sort();console.log(num); // 1,2,3,4,5 (5)操作方法123456789101112131415161718192021222324// 粘贴(新数组)var colors = [\"red\", \"blue\", \"green\"];var colors2 = colors.concat(\"yellow\", [\"black\", \"white\"]);console.log(colors2);// (6) [\"red\", \"blue\", \"green\", \"yellow\", \"black\", \"white\"]// 截切(新数组)var colors = [\"red\", \"blue\", \"green\"];var colors2 = colors.slice(1);var colors3 = colors.slice(0, 1); // 不包含1console.log(colors2); // [\"blue\", \"green\"]console.log(colors3); // [\"red\"]co// 替换(原数组上操作)var colors = [\"red\", \"blue\", \"green\"];colors.splice(1, 1);console.log(colors)colors.splice(1, 0, \"yellow\");console.log(colors)colors.splice(1, 1, \"black\");console.log(colors)//(2) [\"red\", \"green\"]//(3) [\"red\", \"yellow\", \"green\"]//(3) [\"red\", \"black\", \"green\"] (6)位置方法12345// 正向查找var num = [1, 3, 2, 5, 4]; console.log(num.indexOf(3)); // 1// 逆向查找console.log(num.lastIndexOf(3)); // 1 (7)迭代方法1234567891011121314151617181920212223242526// 每项都var num = [1, 3, 2, 5, 4];var res = num.every(function(item, index, array) &#123; return (item &gt; 2); &#125;);console.log(res); // false// 每项结果var res2 = num.filter(function(item, index, array) &#123; return (item &gt; 2) &#125;);console.log(res2); // [3, 5, 4]// 每项运行var res3 = num.forEach(function(item, index, array) &#123; num = num * 2; &#125;);console.log(res3);// 每次结果数组var res4 = num.map(function(item, index, array) &#123; return (item * 2) &#125;);console.log(res4);// 任一项var res5 = num.some(function(item, index, array)&#123; return (item &gt; 2); &#125;);console.log(res5); (8)归并方法123456789101112// 正向归并var num = [1, 3, 2, 5, 4];var sum = num.reduce(function(prev, cur, index, array)&#123; return prev + cur; &#125;);console.log(sum); // 15// 逆向归并var num = [1, 3, 2, 5, 4];var sum = num.reduceRight(function(prev, cur, index, array)&#123; return prev + cur; &#125;);console.log(sum); // 15 Date类型我们可能学习过 Java 中的 Date 类型，其实 ES 也是借鉴它构建的。使用的也是 UTC 来保存日期。保存的日期的范围为 1970.1.1 前后的 1 亿年。使用new创建12var now = new Date;console.log(now); // Sun Dec 02 2016 11:10:38 GMT+0800 (中国标准时间) 由此得知，Dete对象默认创建的是当前的时间，那怎么得到特定的时间呢?有两种方法：一种是Date.parse()，另一种是Date.UTC()12345var someDate = new Date(Date.parse(\"Nov 12, 1995\"));console.log(someDate); // Fri Nov 12 1995 00:00:00 GMT+0800 (中国标准时间)// 省略Date.parse也是可以的var someDate2 = new Date(\"Sep 22, 1996\");console.log(someDate2); // Sun Sep 22 1996 00:00:00 GMT+0800 (中国标准时间) 上面的方法返回的是日期对象，下面再测试一下Date.UTC()12345var someDate = new Date(Date.UTC(1995, 11, 12));console.log(someDate); // Sun Dec 12 1995 08:00:00 GMT+0800 (中国标准时间)// 省略var someDate2 = new Date(1995, 11, 12);console.log(someDate2); //Tue Dec 12 1995 00:00:00 GMT+0800 (中国标准时间) 由此我们得知，这两种方法都是可以自动调用的，调用哪一种方法取决于传入的参数。ES5新增了一种now()方法，可以取得当前时间的毫秒数，那么我们可以用它做一些有用的事1234567var start = Date.now();for (var i = 0; i&lt;1000000; i++) &#123; sum = i*2;&#125;var end = Date.now();var runtime = end - start;console.log(runtime); // 10(ms) 用+操作符也可以达到同等目的1var start = new +Date(); 因为时间本身是毫秒数，所有可以用&gt;或者&lt;比较日期123var date1 = new Date(2016, 2, 3);var date2 = new Date(2015, 3, 4);console.log(date1 &gt; date2); // true 格式化日期12345var date = new Date;console.log(date.toDateString()); // Sun Dec 02 2016console.log(date.toTimeString()); // 11:53:46 GMT+0800 (中国标准时间)console.log(date.toLocaleDateString()); // 2016/12/2console.log(date.toUTCString()); // Sun Dec 02 2016 11:53:46 GMT 日期组件方法，都是一些 get，set 方法，这里就不一一说了12var date = new Date;console.log(date.getTime()); // 1506830282288(ms) RegExp类型我学过 PHP 的正则表达式，学过 Java 的正则表达式，很有意思的是现在又学JS的正则表达式，相对来说容易很多了，除了调用的方法名有所不同以外，其他的内容几乎无差别首先创建一个正则表达式，同样是两种方式12var pat = new RegExp(\"pat\",\"flags\"); // new对象var pat = /pat/flags; // 字面量 稍微解释一些这个表达式的含义，/这个是表达式的定界符，就是隔离正则与其他字符的一个分界，为其他字符也可以，表达式后面的flags是一个标记，就是来切换正则表达式匹配规则的模式。常见的模式有 g 表示全局模式，i 不区分大小写，m 多行模式，举几个例子说明下1var pat = /suo/i; 解释一下，suo是正则法则，i 是模式，也就是匹配字符suo,且不区分大小写使用test来测试是否匹配上1234var pat = /suo/i;console.log(pat.test(\"Suo\")); // trueconsole.log(pat.test(\"SUO\")); // trueconsole.log(pat.test(\"sso\")); // false ES5 规定，使用字面量创建正则必须像直接调用 RegExp 构造函数一样，每次都要创建新的实例。下面我们来看看实例的属性和方法123456var pat = /suo/i;console.log(pat.global); // falseconsole.log(pat.ignoreCase); // trueconsole.log(pat.multiline); // falseconsole.log(pat.lastIndex); // 0console.log(pat.source); // suo 这些属性都是正则表达式本身具有的一些属性，没啥用，但是它的两个方法是我们要掌握的，第一个就是exec()它是用来捕获组的，1234567891011var pat = /suo/ig; // 全局模式var str = \"suo: I am Suoyue\";var matches = pat.exec(str);// 第一次捕获console.log(matches.index); // 0console.log(matches.input); // suo: I am suo yue\"console.log(matches[0]); // suo// 第二次捕获matches = pat.exec(str);console.log(matches.index); // 10console.log(matches[0]); // Suo 正如上面所说，每一次捕获都要创建实例，都要再执行一遍捕获方法另一种方法是test()方法，他是一个判断是否匹配，正如它的名字，只是测试而已123var pat = /suo/i;var str = \"suo: I am Suoyue\";console.log(pat.test(str)); // true 假设我现在捕获到了一个组，我们怎么取得我们想要的东西呢？答案是使用RegExp的构造函数属性12345678910var pat = /suo/ig;var str = \"ss suo: I am Suoyue\";if (pat.test(str)) &#123; console.log(RegExp.$_); // 最近一次要匹配的字符串 suo: I am Suoyue console.log(RegExp[\"$`\"]); // 最近匹配项前面的字符串 ss console.log(RegExp[\"$'\"]); // 最近匹配项后面的字符串 : I am Suoyue console.log(RegExp[\"$&amp;\"]); // 最近一次匹配项 suo console.log(RegExp[\"$+\"]); // 最近匹配的捕获组 [空] console.log(RegExp[\"$*\"]); // 是否使用多行模式 (未实现)&#125; 除了上面 6 个以外还有很多，不一一累述了虽 ES 正则表达式功能还是比较完备的，但是对于 PHP 和 Java 还是缺少很多高级特性，作为一个前端的脚本语言，这些已经足够了 Function类型前面我们一直提到函数，他是对象，它可以赋值给变量，它是 ES 中最小的作用域。但是一直我都没有具体研究它，现在我读了函数这章，很多之前的稍有疑问的地方，现在都豁然开朗了。 之前也说过，函数有两种表达方式，一种是使用函数声明，一种是使用函数表达式。我们稍微回顾一些这两种形式。12345678// 函数声明式function foo() &#123; //code...&#125;// 函数表达式var foo = function() &#123; //code...&#125;; 注意的是函数声明是会有函数声明提升的，之前也讲过，这里不在累述了。由上面可以看出，函数包含函数名，函数本体，也就是{}里面的内容 函数实际是对象，那么函数名实际上是一个指向函数对象的指针，不会与某个函数绑定这句话怎么理解呢？下面给出一个例子来说明这个问题1234567var foo = function() &#123; console.log(\"suo\");&#125;var boo = foo;foo = null;// 经测试foo解引用后，运行会出错boo(); // suo 由上面的代码可以看出，foo只是一个指向函数对象的指针，当使用解引用后，断绝了这个关系了。而boo又指向了函数对象，所以可以运行。 下面我们来探讨另一个问题，既然我们已经得出结论，函数名只是一个指向函数对象的指针。那函数就不应该有重载这个特性。因为同一个函数名是指向同一个函数对象的。就不会指向其他对象的说法下面我们也来例证一下12345678910var name = \"suo\";var gender = \"male\";var foo = function(name) &#123; console.log(name);&#125;var foo = function(name, gender) &#123; console.log(name+','+gender);&#125;foo(name); // suo,undefinedfoo(name, gender); // suo,male 由上可知，如果函数有重载的话，第一个foo执行的结果应该是suo，但是实际的结果确实suo，undefined。很显然第一个函数执行的也是第二个函数表达式。第二个表达式的函数覆盖了之前的。得出结论，函数重名会覆盖，不管参数是怎样的 上面也提到了函数是对象，那么函数就可以给其他变量赋值。不仅如此函数还可以作为返回值用。下面看一个例子12345678910111213141516171819// 比较人的身高var suo = &#123; height : 180&#125;;var yue = &#123; height : 170&#125;;function campareHeight(height) &#123; return (function(suo, yue) &#123; if (suo.height &gt; yue.height) &#123; return 1; &#125; else if (suo.height &lt; yue.height) &#123; return -1; &#125; else &#123; return 0; &#125; &#125;)(suo, yue);&#125;console.log(campareHeight(\"height\")); // 1 这里要提醒下，函数声明是不可以直接做返回值的，只有执行后的函数才能做返回值.一般这种情况我，使用立即执行函数一步来搞定，下面写一个立即执行函数的简单例子123456789// 声明与执行分步写function foo() &#123; return 1;&#125;console.log(foo()); // 1// 使用立即执行函数一步写console.log( (function()&#123; return 1; &#125;)() ); // 1 函数内部有两个特殊的对象：arguments 和 thisarguments 是一个类数组对象，包含传入函数的所以参数主要用来保存函数参数的，这个对象有一个叫 callee 的属性，它是一个指针，指向拥有这个 arguments 对象的函数。下面一个例子告诉我们caller的用法12345678function foo(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125;&#125;foo(10); // 3628800 其实这个就是 10 的阶乘。关键在于这行代码arguments.callee(num-1)，我们再仔细揣摩这句话，callee 的属性，它是一个指针，指向拥有这个 arguments 对象的函数，现在明白了arguments.callee(num-1)就等同于foo(num-1)，这样就清楚了。该说说 this 了，我看了半天书上的叙述，总结了一句话，当在哪个作用域调用函数时，该函数中的 this 就是哪个作用域对象下面验证下这句话的正确性1234567891011// 全局调用window.color = \"red\";var o = &#123; color: \"blue\"&#125;;function getColor() &#123; console.log(this.color);&#125;getColor(); // redo.getColor = getColor;o.getColor(); // blue 另一个是caller，表示调用当前函数的函数的引用，全局作用域为null，验证一下12345678function foo() &#123; boo();&#125;function boo() &#123; console.log(boo.caller); &#125;console.log(foo.caller); // nullfoo(); // ƒ foo() &#123; boo();&#125; 这里可以看到显示了 foo 的源码，下面用另一种方式实现这个效果(根据 callee 的用法好理解)12345678function foo() &#123; boo();&#125;function boo() &#123; console.log(arguments.callee.caller); &#125;console.log(foo.caller); // nullfoo(); // ƒ foo() &#123; boo();&#125; 这种写法虽然现在可以，但是出于安全性考虑，严格模式下已经不许这样做了，另外严格模式下函数的 caller 属性是不能赋值的 都说对象是有属性方法的，函数也不例外，下面谈谈函数的属性和方法吧函数有两个属性一个是 leghth，一个是 prototype ，前面一个是指希望接受参数个数，没什么好说的。关键在于这个 prototype 属性,这个属性是ES搞面向对象专门搞得一个属性，这里不谈太多了，下一篇博客研究对象和继承时。好好探究这个属性。这里就简单提几点，ES5 中，prototype 属性太多，是无法使用 for-in 枚举的。 下面我们聊聊,函数的两个独有的方法，说独有是因为它不是其他对象有的，因为它们关系到作用域。我们知道 ES 就只有函数作用域，所以这一切搜说得通了。这两个方法，一个是apply(),一个是call(),这两个函数有很多相似之处。1234567function foo(a, b) &#123; return a&gt;b;&#125;function callFoo(c, d) &#123; return foo.apply(this, arguments);&#125;callFoo(1, 2); // false 这里我的理解是，apply这个函数，是将 callFoo 的 this 对象和 arguments 传给了 foo，并执行结果返回给 callFoo，也可以不用自己的 arguments 对象，随意传一个数组也可以。因为 arguments 本身也是一个数组。如下12345678function foo(a, b) &#123; return a&gt;b;&#125;function callFoo(c, d) &#123; return foo.apply(this, [3, 2]); // 替换成自己的&#125;// 不写参数看看callFoo(); // true 果然是这样，证明我的理解是正确的。理解了 apply，call 也就好理解了，它们区别就在于参数，不同于 apply，一个作用域和一个参数数组。call 的参数要全部单独写出来。改变上面的代码，看看1234567function foo(a, b) &#123; return a&gt;b;&#125;function callFoo(c, d) &#123; return foo.call(this, 3, 2); // 参数数组变成单个参数&#125;callFoo(); // true 一切都在意料之中，果然是这样。说了这么这两个方法，它们有啥用呢？它们的真正用处在于扩充函数的作用域下面看一个例子你就明白了1234567891011window.color = \"red\";var o = &#123; color: \"blue\"&#125;;function getColor() &#123; console.log(this.color);&#125;getColor(); // redgetColor.call(this); // redgetColor.call(window); // redgetColor.call(o); // blue 这里你是否明白了呢，getColor本来是全局作用域，本应该是输出red，绑定o后，竟然可以输出对象的变量。这样做的最大好处是函数既访问到了对象的变量，而且和对象没有形成耦合关系。最后说一个 ES 方法bind()。下面看一下代码123456789window.color = \"red\";var o = &#123; color: \"blue\"&#125;;function getColor() &#123; console.log(this.color);&#125;var oGetColor = getColor.bind(o);oGetColor(); // blue 这个方法比call()更直接，直接实现函数对象绑定的值，并给一个新的函数。这个就牛逼了，具有call()的好处,并且更加直接，好理解。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"《JavaScript高级程序设计》读后记<四>：垃圾回收","slug":"t-book_js_004","date":"2015-11-29T07:22:15.000Z","updated":"2017-10-13T01:48:24.000Z","comments":true,"path":"2015/11/29/t-book_js_004/","link":"","permalink":"http://yoursite.com/2015/11/29/t-book_js_004/","excerpt":"","text":"上一篇博客里，阐明了闭包的概念和作用，但是它有个缺点就是容易造成内存泄露，为什么会造成内存泄露呢？内存泄露又是怎样产生的呢？这一切要从 JavaScript 的垃圾回收机制说起 理解JavaScript的垃圾回收机制JavaScript 具有自动垃圾回收机制，因此我们可以不必管它，但是也要知道它的原理。垃圾回收机制的原理：垃圾回收机制会周期性的释放不再使用的变量的内存。这里我们要知道两点：1.这个周期是多少？是如何决定的？2.如何判断这个变量不再继续使用？ 我们先来探究第二个问题，如何判断这个变量不再使用，并回收？我们知道，每一个变量都是有生命周期的，如果哪个变量没有的话，就会一直残留下去，总有一天会消耗完内存。这也叫内存泄露。下面我们分析下局部变量的正常生命周期局部变量只在函数执行过程中存在，函数执行结束后，局部变量就没有存在价值了，然后垃圾回收器给无用的局部变量标记。等回收周期到来的时候，回收这个变量。 标记变量有两种策略：一种是标记清除法，另一种是引用计数法这个标记清除法其实很简单解释，当变量进入环境时（变量声明），该变量就被标记为“进入环境”。当变量离开环境时（函数执行完），该变量就被标记为“离开环境”。而这些被标记成离开环境的变量就是无用变量，等着垃圾回收机制回收就可以了 第二个问题清楚了，我们看看第一个问题，垃圾回收机制的周期是多少？怎么决定的？从 IE 开始谈起，IE 垃圾回收器是根据内存分配量运行的，具体就是 256 个变量，4096 个对象字面量，数组元素，或者 64Kb 的字符串。达到上面任何一个临界值，垃圾回收器就开始运行。但是这样又出现了一个问题，如果一个脚本本来就有那么多变量，垃圾回收器就会一直的运行。每次回收完了又到达临界值，这样导致垃圾回收器频繁的调用，对性能来说是有很大影响的。 等到 IE7 的出现，重写了垃圾回收机制。固定的临界量改为了动态的分配。垃圾回收的内存分配量低于 15% 时，临界值就加倍。当内存分配量达 85% 时，临界时恢复为初始的值。简单的来说就是，内存够用时，就不急着回收。内存不够时，就和初始一样，达到就回收。这样一来，即便脚本中的变量很多，只要内存够用，也不会频繁的调用垃圾回收器了。 在 JavaScript 中虽然我们不必担心内存管理的问题，但是我们也需要保证页面的性能更好。这里我们可以去优化内存。优化内存最佳的方式就是，将无用数据，设置为null,来释放其引用，也就是解除引用。 下面我们来看一段代码12345678function createPerson(name) &#123; var localPerson = new Object; localPerson.name = name; return localPerson;&#125;var globalPerson = createPerson(\"suo\");// 解除引用globalPerson = null; 这里我们可以知道的是localPerson是局部的变量，所以垃圾回收器会自动为它解除引用但是globalPerson是全局变量，如果不需要用了，垃圾回收机制不会干，现在我们手动为它解除引用。解除引用之后，它不会立即销毁，只是脱离了执行环境，等待垃圾回收器来回收。 说了这么多，搞清楚了垃圾回收机制。上一篇博客中谈到闭包的缺点，闭包会造成内存泄露。清楚了垃圾回收机制，我们可以知道的是，闭包访问的变量是无法被垃圾回收器回收的。那么我们该怎么办了。恰好刚刚就有种方法。我们可以手动来解除引用。这样就避免了闭包产生的内存泄露了。下面给出闭包和解除引用的实例123456789function assignHadler() &#123; var element = document.getElementById(\"div\"); var id = element.id; element.onclick = function() &#123; alert(id); &#125;; // 解除引用 element = null;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"《JavaScript高级程序设计》读后记<三>：闭包","slug":"t-book_js_003","date":"2015-11-28T03:28:15.000Z","updated":"2017-10-13T01:48:27.000Z","comments":true,"path":"2015/11/28/t-book_js_003/","link":"","permalink":"http://yoursite.com/2015/11/28/t-book_js_003/","excerpt":"","text":"在上一篇博客里，谈到了作用域，留下了一个问题，怎样从函数外访问到函数内部的局部变量。这是在我完全理解闭包和函数后，写的一篇博客。 理解函数与闭包前面我们知道了作用域最小单位就是函数，那么函数是怎么表示的呢？定义函数有两种方式：一种是函数声明，另一种是函数表达式。1234// 函数声明function foo(arg0, arg1, arg2) &#123; // code...&#125; 我们知道函数也是一种引用类型，所以函数，也有自己的属性，其中一个就是name1console.log(foo.name); // foo 由此我们也更加确定了，函数也是一个对象，里面包含各种属性和方法对于函数还有一个特别的性质，那就是函数声明提升，如同变量声明提升，函数声明也是可以提升的1234sayBye(); // bye byefunction sayBye() &#123; alert(\"bye bye\");&#125; 函数声明提升会带来一个问题123456789101112// 反例var a = 1;if (a &gt; 1) &#123; function saybye() &#123; // code... &#125;&#125;else (a &lt; 1) &#123; function saybye() &#123; // code... &#125;&#125; 上面的代码，很容易看出来，函数声明提升后，可能产生和预期不一样的效果接下来我们看下函数表达式123var foo = function(arg0, arg1, arg2) &#123; //code..&#125;; 这个表达式怎么解释呢？就如一个赋值语句一样，将后面的匿名函数赋值给foo变量，有人可能有疑问，函数也可以赋值吗？在 js 里面来说，这是可以的，因为 js 里面函数也是一种引用类型，当作对象赋值给变量 那么函数表达式是否也有函数提升呢？下面验证一下1234foo(); // VM225:1 Uncaught TypeError: foo is not a functionvar foo = function() &#123; alert(\"ok\");&#125;; 答案是没有，函数并没有提升上去，因为在这里函数作为了对象赋值给了变量，并不是声明，这里的赋值同样的也是引用赋值。此时foo指向的是堆中的内存块。 谈谈闭包闭包是有权访问另一个函数作用域中的变量的函数，创建闭包的常见方式，就是在一个函数内部创建另一个函数1234567// 要访问foo中的afunction foo() &#123; var a1 = 1;&#125;foo();console.log(a1);// VM309:4 Uncaught ReferenceError: a1 is not defined 显然访问不了123456789// 使用闭包函数访问function foo() &#123; var a2 = 2; var b = function() &#123; console.log(a2); &#125; return b();&#125;foo(); // 2 下面解释一下是怎么做到的a2是foo的局部变量，而是b函数的外部变量，而b是可以访问到的，b函数在闭包函数b返回到外部的函数或全局变量12345678// 改写成立即执行函数function foo() &#123; var a3 = 3; return (function() &#123; console.log(a3); &#125;)();&#125;foo(); // 3 将b函数改写成立即执行函数更加清晰紧凑了，相当于函数里面将一个执行的函数返回到外部去就好像在函数内外构建了一个桥梁。闭包有闭包的好处，但是它也有不少缺陷闭包会携带包含它的函数的作用域，因此比其他函数占用更多的内存，过度的使用闭包可能会导致内存占用过多闭包的限制与解除，闭包只能取得包含函数中的任何变量的最后一个值，闭包保存的是整个变量对象，而不是某个特殊的变量下面我们来看看代码12345678910function foo() &#123; var arr = new Array; for (var i=0; i&lt;10; i++) &#123; arr[i] = function() &#123; return i; &#125; &#125; return arr;&#125;alert(foo()); 谈到闭包的缺点，必须要说的一个东西就是 Js 的垃圾回收机制，下篇博客，我将重点研究关于 JS 的垃圾回收机制，","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"《JavaScript高级程序设计》读后记<二>：作用域","slug":"t-book_js_002","date":"2015-11-27T13:18:03.000Z","updated":"2018-06-30T16:32:57.260Z","comments":true,"path":"2015/11/27/t-book_js_002/","link":"","permalink":"http://yoursite.com/2015/11/27/t-book_js_002/","excerpt":"","text":"在第一篇博客里面，提到过变量是松散变量，决定它只是特定时间保持特定的值的符号而已，而变量的值和数据类型可以在脚本的生命周期内改变的。接下来就是理解这种特性的性质了。 理解引用类型，作用域前面我们已经知道了，ES 变量类型包括 5 种基本类型和引用类型。 基本类型与引用类型的区别？ 基本类型值在内存中占据固定大小的空间，保存在栈中，引用类型的值是对象，被保存在堆中 这 5 种基本类型可以按值访问的，而引用类型的值是按引用访问 基本类型的变量包含的是实际的值，引用对象实际包含的并不是对象本身而是指向对象的指针。 这里要解释一下什么是按值访问？什么是按引用访问？如果学过 C++ ,我们就会知道 C++ 传参有两种方式，一种是传值，一种是传引用。 这两种方式有什么区别呢？区别在于传值是将实参拷贝给形参，而传引用并不是简单的赋值，而是将形参与实参绑定在一起，它们同时指向同一内存空间，修改形参相当于修改实参。引用相当于变量的别名，理解这句话。我们可能大致知道什么是按值访问，什么是按引用访问了 那么，为什么基本类型是按值访问？而引用类型是按引用访问？我们知道引用类型不同于基本类型，它不是单纯的值，而是一种数据结构，包含有属性和方法。如果按值传递，会拷贝整个对象，这样消耗的空间是否太大了呢，所以ES将这些对象的访问都设置成了按引用访问。 刚才我们提到了，c++的值拷贝方式和引用拷贝方式，JS是否也是这样的呢？的确，JS也是这样的，下面简单的验证一下1234// 基本类型的拷贝var a = \"hello\";var b = a;console.log(a+','+b); // hello,hello 12345// 引用类型的拷贝var obj = new Objcet();var obj1 = obj2;obj.name = \"hello\";console.log(obj.name+','+obj1.name); // hello,hello 因此我们可以看到，对象obj1是随obj变化的，他们是指向同一个内存块的，而不是简单的拷贝而已 那么传参是否也是在我们的意料之中呢？然而并不是这样的，ES 中所有函数的参数都是按值传递的，基本类型值的传递就像复制一样而引用类型的值的传递，就行引用类型的变量复制一样，为什么会这样呢？这里我们重点看一下传递引用参数123456function setName(obj) &#123; obj.name = \"suo\";&#125;var person = new Object;setName(person);console.log(person.name); // suo 由上可知，对象传递后，通过函数修改对象属性影响了全局变量的值在这里有人可能会觉得，函数传的是引用并非是值吧其实 ES 中所有的函数都是按值传递，并非引用传递，有人肯定会有疑问为什么obj会被改变呢其实这里说的按值传递有点特殊，这个值恰好是指向内存的指针，与引用传递的不同在于，并没有，形参并没有和实参进行引用绑定接下来进一步验证一下12345678function setName(obj) &#123; obj.name = \"suo\"; obj = new Object; obj.name = \"yue\";&#125;var person = new Object;setName(person);console.log(person.name); // suo 上面代码的意义是什么呢？我们在函数内重新定义了这个对象，并给了它一个属性而执行后，结果person并没有和obj的属性一样，也就是说obj并不是person的引用，仅仅是它的地址的值等于person的地址而已 我们已经知道了ES有引用类型和基本类型，而且typeof操作符可以检测基本类型的类型那么我们怎样检测引用类型呢？其实也有个操作符可以利用，不过它只能判断是或者不是，不能直接得出是什么类型下面我们测试一下几个引用类型检测12var person = new Object;console.log(person instanceof Object); 刚刚看到了，函数通过传值的形式来传参现在思考一下，函数是怎么执行的呢？原来每个函数都有执行环境，每个执行环境都有与之对应的变量对象，环境中所有的对象和函数都保存在这个对象中。代码在一个环境中执行时，会创建变量对象的作用域链，作用域链控制执行环境访问变量和函数的顺序和权限。下面先看一段代码123456789var color = \"red\";function changeColor() &#123; if (color === \"red\") color = \"yellow\"; else color = \"green\";&#125;changeColor();console.log(color); // yellow 可知，函数执行时可以访问到外部的变量，这里的作用域包括两个对象：自己的对象，全局环境的对象进一步研究，多层函数套用，执行是怎样的呢？1234567891011var color = \"blue\";function changeColor() &#123; var anotherColor = \"red\"; function swapColors() &#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; // 都能访问 &#125; // 只能访问color,anothor swapColor();&#125; // 只能访问colorchangeColor(); 可以看出作用域链是由内而外的，也就是说函数是从当前的环境对象向外搜索变量，直至到全局对象。函数可以访问外部的变量，但是无法访问当前环境下函数里的局部变量。用更确切的话说，ES 的作用域链是单向的，而这个方向是由里向外的访问原则。下面画一个图式来说明这个问题现在问题来了，既然作用域是单向访问，有没有办法访问到由外访问到里面的局部变量呢？答案是有的，下节谈一下闭包，这个特性能很好的解决这个问题。还有一点要说明的是,JS 没有块级作用域，不同域 c 语言，花括号括起来的都有作用域，JS 只有函数作用域下面用代码解释下12345678910111213#include &lt;stdio.h&gt;int main(void) &#123; &#123; int b = 0; &#125; for (int a=0; a&lt;10; a++) &#123; b++; // 出错 &#125; printf(\"%d,%d\", &amp;a, &amp;b); return 0;&#125;// error: 'b' was not declared in this scope,b++;// error: 'a' was not declared in this scope 12345678&#123; var b = 0;&#125;for (var a=0; a&lt;10; a++) &#123; b++;&#125;console.log(a+','+b);// 10,10 根据上面的运行结果，我们很容易看到 C 中花括号的是单独的作用域，其他作用域是访问不到的，for循环里的变量，循环结束后，也不会保留而 JS 里的不一样，他们虽然有花括号，但是这个花括号如同形式一般，没特别的意义，与去掉花括号是同样的意义。 JS 是通过函数作用域，来实现作用域链，控制访问顺序和权限。所有它的最小执行的单元就是函数。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"《JavaScript高级程序设计》读后记<一>：数据类型","slug":"t-book_js_001","date":"2015-11-27T00:25:46.000Z","updated":"2017-10-13T01:48:40.000Z","comments":true,"path":"2015/11/27/t-book_js_001/","link":"","permalink":"http://yoursite.com/2015/11/27/t-book_js_001/","excerpt":"","text":"经过一段时间的学习，深感 JavaScript 知识点还是挺多。之前一直是看视频教程和博客学习 JavaScript 。但是总觉得缺点什么，不管是视频还是博客，它们强调的始终是单一的知识或者是技术点。并没有对整个语言有一个更加全面的概述。基于这些学习上的不足，我向师哥师姐们询问到了这方面的问题，于是乎他们向我推荐了这本书，《JavaScript高级程序设计》第三版。无奈由于时间原因，一直放在书桌上搁置了好一段时间。就在近几天我终于有机会专心看这本书了。经过一个星期的学习，感觉大有收获，所以写下这篇博客，记录学习中的偏向于重点知识的理解和体会。 理解变量与数据类型1.ES的变量是松散变量，也就是说每一个变量仅仅是用于保存一个值的占位符，它可以保存任何值。变量未声明或未初始化之前的值是undefined,定义之后的值是赋给它的任何值。到这里就一个小疑问，通常我们学习其他语言都会有，一个值和类型相对应，那么问题来了，undefind是值那么它的类型又是啥呢？做个简单的例子测试一下看看123var a; alert(a); // undefinedalert(typeof a); // undefined 原来值为undefined的类型也是undefined。由此我们可能会想到另外一个值，那就是null,是不是nUll的类型也是null呢？123var a = null; // nullalert(a); // objectalert(typeof a); null的类型竟然是object，估计有不少人会大跌眼镜吧，为啥会这样？凭什么？其实这是正确的，JavaScript的null被认为是空对象的引用这里还要解释下什么是空对象的引用？简单的说就是一个变量本该保存一个对象，但是还没有保存对象，这个时候就应该把这个变量来保存null，显示的表示这个变量是一个空对象的变量。 2.undefined和null又有哪些区别和联系呢？首先说联系undefined其实是null派生出来的，在代码层上表现为12alert(undefined == null); // truealert(undefined === null); // false 第2个为false好说，至少是他们类型是不一致的。第一个为什么为true呢？原来这个==符是类似相等符，不是绝对相等，null和undefined的值是类似的。区别上面也很容易看出来 用途不一致：null用于空对象指针，给还没对象的变量赋值。undefined是来区别变量的未初始化或声明的。 常用于：null常用与显示的赋值变量，undefined不会这么做. 3.基本类型ES 中有 5 种简单数据类型和一种复杂数据类型，分别为undefined，null，boolean，number，string，object。其中object实质是一组无序名值对组成的。具体理解的是object这一类型。通过执行new来创建对象12var o = new Object();var o = new Object; // 都可以 object的每一个实例下面都有属性和方法 constructor:创建当前对象的函数，对于上面就是Object()这个构造函数 hasOwnProperty(propertyName):检查属性在当前对象中是否存在 isProtptypeOf(object):检查属性是否是当前对象原型 propertIsEnumerable(propertypeName):检查对象是否可以用for-in来枚举 toLocaleString():返回对象字符串表示，与执行环境对应 toString():返回对象字符串表示 valueOf():返回对象的字符串，数值，布尔值表示要具体理解这些函数和属性，需要后面面向对象的思想做铺垫。ES 中 Object 是所有对象的基础。因此所有对象都具有这些基本的属性和方法。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"关于 this 的两种误解","slug":"note-this","date":"2015-10-25T10:25:43.000Z","updated":"2019-06-14T06:48:56.408Z","comments":true,"path":"2015/10/25/note-this/","link":"","permalink":"http://yoursite.com/2015/10/25/note-this/","excerpt":"","text":"this两种误解 误解1 this 指向函数本身 对象内部引用自身 具名函数可以实现、匿名就不好实现了 弃用的方法：arguments.callee 解决方法1 foo函数名 代替 this 1234567function foo() &#123; foo.count++&#125;foo.count = 0foo()console.log(foo.count) // 1 解决方法2 强制 this 指向 foo 12345678function foo1() &#123; this.count++&#125;foo1.count = 0foo1.call(foo1)console.log(foo1.count) 误解2 this 指向函数作用域 this 任何情况下都不指向函数词法作用域 this 无法跨越词法作用域边界 this 到底是什么?this 的绑定和函数的声明位置没有任何关系，只取决于函数的调用方式 函数的调用位置 分析调用栈 1234567891011121314151617// 调用链相关function foo() &#123; // global bar()&#125;function bar &#123; // global foo baz()&#125;function baz() &#123; // global foo bar&#125;foo() 严格模式下，全局对象无法绑定 隐式调用 绑定对象内部 12345678910function foo() &#123; console.log(this.a)&#125;var obj = &#123; a: 1, foo: foo&#125;obj.foo() // 1 只有最顶层有效 123456789101112131415function foo() &#123; console.log(this.a)&#125;var obj = &#123; a: 40, obj2: obj2&#125;var obj2 = &#123; a: 3, foo: foo&#125;obj.obj2.foo() // 42 隐式丢失 1234567891011function foo() &#123; console.log(this.a)&#125;var obj = &#123; a: 10, foo: foo&#125;var bar = obj.foovar a = 'global'obj.foo() 隐式 传参丢失 12345678910111213function foo() &#123; console.log(this.a)&#125;function bar(fn) &#123; fn()&#125;var obj = &#123; a: 1, foo: foo&#125; var a = 2console.log(bar(obj.foo)) 显式绑定 123456789function foo() &#123; console.log(this.a)&#125;var obj = &#123; a: 1&#125;foo.call(obj) // 1 无法解决隐式丢失问题 解决方法1: 硬绑定 12345678910111213function foo() &#123; console.log(this.a)&#125;var obj = &#123; a: 1&#125;var bar = function() &#123; foo.call(obj)&#125;bar() // 1 New 调用 优先级 new &gt; 显示调用 &gt; 隐式调用 &gt; 调用栈","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES5","slug":"ES5","permalink":"http://yoursite.com/tags/ES5/"}]},{"title":"CSS 水平垂直居中的6种常用方法","slug":"t-blog_css_001","date":"2015-10-25T10:25:43.000Z","updated":"2019-02-26T06:01:04.774Z","comments":true,"path":"2015/10/25/t-blog_css_001/","link":"","permalink":"http://yoursite.com/2015/10/25/t-blog_css_001/","excerpt":"","text":"学了前端之后，也应该有一些收获了，现在写一些简单 demo， 练下手 前端布局中最常见的就是居中问题，由于浏览器的兼容性不一致，单一的居中方法会有很多缺陷即使如此，还是有方法解决这些问题的。这里我总结了最常见的 6 种居中的方法，每种方法都在不同的浏览器下测试过。下面给出具体的代码。 水平垂直居中的 6 种常用方法HTML 模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;水平垂直居中&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"center.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 绝对定位法 --&gt;&lt;div class=\"demo1\"&gt; &lt;div class=\"absolute-center\"&gt;demo1&lt;/div&gt;&lt;/div&gt;&lt;!-- 负外边距法 --&gt;&lt;div class=\"demo2\"&gt; &lt;div class=\"negative-center\"&gt;demo2&lt;/div&gt;&lt;/div&gt;&lt;!-- transform法 --&gt;&lt;div class=\"demo3\"&gt; &lt;div class=\"transform-center\"&gt;demo3&lt;/div&gt;&lt;/div&gt;&lt;!-- table-cell --&gt;&lt;div class=\"demo4\"&gt; &lt;div class=\"table-cell\"&gt; &lt;div class=\"block-center\"&gt; demo4 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- inline-block法 --&gt;&lt;div class=\"demo5\"&gt; &lt;div class=\"inline-center\"&gt; demo5 &lt;/div&gt;&lt;/div&gt;&lt;!-- flexbox法 --&gt;&lt;div class=\"demo6\"&gt; &lt;div class=\"flexbox-center\"&gt; demo6 &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS 布局先写一个基本的样式1234567891011121314151617/*容器*/.demo1, .demo2, .demo3, .demo4, .demo5, .demo6 &#123; margin: 0 auto; position: relative; height: 500px; width: 500px; border: 1px black solid;&#125;/*样式*/.absolute-center, .negative-center, .transform-center, .block-center, .inline-center, .flexbox-center &#123; height: 200px; width: 200px; padding: 20px; background: #eee; line-height: 200px; text-align: center;&#125; 1.绝对定位法12345678910/*绝对定位法*/.absolute-center &#123; position: absolute; margin: auto; overflow: auto; top: 0; right: 0; bottom: 0; left: 0;&#125; 2.负外边距法 12345678/*负外边距*/.negative-center &#123; position: absolute; top: 50%; left: 50%; margin-left: -110px; margin-top: -110px;&#125; 3.tranfrom法 12345678910/*tranfrom法*/.transform-center &#123; position: absolute; margin: auto; top: 50%; left: 50%; -webkit-transform: translate(-50%, -50%); -ms-transform: translate(-50%, -50%); transform: translate(-50%, -50%);&#125; 4.table-cess法1234567891011/*table-cell*/.demo4 &#123; display: table;&#125;.table-cell &#123; display: table-cell; vertical-align: middle;&#125;.block-center &#123; margin: 0 auto;&#125; 5.inline-block法1234567891011121314151617/*inline-block*/.demo5 &#123; text-align: center; overflow: auto;&#125;.demo5:after, .inline-center &#123; display: inline-block; verticel: middle;&#125;.demo5:after &#123; content: ''; height: 50%; margin-left: -0.25em;&#125;.inline-center &#123; max-width: 99%;&#125; 6.flexbox法1234567891011121314151617181920212223242526272829303132/*flexbox法*/.demo6 &#123; display: -webkit-box; /* OLD: */ display: -moz-box; /* OLD: Firefox (buggy) */ display: -ms-flexbox; /* MID: IE 10 */ display: -webkit-flex; /* NEW, Chrome 21–28, Safari 6.1+ */ display: flex; /* NEW: IE11, */ -webkit-box-align: center; -moz-box-align: center; /* OLD… */ -ms-flex-align: center; /* You know the drill now… */ -webkit-align-items: center; align-items: center; -webkit-box-pack: center; -moz-box-pack: center; -ms-flex-pack: center; -webkit-justify-content: center; justify-content: center;&#125;.flexbox &#123; display: -webkit-box; display: -moz-box; display: -ms-flexbox; display: -webkit-flex; display: flex; -webkit-box-align: center; -moz-box-align: center; -ms-flex-align: center; -webkit-align-items: center; align-items: center;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"垂直居中","slug":"垂直居中","permalink":"http://yoursite.com/tags/垂直居中/"}]},{"title":"《CSS权威指南》读后记<三>：浮动与定位","slug":"t-book_css_003","date":"2015-10-23T11:55:47.000Z","updated":"2017-10-13T01:54:15.000Z","comments":true,"path":"2015/10/23/t-book_css_003/","link":"","permalink":"http://yoursite.com/2015/10/23/t-book_css_003/","excerpt":"","text":"上一段时间学了盒子模型，盒子模型虽然弄清楚了，对于制作页面来说还是一点小懵懂的地方，那就是布局。怎样布局才算是好的布局，才能轻松的高效的还原设计稿。学了这章后，对于一般页面的布局没什么太大问题了。现在记下一点笔记，以后查漏补缺。 浮动（float）浮动元素脱离了文档流，浮动元素与周围外边距不会合并。浮动元素会生成一个块框1.浮动规则 左右不能超过父级块边界 浮同一父元素下的浮动动元素之间不能相互覆盖 顶端不能超过父元素顶端 顶端不能比之前所有元素顶端高 空间不足，浮动元素将被挤到新行 负外边距可以使浮动元素跑到父元素外边 2.重叠规则 行内框重叠时，边框，背景，内容显示在浮动元素之上 块框重叠时，显示在浮动元素之下 实现浮动12p &#123;float: left;&#125;.slect &#123;float: right;&#125; 清除浮动1234&lt;!-- 清除h1左边的浮动 --&gt;h1 &#123;clear: left;&#125;&lt;!-- 清除两边的浮动 --&gt;h1 &#123;clear: both;&#125; 定位（position)属性偏移高度宽度溢出剪裁可见性绝对定位Z轴放置固定定位相对定位","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"盒子模型","slug":"盒子模型","permalink":"http://yoursite.com/tags/盒子模型/"}]},{"title":"《CSS权威指南》读后记<二>：盒子模型","slug":"t-book_css_002","date":"2015-10-20T12:06:44.000Z","updated":"2017-10-13T01:53:59.000Z","comments":true,"path":"2015/10/20/t-book_css_002/","link":"","permalink":"http://yoursite.com/2015/10/20/t-book_css_002/","excerpt":"","text":"之前一直在使用 height 和 width，但是经常会遇到问题。在看了 盒子模型这一章后，很多东西迎刃而解了。现在详细的记录这些知识点。 盒子模型由四个部分组成，如下图img 内容高度与宽度决定内容大小1p &#123;height: 100px; width: 100px;&#125; 外边距边框外部1234567891011121314151617h1 &#123;margin: 0.25in; background-color: red;&#125;&lt;!-- 可以接受px,em,cm单位 --&gt;&lt;!-- 单独设置 --&gt;h1 &#123;margin: 10px 20px 15px 10px;&#125;&lt;!-- top right bottom left 可以混合单位--&gt;&lt;!-- 缺值规则 --&gt;&lt;!-- 缺左外，使用右外，缺下使用上，缺右使用上 --&gt;h1 &#123;margin: 10px 0;&#125;&lt;!-- 10px 0 10px 0 --&gt;&lt;!-- 单边外设置 --&gt;h1 &#123;margin-lelf: 10px;&#125;&lt;!-- 负外边距 --&gt;h1 &#123;margin-left: -10px;&#125; 边框外边距与内边距之间12345678910111213141516171819202122&lt;!-- 默认为none --&gt;&lt;!-- border-style的值很多 --&gt;&lt;!-- none,hidden,dotted,dashed,solid,double,groove,ridge,... --&gt;&lt;!-- 可以定义多样式 --&gt;p.new &#123;border-style: solid;&#125;p.new &#123;border-top-style: solid;&#125;p.new &#123;border-style: solid dashed none;&#125;&lt;!-- 边框宽度 --&gt;p.new &#123;border-width: 1px;&#125;p.new &#123;border-top-width: 2px;&#125;p.new &#123;border-width: 2px 1px 3px 2px;&#125;&lt;!-- 边框颜色 --&gt;p.new &#123;border-color: #666;&#125;p.new &#123;border-top-color: #666;&#125;p.new &#123;border-color: #666 #344 #333 #455;&#125;&lt;!-- 简写属性 --&gt;p.new &#123;border: 3px solid #666&#125;&lt;!-- 顺序不重要 --&gt; 内边距边框与内容之间1234&lt;!-- 同理margin --&gt;p.new &#123;padding: 10px;&#125;p.new &#123;padding-top: 20px;&#125;p.new &#123;padding: 10px 20px 30px 40px;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"《CSS权威指南》读后记<一>：选择器","slug":"t-book_css_001","date":"2015-10-15T10:25:43.000Z","updated":"2017-10-13T01:47:07.000Z","comments":true,"path":"2015/10/15/t-book_css_001/","link":"","permalink":"http://yoursite.com/2015/10/15/t-book_css_001/","excerpt":"","text":"最初接触网页制作是用的微软的 frontPage。只是为了给朋友搭建一个许嵩的主题网站，完成一个小小的课外作业，意外的拿到了不错的分数。虽然并没有用代码取写网页，但是制作的过程也是很有趣的。现在出于某种兴趣对网页制作进行了学习，才发现原来以前玩儿式的制作，现在写代码也可以弄出来，而且更加好看，标准。学习完 HTML 后，开始学习 CSS，现在读了这本 《 CSS 权威指南》第三版，感觉收益匪浅，所以记下里面重要的内容以便以后学习之用。 CSS选择器首先写一个大致的 html 页面做模板12345678910111213141516171819202122232425262728293031323334&lt;!doctype&gt;&lt;html&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"selector.css\"&gt; &lt;head&gt; &lt;title&gt;suo的个人网页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;锁的生活日志&lt;/h1&gt; &lt;h2&gt;今天是个好日子&lt;/h2&gt; &lt;h3&gt;哈哈&lt;/h3&gt; &lt;h4&gt;呵呵&lt;/h4&gt; &lt;h5&gt;嘻嘻&lt;/h5&gt; &lt;h6&gt;吼吼&lt;/h6&gt; &lt;p&gt;最初接触网页制作是用的微软的 pagefont。只是为了给朋友搭建一个许嵩的主题网站，完成一个小小的课外作业，意外的拿到了不错的分数。&lt;/p&gt; &lt;p&gt;虽然并没有用代码取写网页，但是制作的过程也是很有趣的。现在出于某种兴趣对网页制作进行了学习，才发现原来以前玩儿式的制作，现在写代码也可以弄出来，而且更加好看，标准。&lt;/p&gt; &lt;p&gt;学习完 HTML 后，开始学习 CSS，现在读了这本《CSS权威指南》第三版，感觉收益匪浅，所以记下里面重要的内容以便以后学习之用。&lt;/p&gt; &lt;p class=\"cselect\"&gt;类选择器&lt;/p&gt; &lt;p class=\"cselect1 cselect2\"&gt;多类选择器&lt;/p&gt; &lt;ul&gt; &lt;li&gt;1.what&lt;/li&gt; &lt;li&gt;2.how&lt;/li&gt; &lt;li&gt;3.why&lt;/li&gt; &lt;/ul&gt; &lt;a href=\"www.baidu.com\" class=\"visited\"&gt;百度&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 使用 css 选择器12h1 &#123;color: red;&#125;h2 &#123;font: 20px;&#125; 元素选择器123html &#123;color: black;&#125;h1 &#123;color: green;&#125;h2 &#123;color: red;&#125; 1.选择器分组12h1, h2, h3, h4, h5, h6 &#123;color: red;&#125;h1, h3, h5 &#123;backgroud: green;&#125; 2.通配选择器1* &#123;color: red;&#125; 3.声明分组12h1, h3, h5 &#123;color: red; background: green;&#125;h2, h4, h5 &#123;color: red&#125;; 类选择器与 ID 选择器1234&lt;!-- 特定 --&gt;p.cselect &#123;font-weight: bold;&#125; &lt;!-- 通用 --&gt;.cselect &#123;color: red;&#125; 1.多类选择器123&lt;!-- 顺序不限 --&gt;.cselect1.cselect2 &#123;color: grey;&#125;p.cselect1.cselect2 &#123;color: black;&#125; 2.id 选择器123p#idselect &#123;color: yellow;&#125;&lt;!-- 忽略 --&gt;#idselect &#123;color: yellow;&#125; 3.类选择器与 ID 选择器的选择 ID 选择器只能用一次，类选择器可以多次 ID 选择器不能结合使用，不能有空格来定义不同属性 它们都区分大小写 属性选择器12&lt;!-- 现在p中有class的全变红色 --&gt;p[class] &#123;color: red;&#125; 1.多属性选择1p[class][id] &#123;color: red;&#125; 2.值属性选择12p[class=\"cselect\"] &#123;color: red;&#125;a[href=\"www.baidu.com\"] &#123;color:black;&#125; 3.部分值属性选择1p[class~=\"cselect\"] &#123;color: red;&#125; 4.子串匹配属性选择器123456&lt;!-- 开头包含串 --&gt;p[class^=\"cs\"] &#123;color； red;&#125;&lt;!-- 结尾包含 --&gt;p[class$=\"select\"] &#123;color:red;&#125;&lt;!-- 包含即可 --&gt;p[class*=\"ele\"] &#123;color: red;&#125; 5.特定属性选择器1*[lang|=\"en\"] &#123;color: red;&#125; 后代选择器123ul li &#123;color: red;&#125;ul li a img &#123;height: 100px;&#125;.cselect a, #idselect a &#123;color: red;&#125; 如上所示，默认的后代选择器，可以忽略层次，选择 ul 下面所有的 li，并不只是直属的1.选择子元素1ul &gt; li &#123;color: red;&#125; 选择的是 ul 下直属的 li2.选择兄弟元素1p + .cselect &#123;color:red;&#125; 选择的是相同父亲下，紧邻的下一个元素 伪类和伪元素选择器12&lt;!-- a.visited &#123;color: red;&#125; --&gt;a:visited &#123;color: red;&#125; 1.链接伪类选择器123a:link &#123;color: blue;&#125;&lt;!-- 已访问 --&gt;a:visited &#123;color: red;&#125; 2.动态伪类选择器123456&lt;!-- 输入聚集时 --&gt;input:focus &#123;background: silver; font-weight: bold;&#125;&lt;!-- 鼠标停留时 --&gt;a:hover &#123;color: red;&#125;&lt;!-- 用户激活时 --&gt;a:active &#123;color: green;&#125; 3.伪元素选择器123456789&lt;!-- 只能用于块元素 --&gt;&lt;!-- 首字母 --&gt;p:first-letter &#123;color: red;&#125;&lt;!-- 首行 --&gt;p:first-line &#123;color: red;&#125;&lt;!-- 之前 --&gt;p:before &#123;color: red;&#125;&lt;!-- 之后 --&gt;p:after &#123;color:red;&#125; 权重计算css权重越大优先级越高123456&lt;!-- 一等：行内样式：1000 --&gt;&lt;!-- 二等：id选择器：100 --&gt;&lt;!-- 三等：类选择器，伪类，属性：10 --&gt;&lt;!-- 四等：类型选择器，伪元素选择器：1 --&gt;.cselect #idselect div p[name=\"suo\"] &#123;color: red;&#125;&lt;!-- 10 + 100 + 1 + 11 = 122 --&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"《数据结构》笔记：归纳","slug":"t-course_ds_010","date":"2015-10-10T14:22:06.000Z","updated":"2017-10-04T10:05:41.000Z","comments":true,"path":"2015/10/10/t-course_ds_010/","link":"","permalink":"http://yoursite.com/2015/10/10/t-course_ds_010/","excerpt":"","text":"数据结构(Data Structure) 数组(Array)：物理上紧邻的定长线性序列（元素为数） 向量(Vector)：物理上紧邻的一组不定长线性序列（元素不限） 列表(List)：逻辑上紧邻的一组线性序列 栈(Stack)：受限的列表（一端出入） 队列(Queue)：受限的列表（一端出一端入） 树(Tree)：成树结构的半线性序列 图(Graph)：成图结构的非线性序列 STL序列容器(Sequence Contains) 定长数组(Array) 向量(Vector) 列表(双向链表)(List) 单链表(sList)：非标准STL 双端队列(Deque) 栈(Stack) 队列(Queue) STL关联容器(Associative Contains) 红黑树(Red-Black Tree) 集合(Set) 映射(Map) 扩展集合(mutiMap) 扩展映射(mutiSet) 哈希表(HashTable) 哈希集合(HashSet) 哈希映射(HashMap) 哈希集合扩展(mutiHashSet) 哈希映射扩展(mutiHashMap) 排序查找搜索 排序(Sort) 起泡排序 选择排序 归并排序 插入排序 堆排序 桶排序 基数排序 快速排序 希尔排序 查找(Find) 扫描查找 二分查找 fib查找 搜索(Search) 广度搜索 深度搜索","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"《数据结构》笔记：排序","slug":"t-course_ds_009","date":"2015-09-18T03:53:01.000Z","updated":"2017-10-04T10:06:18.000Z","comments":true,"path":"2015/09/18/t-course_ds_009/","link":"","permalink":"http://yoursite.com/2015/09/18/t-course_ds_009/","excerpt":"","text":"快速排序(QuickSort) 分而治之 将序列分为2个子序列:S = Sl = Sr //O(n) 规模独立：max { |Sl| , |Sr| } &lt; n 彼此独立：max( Sl ) &lt;= min( Sr ) 在子序列分别递归底排序之后，原序列自然有序sorted(S) = sorted(Sl) + sorted(Sr) 平凡解：只剩单个元素时，本身就是解 归并排序在于合，quicksort在于分 轴点(pivot) 左/右侧的元素，均不比它更大/小 以轴点为届，原序列的划分自然实现：[lo, hi) = [lo,mi) + [mi] + (mi,hi) 123456template &lt;typename T&gt; void Verctor&lt;T&gt;::quickSort( Rank lo, Rank hi) &#123; if( hi - lo &lt; 2) return 0; //平凡解 Rank mi = partition( lo, hi-1 ); //先构造轴点 quickSort(lo, mi); //前缀排序 quickSort(mi+1, hi); //后缀排序&#125; 坏消息：在原始序列中，轴点未必存在 必要条件：轴点必然已然就位 特别的：在有序序列中，所有元素逐个转换成轴00点2 不变性与单调性：L &lt;= pivot &lt;= G; U = [lo, hi],[lo]和[hi]交替空闲 实例： 123456789轴点为66 3 8 2 5 9 4 5 1 7x 3 8 2 5 9 4 5 1 71 3 8 2 5 9 4 5 x 71 3 x 2 5 9 4 5 8 71 3 5 2 5 9 4 x 8 71 3 5 2 5 x 4 9 8 71 3 5 2 5 4 x 9 8 71 3 5 2 5 4 6 9 8 7 性能 不稳定 空间：只需要O(1) 时间：不能保证划分的均衡性，最好O(nlogn)，最坏O(n^2) 采取随机选取，三者取中，只能降低最坏的情况，而无法根本的杜绝 总结：平均性能O(nlogn),根据均匀独立分布为例，准确的1.39logn 快排变种 不变性：四个部分S = [lo] + L(lo, mi] + G(mi, k) + U[k, hi], L &lt; pivot &lt;= G 单调性：K不小于轴 ? 直接拓展G ： G滚动后移，L拓展 pivot &lt;= S[k] ? k++ : swap(S[++mi], S[k++]) 代码 12345678910template &lt;typename T&gt; Rank Vector&lt;T&gt;::partition( Rank lo, Rank hi) &#123; swap( _elem[ lo ], _elem[ lo + rand() % ( hi - lo + 1 ) ] );//随机交换 T pivot = _elem[ lo ]; int mi = lo; for ( int k = lo + 1; k &lt;= hi; k++ ) //自左向右考查每个[k] if( _elem[ k ] &lt; pivot ) //若k小于轴点，则将其与[mi]交换，L向右扩展 swap( _elem[ ++mi ], _elem[ k ]); swap( _elem[ lo ], _elem[ mi ] ); //候选抽点归位 return mi;//返回轴点的秩&#125; 实例123456789101112136 3 8 1 5 9 8 4 5 7 26 3 8 1 5 9 8 4 5 7 26 3 1 5 8 9 8 4 5 7 26 3 1 5 8 9 8 4 5 7 26 3 1 5 8 9 8 4 5 7 26 3 1 5 4 9 8 8 5 7 26 3 1 5 4 5 9 8 8 7 26 3 1 5 4 5 9 8 8 7 26 3 1 5 4 5 2 8 9 7 82 3 1 5 4 5 6 8 9 7 8//时间O(n)//空间O(1)//不稳定 选取 k-selection：在任意大小的元素中，如何由小到大，找到次序为k者，亦即 median：长度为n中选择位于中间的那个数 majoerity：无序向量，若有一半以上元素同为m，称之为众数 平凡算法 排序+扫描，必要性，众数存在必为中位数 事实上，只要能够找到中位数，就能判断是否为众数 众数若存在，则必为频繁数 策略：减而治之","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"《数据结构》笔记：词典","slug":"t-course_ds_008","date":"2015-09-15T02:52:04.000Z","updated":"2017-10-04T10:06:13.000Z","comments":true,"path":"2015/09/15/t-course_ds_008/","link":"","permalink":"http://yoursite.com/2015/09/15/t-course_ds_008/","excerpt":"","text":"散列(Hash) 新的访问方式 123寻秩访问：向量寻位置：列表寻关键码：BST 访问方式：寻值访问 电话 原理 桶Bucket：直接存放或者间接指向一个词条 桶数组Bucket array/散列表 Hash Table 容量为M 1N &lt; M &lt;&lt; R 空间 = O(N + M) = O(n) 定址/杂凑/散列：根据Key直接确定散列表入口 散列函数：hash() : key -&gt; &amp; entry 12345678hash(key) = key % M25K / 90K &gt; 25% 节约了较大空间装填因子 N / M 6278 5001 54304 395146277 0211 % 90001 39514 513045154 1876 51304 54304 冲突：不同关键码，被映射到同一实体上 12345153 1976 % 90001 513046278 2001理论上无法彻底避免，只能根据策略减少冲突hash 不可能是单射 散列策略：近似的单射，往往可行 精心设计散列表和散列函数，尽可能降低冲突的概率 制定可行的预案，以便排解 散列函数 评价标准：什么样hash()更好 确定determinism：同一关键码总是被映射至同一地址 快速efficency：expected-O(1) 满射surjection:尽可能充分的覆盖整个散列空间 均匀uniformity：关键码映射到散列表各位置的概率尽量接近可有效避免聚集clustering现象 除余法 1hash(key) = key % M 表长为素数时，分布更均匀，更全面 gcd(S, M) = G ，M取素数 缺陷：不动点hash(0) = 0，零阶均匀，相邻关键码散列地址必相邻 MAD法： 12M为素数，a &gt; 0, b &gt; 0, a % M !=0hash( key ) = ( a * key + b ) % M 数字分析法 平方取中法：平方后取中间数 1hash( key ) = key^2 取中间位数 折叠法：将key分隔为等宽的若干端，取其总和作为地址 位异或法。。。。 总结：越是随机越是没有规律越好 伪随机数法： 123456随机数发生器循环 rand( x + 1 ) = a * rand( x ) % Mx = time()伪随机数法hash( key ) = rand( key ) = [ rand(0) * a^key ] % M种子 rand(0) 多项式法： 1hash( s = X0X1X2...Xn-1) = X0a^n-1 + X1a^n-2+... Xn-1 排解冲突","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"《数据结构》笔记：二叉搜索树","slug":"t-course_ds_007","date":"2015-09-10T01:13:04.000Z","updated":"2017-10-04T10:06:09.000Z","comments":true,"path":"2015/09/10/t-course_ds_007/","link":"","permalink":"http://yoursite.com/2015/09/10/t-course_ds_007/","excerpt":"","text":"概述 循关键码访问call by key： 关键码之间可以比较，比对 词条entity： key - value 比较器：重载操纵符实现 判等器：重载操纵符实现 Binary Search Tree: 节点 ~ 词条 ~ 关键码， 处处满足顺序性 顺序性：任意节点均不小于左后代，不大于右后代 单调性：中序遍历，必然单调非降，充要性 宏微观：微观满足顺序性，宏观满足单调性 123456789101112template &lt;typename T&gt; class BST: public public BinTree&lt;T&gt; &#123; public: //二叉树派生 virtual BinNodePosi(T) &amp; search( const T &amp;) ; //查找 virtual BinNodePosi(T) insert( const T &amp;) ; //插入 virtual bool remove( const T &amp;) ; //删除 protected: BinNodePosi(T) _hot; //命中节点的父亲 BinNodePosi(T) connect34(BinNodePosi(T), BinNodePosi(T), //3+4重构 BinNodePosi(T), BinNodePosi(T), BinNodePosi(T), BinNodePosi(T), BinNodePosi(T)); BinNodePosi(T) rotateAt( BinNodePosi(T) ); //旋转&#125; 查找 策略：减而治之，仿照二分查找策略 12345678910template &lt;typename T&gt; BinNodePosi(T) &amp; BST&lt;T&gt;::search(const T &amp; e) &#123; return searchIn( _root, e, _hot = NULL) ;&#125;//典型的尾递归，当前树根目标关键码，记忆热点static BinNodePosi(T) &amp; searchIn(BinNodePosi(T) &amp; v, const T &amp; e, BinNodePosi(T) &amp; hot ) &#123; if( !v || (e == v-&gt;data) ) //确定失败，成功，或者 return v; hot = v; //记下当前节点，然后。。 return searchIn( ( (e &lt; v-&gt;data ) ? v-&gt;lchild : v-&gt;rchild ) , e, hot);&#125; //运行时间正比于返回节点的深度 接口语义：返回值的引用值 成功时，指向一个关键码为e且真实存在的节点, 失败时，指向试图转向的空节点NULL 增加哨兵，失败时，将此空节点转换为一个关键码为e且真实存在的节点 插入 策略：在查找的基础上替换失败的空节点 12345678910//BST插入template &lt;typename T&gt; BinNodePosi(T) BST&lt;T&gt;:: insert(const T &amp; e) &#123; BinNodePosi(T) &amp; x = search( e ); //查找目标 if( !x ) &#123; //禁止雷同，失败时才插入操作 x = new BinNode&lt;T&gt;(e, _hot); //创建新节点以hot为父亲 _size++; updataHeightAbove(x); //更新全树规模，并更新历代祖先规模 &#125; return x; //无论e是否存在原树中，总有x-&gt;data == e&#125; //总体复杂度O(h) 删除 策略：先确认目标再删除 12345678template &lt;typename T&gt; bool BST&lt;T&gt;:: remove( const T &amp; e) &#123; BinNodePosi(T) &amp; x = search( e ); //定位目标 if(!x) return false; //确认目标存在 removeAt(x , _hot); //分两大类实施 删除 _size--; //更新规模 updataHeightAbove( _hot ); return true;&#125; //复杂度O(h) 情况一 12345678910111213template &lt;typename T&gt; static BinNodePosi(T) removeAt(BinNodePosi(T) &amp; x, BinNodePosi(T) &amp; hot)&#123; BinNodePosi(T) w = x; //实际被摘除的节点 BinNodePosi(T) succ = NULL; //实际被删除的节点的接替者 if( ! HasLchild(*x) ) succ = x = x-&gt;rchild; //左子树为空 else if( ! HasRchild(*x) ) succ = x = x-&gt;lchild; //右子树为空 else &#123; //左右并存的状况 hot = w-&gt;parent; if( succ ) succ-&gt;parent = hot; release( w-&gt;data ); //释放被摘除的节点 release( w ); return succ; 返回接替者 &#125;&#125; 情况二 123456789101112template &lt;typename T&gt; static BinNodePosi(T) removeAt( BinNodePosi(T) &amp;x, BinNodePosi(T) &amp; hot ) &#123; BinNodePosi(T) w = x; //实际被摘除的节点 BinNodePosi(T) succ = NULL; //实际被删除的节点的接替者 if( ! HasLchild(*x) ) succ = x = x-&gt;rchild; //左子树为空 else if( ! HasRchild(*x) ) succ = x = x-&gt;lchild; //右子树为空 else &#123; w = w-&gt;succ; swap( x-&gt;data, w-&gt;data); BinNodePosi(T) u = w-&gt;parent; ( u == x ? u-&gt;rChild : u-&gt;lChild ) = succ = w-&gt;rChild; &#125;//O(h)&#125; 平衡与等价 BST的查找，插入，删除复杂度都为O(h)，但是高度不能很好控制，效率并不理想 生成BST：随机生成的高度为O(logn)，有重复的组合，随机组合的BST生成的O(n^1/2) 理想平衡：节点数固定，兄弟子树高度越接近(平衡)，全树倾向更低 由n个节点组成的二叉树，高度不低于logn时—–恰为logn为理想平衡树，概率低，适当降低标准 退一步海阔天空：高度渐进不超过O(logn) 适度平衡的二叉树，称平衡二叉树BBST 非平衡二叉树等价平衡二叉树 中序遍历的歧义性：拓扑结构不同，中序遍历相同 等价BST：3个规律，上下可变，左右不能乱，旋转变换 zig变换（旋转调整） 准则：局部性（常数节点数），操作数至多O(logn) AVL树(适度平衡搜索二叉树) 平衡因子：balFac(V) = height( lc(v) ) - height( rc(v) ) G.Adelson-Velsky &amp; E.Landis (1962) 所有 | balFac | &lt;= 1 AVL = 适度平衡：高度为h的AVL树，至少包含S(h) = fib(h+3) -1个节点 接口： 12345678#define Balance(x) ( stature( (x).lChild ) == stature( (x).rChild ) )#define BalFac(x) ( stature( (x).lChild ) - stature( (x).rChild ) )#define AvlBalanced(x) ( ( -2 &lt; BalFac(x) ) &amp;&amp; ( BalFac(x) &lt; 2 ) )template &lt;typename T&gt; class AVL: public BST&lt;T&gt; &#123; public: BinNodePosi(T) insert( const T &amp;); //插入重写 bool remove( const T &amp;); //删除重写&#125; 插入节点会导致祖先发生失衡，删除后只有一个节点失衡，相反插入操作更简单 插入：单旋 ，g经过单旋后复衡，子树高度复原，更高祖先也必平衡，全树复衡 时间：旋转O(1) 一致向右zagzag，一致向左zigzig，双旋，zigzag和zagzig情况 123456789101112131415//插入template &lt;typename T&gt; BinNodePosi(T) AVL&lt;T&gt;::insert( const T &amp; e) &#123; BinNodePosi(T) &amp; x = search( e ); if( x ) return x; x = new BinNode&lt;T&gt;( e, _hot ); _size++; BinNodePosi(T) xx = x; for ( BinNodePosi(T) g = x-&gt;parenr; g; g = g-&gt;parent ) if ( !AvlBalanced( *g ) ) &#123; FromParentIo( *g ) = rotateAt( tallerChild( tallerChild(g) ) ); break; &#125;else updateHeight( g ); return xx;&#125;","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"《数据结构》笔记：图","slug":"t-course_ds_006","date":"2015-08-30T07:58:33.000Z","updated":"2017-10-04T10:06:04.000Z","comments":true,"path":"2015/08/30/t-course_ds_006/","link":"","permalink":"http://yoursite.com/2015/08/30/t-course_ds_006/","excerpt":"","text":"概述 邻接：邻接关系，顶点与顶点的关系 关联：关联关系，顶点与边的关系 无向图：次序无所谓 有向图（digraph）：有次序，起点尾（tail），终点头 （head） 路径(path)：一系列的顶点按照依次邻接的关系构成序列 简单路径：不含重复节点的路径 环路(cicle)：起点终点重合的路径 无环路(DAG)：不包含任何环路的图 欧哈路：覆盖所有的点 哈密尔顿：覆盖所有点，每个顶点有且仅经过一次 邻接矩阵（adjacency matrix） 接口 123456789101112131415template &lt;typename Tv, typename Te&gt; class Graph &#123; private: void reset() &#123; for (int i = 0; i &lt; n; ++i)&#123; //顶点 status(i) = UNDISCOVERED; dTime(i) = fTime(i) = -1; parent(i) = -1; priority(i) = INT_MAX; for (int j = 0; j &lt; n; j++) //边 if (exists(i, j)) status(i, j) = UNDETERMINED; &#125; &#125; public: &#125;; 顶点的实现（Vertex）：邻接矩阵 12345678910111213typedef enum &#123; UNDISCOVERED, DISCOVERED, VISITED&#125; VStatus;template &lt;typename Tv&gt; struct Vertex &#123; Tc data; //数据 int inDegree, outDegree; //入度出度 VStatus status; //状态 int dTime, fTime; //时间标签 int parent; //父节点 int priority; //优先级 Vertex( Tv const &amp; d) : //构造初始化新顶点 data(d), inDegree(0), outDegree(0), status(UNDISCOVERED), dTime(-1), fTime(-1), priority(INT_MAX) &#123;&#125;&#125;; 边的实现（Edge）： 1234567typedef enum &#123; UNDETERMINED, TREE, CROSS, FORWORD, BACKWAED &#125; EStatus;template &lt;typename Te&gt; struct Edge &#123; Te data; //数据 int weight; //权重 EStatus status; //类型 Edge( Te const &amp; d, int w ):data(d), weight(w), status(UNDETERMINED) &#123;&#125; &#125;; 图的实现(GraphMatrix)：利用向量和邻接矩阵实现，适用稠密图，效率高 123456789101112template &lt;typename Te, typename Tv&gt; class GraphMatrix : public Graph&lt;Tv, Te&gt; &#123; private: Vector&lt; Vertex&lt;Tv&gt; &gt; V; //顶点集 Vector&lt; Vector&lt; Edge&lt;Te&gt;* &gt; &gt; E; //边集 public: GraphMatrix() &#123; n = e = 0;&#125; ~GraphMatrix() &#123; for (int j = 0; j &lt; n; ++j) for (int k = 0; k &lt; n; ++k) delete E[j][k]; &#125;&#125;; 顶点操作 1234567891011121314151617181920212223242526272829303132333435363738//顶点操作 Tv &amp; Vertex(int i) &#123; return V[i].data &#125;//...//枚举邻接顶点，逆序查找int NextNbr(int i, int j) &#123; while ( (-1 &lt; j) &amp;&amp; !exists(i, --j) ) ; return j;&#125;int firstNbr(int i) &#123; return NextNbr(i, n);&#125;//顶点插入int insert(Tv const &amp; vertex) &#123; for (int i = 0; i &lt; n; ++i) E[j].insert(NULL); n++; E.insert( Vector&lt; Edge&lt;Te&gt;* &gt;( n, n, NULL) ); return V.insert( Vertex&lt;Tv&gt;(vertex) ); &#125;//顶点删除Tv remove(int i) &#123; for (int i = 0; i &lt; n; ++i) if(exists(i, j))&#123; delete E[i][j]; V[j].inDegree--; &#125; E.remove(i); n--; for (int j = 0; j &lt; n; j++) if ( exists(j ,i) )&#123; delete E[j].remove(i); V[j].outDegree--; &#125; Tv vBak = vertex(i); V.remove(i); return vBak;&#125; 边操作 123456789101112131415161718192021222324252627//边操作bool exists(int i, int j) &#123; return (0 &lt;= i) &amp;&amp; (i &lt; n) &amp;&amp; (0 &lt;= j) &amp;&amp; (j &lt; n) &amp;&amp; E[i][j] != NULL;&#125;Te &amp; edge(int i, int j) &#123; return E[i][j]-&gt;data;&#125;//...//边插入void insert( Te const&amp; edge, int w, int i, int j) &#123; if( exists(i, j) ) return ; //忽略已有的边 E[i][j] = new Edge&lt;Te&gt;(edge, w); //创建新边 e++; //更新信息 V[i].outDegree++; V[i].inDegree++;&#125;//边删除Te remove(int i, int j) &#123; Te eBak = edge(i, j); delete E[i][j]; E[i][j] = NULL; e--; V[i].outDegree--; V[j].inDegree--; return eBak;&#125; 广度优先搜索（BF-Search） 化繁为简：遍历（图-&gt;树） 算法： 123451. 访问顶点s2. 访问s所有尚未访问的邻接顶点3. 依次访问它们尚未访问的邻接顶点4. 如此反复实际上：树的层次遍历 图示： 12345678910111213141516 a / | \\ s | e / \\ | | \\ 遍历前 d c | f \\ / | / b-----g a / \\ s e / \\ | \\ 遍历后 d c | f / | b g队列 s-&gt;a-&gt;c-&gt;d-&gt;e-&gt;b-&gt;f-&gt;g 实现：1//练习 深度优先搜索(DF-Search) 算法： 121. 访问顶点s2. 尚有未被访问的邻居，任取其一u，递归执行DFS(u),否则返回 图示: 12345678910111213141516 j | i---g---h | / \\ | d e f | / | | a --b---c j | i---g---h | | d e f | | a --b---c队列: a-&gt;b-&gt;c-&gt;f-&gt;h-&gt;g-&gt;j-&gt;i-&gt;d-&gt;e 实现： 1//练习","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"《数据结构》笔记：二叉树","slug":"t-course_ds_005","date":"2015-08-25T14:58:11.000Z","updated":"2017-10-04T10:05:59.000Z","comments":true,"path":"2015/08/25/t-course_ds_005/","link":"","permalink":"http://yoursite.com/2015/08/25/t-course_ds_005/","excerpt":"","text":"半线性结构，二维的列表，特殊的图 树(tree) 有根树：指定任一节点r 属于 V作为根后，T即称有根树(rooted tree) 有序树： 子树树根称孩子，同一父亲的子树之间称兄弟 关系：边数 = 所有定点度数之和 = 所有顶点-1 = O（n） 定义：指定孩子的顺序，称T为有序数 路径环路： k条边依次相连，构成一条路径(path) 长度：边的数目 环路：其中的某个顶点短路 连通无环： 连通图：节点之间均有路径（边数多） 无环图：不含环路（边数少） 树与图：无环连通图，任何节点与根之间存在唯一路径，每个顶点都有了一个长度path(V) 深度层次： 路径节点子树可以相互指代 深度：depth(v) = | path(v) | 祖先后代：路径上的节点均为v的祖先，v是它们的后代 真祖先后代：除开自己的 半线性：任一深度，祖先唯一，后代未必唯一 根：所有节点的公共祖先，深度为0，无祖先 叶子：没有后代的节点，出度为0 高度：所有叶子深度的最大值称树的高度，空树（一个节点没有）的高度为-1 树的表示 接口： 节点 功能 root() 根节点 parent() 父节点 firstChild() 长子 nexrSibling() 兄弟 insert(i, e) 第i个孩子插入 remove(i) 删除第i个孩子 traverse() 遍历 父节点实现： rank data parent 0 A -1 1 B 0 2 C 0 3 D 0 4 E 1 5 F 1 6 G 3 7 H 6 8 I 6 9 J 6 123456//空间性能： O(n)//时间性能//parent(): O(1)//root(): O(n)或O(1)//firstChild(): O(n) //不好//nextSibling(): O(n) //不好 子节点实现： rank data children 0 A 35 1 B -1 2 C -1 3 D -1 4 E 012 5 F -1 6 G 789 7 H -1 8 I -1 9 J -1 123456//空间性能： O(n)//时间性能//parent(): O(n) //不好//root(): O(n)或O(1)//firstChild(): O(1) //nextSibling(): O(1) 组合实现： rank data parent children 0 A 4 35 1 B 4 -1 2 C 4 6 3 D 0 -1 4 E -1 012 5 F 0 -1 6 G 2 789 7 H 6 -1 8 I 6 -1 9 J 6 -1 123456//空间性能： O(n)//时间性能//parent(): O(1) //root(): O(n)或O(1)//firstChild(): O(1) //nextSibling(): O(1) //不好 长子兄弟法:设2个引用，纵firstChild(), 横nextSibling() 二叉树(binary tree):节点度数不超过2 左右孩子：lChild–&gt;lSubTree,rChild–&gt;rSubtree隐含了树的有序性 基数：深度为k的节点，至多2^k个，含n个节点，高度为h的二叉树 h &lt; n &lt; 2^(h+1) 满树：顶点树最大，饱和状态，宽度2^h 度与节点：0度叶子，1度单分支，2度双分支 真二叉树：所有节点度数为0或2，补全1度节点（假想策略） 描述二叉树:二叉树是多叉树的特例，有根有序时能力足以覆盖后者 多叉树化二叉树 121. 长子兄弟法2. 向左45度旋转 二叉树化树 1231. 若某结点是其双亲的左儿子，则把该结点的右儿子，右儿子的右儿子，...都与该结点的双亲结点用线连起来；2. 删掉原二叉树中所有的双亲结点与右儿子结点的连线；3. 整理由两步所得到的树，使之结构层次分明。 二叉树实现 节点实现(BinNode) 123456789101112131415161718192021222324252627282930#define BinNodePosi(T) BinNode&lt;T&gt;*template &lt;typename T&gt; struct BinNode &#123; BinNodePosi(T) parent, lChild, rChild; //父亲孩子 T data; //数据 int height; //高度 int size(); //规模 BinNodePosi(T) insertAsLc(T const &amp;); //插入左子 BinNodePosi(T) insertAsRc(T const &amp;); //插入右子 BinNodePosi(T) succ(); //（中序）后继 template &lt;typename VST&gt; void travLevel( VST &amp; ); //层次遍历 template &lt;typename VST&gt; void travIn( VST &amp; ); //中序遍历 template &lt;typename VST&gt; void travPost( VST &amp; ); //后序遍历&#125; //O(1)//插入左子template &lt;typename T&gt; BinNodePosi(T) BinNode&lt;T&gt;::insertAsLc(T const &amp;) &#123; return lChild = new BinNode( e, this);&#125;//插入右子template &lt;typename T&gt; BinNodePosi(T) BinNode&lt;T&gt;::insertAsRc(T const &amp;) &#123; return rChild = new BinNode( e, this);&#125;//O(1)//规模template &lt;typename T&gt; int BinNode&lt;T&gt;::size() &#123; int s = 1; if (lChild) s += lChild-&gt;size(); if (rChild) s += rChild-&gt;size(); return s;&#125;//O(n) 二叉树实现接口(BinTree) 1234567891011121314#define stature ((p) ? (p)-&gt;height : -1)template &lt;typename T&gt; class BinTree &#123; protected: int _size; //规模 BinNodePosi(T) _root; //根节点 virtual int updateHeight( BinNodePosi(T) x ); void updateHeightAbout( BinNodePosi(T) x ); public: int size() const &#123; return _size; &#125; bool empty() const &#123; return _root; &#125; BinNodePosi(T) root() const &#123; return _root; &#125; //接入删除分离 //遍历&#125; 更新高度 12345678910template &lt;typename T&gt; int BinTree&lt;T&gt;::updateHeight( BinNodePosi(T) x ) &#123; return x-&gt;height = 1 + max( stature(x-&gt;lChild), stature(x-&gt;rChild) );&#125;template &lt;typename T&gt; void BinTree&lt;T&gt;::updateHeightAbout( BinNodePosi(T) x ) &#123; while (x) &#123; updateHeight(x); x = x-&gt;parent; &#125;&#125; 节点插入 123456template &lt;typename T&gt; BinNodePosi(T) BinTree&lt;T&gt;::insertAsRC( BinNodePosi(T) x, T const &amp;e)&#123; _size++; x-&gt;insertAsRC(e); updateHeightAbout(x); return x-&gt;rChild;&#125; 先序遍历不要从轮子造起，利用之前的工作 按照某种次序访问，每个节点被访问恰好一次 遍历结果：先序，中序，后序 区别：局部的根节点的访问顺序 1234先序：V --&gt; L --&gt; R中序：L --&gt; V --&gt; R后序：L --&gt; R --&gt; V//左子树总是在右子树之前 递归实现： 1234567template &lt;typename T&gt; void traverse( BinNodePosi(T) x, VST &amp; visit) &#123; if ( !x ) return; visit( x-&gt;data ); //访问根 traverse( x-&gt;lChild, visit ); //访问左子树 traverse( x-&gt;rChild, visit ); //访问右子树&#125; //O(n)渐进的 改进1(迭代) 12345678910111213template &lt;typename T, typename VST&gt; void travPre_I1( BinNodePosi(T) x, VST &amp; visit) &#123; Stack &lt;BinNodePosi(T)&gt; S; //辅助栈 if ( x ) //根入栈 S.push(x); while ( !S.empty() ) &#123; x = S.pop(); //出栈并访问当前节点 visit( x-&gt;data ); if( HasRChild( *x ) ) //右孩子先进后出 S.push( x-&gt;rChild ); if( HasLChild( *x ) ) //左孩子先出后进 S.push( x-&gt;lChild ); &#125;&#125; //无法推广 改进2(左侧下行迭代) 1234567891011121314151617template &lt;typename T, typename VST&gt; void travPre_I2( BinNodePosi(T) x, VST &amp; visit ) &#123; Stack &lt;BinNodePosi(T)&gt; S; //辅助栈 while (true) &#123; //以右子树为单位，逐批访问节点 visitAlongLeftBranch(x, visit, S); if( S.empty() ) //栈空即退出 break; x = S.pop(); //弹出下一个子树的根 &#125; //pop = push = visit = O(n) = 分摊O(1)&#125;template &lt;typename T, typename VST&gt; static void visitAlongLeftBranch( BinNodePosi(T) x, VST &amp; visit, Stack&lt;BinNodePosi(T)&gt; &amp; S) &#123; while (x) &#123; visit( x-&gt;data ); S-&gt;pash( x-&gt;rChild ); //右孩子入栈 x = x-&gt;lChild; //沿左侧下行 &#125;&#125; 中序遍历 递归实现 1234567template &lt;typename T, typename VST&gt; void traverse( BinNodePosi(T) x, VST &amp; visit) &#123; if ( !x ) return; traverse( x-&gt;lChild, visit ); //访问左子树O(a) visit( x-&gt;data ); //访问根O(1) traverse( x-&gt;rChild, visit ); //访问右子树O(n-1-a)&#125; //O(n)渐进的 改进：左侧下行迭代 123456789101112131415161718template &lt;typename T, typename VST&gt; void travIn_I2( BinNodePosi(T) x, VST &amp; visit ) &#123; Stack &lt;BinNodePosi(T)&gt; S; //辅助栈 while (true) &#123; //以右子树为单位，逐批访问节点 goAlongLeftBranch(x, visit, S); if( S.empty() ) //栈空即退出 break; x = S.pop(); visit( x-&gt;data ); //立即访问 x = x-&gt;rChild; //转向右子树 &#125; //pop = push = visit = O(n) = 分摊O(1)&#125;template &lt;typename T, typename VST&gt; static void goAlongLeftBranch( BinNodePosi(T) x, VST &amp; visit, Stack&lt;BinNodePosi(T)&gt; &amp; S) &#123; while (x) &#123; S-&gt;pash( x-&gt;rChild ); //右孩子入栈 x = x-&gt;lChild; //沿左侧下行 &#125;&#125;//每一个节点都只有一个入栈动作，实际只有O(n)复杂度，分摊分析，优于递归 层次遍历：借助队列123456789101112template &lt;typename T, typename VST&gt; void traverse( VST &amp; visit) &#123; Queue &lt;BinNodePosi(T)&gt; Q; //辅助栈 Q.enqueue( this ); while ( !Q.empty() ) &#123; BinNodePosi(T) x = Q.dequeue(); //出列并访问当前节点 visit( x-&gt;data ); if( HasLChild( *x ) ) //左孩子先进先出 Q.enqueue( x-&gt;lChild ); if( HasRChild( *x ) ) //右孩子后进后出 Q.enqueue( x-&gt;rChild ); &#125;&#125; 重构：已知三种遍历序列其中2种还原二叉树 中序 + 先序/后序：数学归纳法 123456789101112131415161718192021证明：preorder: r -&gt; [L] -&gt; [R]inorder: [L] -&gt; r -&gt; [R]postorder：[L]-&gt;[R] -&gt; r 定位r，判断左右子树，递归实现 A B C D E F先序： A B D C E F中序： D B A E F C后序： D B F E C A先+中1. root:A L:DB R:EFC2. root:B L:D, root:C , root:C L:EF3. root:E R:F后+中1. root:A L:DB R:EFC2. root:C L:EF, root:B L:D 3. root:E R:E//技巧，先序后序确定根，中序确定左右分支 先序 + 后序 + 真二叉树： 123456789 A B C D E F G H I先序： A B D E C F G H I后序： D E B F H I G C A1. root: A L: BDE R:CFGHI2. root: B L: D R:E, root:C L:F R:GHI3. root: G L: H R:I","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"《数据结构》笔记：栈","slug":"t-course_ds_004","date":"2015-08-20T04:22:23.000Z","updated":"2017-10-04T10:05:55.000Z","comments":true,"path":"2015/08/20/t-course_ds_004/","link":"","permalink":"http://yoursite.com/2015/08/20/t-course_ds_004/","excerpt":"","text":"一组元素的线性序列，通常只能访问一个元素开放的端top,不开放的bottompush,pop只能操纵当前的顶部的元素 接口与实现 操纵 操纵 功能 Stack() 初始化栈 empty() 判断栈是否为空 push(e) 进栈 pop(e) 出栈 size() 返回元素数量 特性：后进先出(LIFO) 实现：通过向量或列表派生 12345678//向量实现template &lt;typename T&gt; class Stack :public Vector&lt;T&gt; &#123; public: //size() empty()直接沿用 void push(T const &amp; e) &#123; insert(size(), e); &#125; //入栈 T pop() &#123; return remove( size() -1 ); &#125; //出栈 T &amp; top() &#123; return (*this)[ size() - 1]; &#125; //取顶 O(1)&#125;;//列表实现 进制转换(逆序输出)12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;void convert( Stack&lt;char&gt; &amp; S, __int64 n, int base) &#123; static char digit[] = &#123;'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'&#125;; while (n &gt; 0) &#123; s.push( digit[ n % base ]); n /= base; &#125;&#125;int main(void) &#123; Stack&lt;char&gt; S; cin &gt;&gt; n &gt;&gt; base; convert(S, n, base); while ( !S.empty() ) cout &lt;&lt; S.pop(); return 0;&#125; 括号匹配（递归嵌套）123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;stack&gt;bool paren(const char exp[], int lo, int hi) &#123; Stack&lt;char&gt; S; for (int i = lo; i &lt; hi; i++) if( exp[i] == '(' ) S.push(exp[i]); else if( !S.empty() ) S.pop(); else return false; return S.empty();&#125;int main(void) &#123; char exp[20] = &#123; '(' &#125;; paren(exp, 0, 20); return 0;&#125;//通过计数器也可以实现//但是通过栈可以拓展到多个括号并存的实例 栈混洗 计数：cabula数 （2n!）/ (n!*(n+1)!) 甄别：n = 3 时 3 1 2 不是栈混洗，与元素无关，这是一个禁型，是充要条件 12//高效算法，引入3个栈，模拟混洗过程，使用贪心算法//练习 与括号匹配的联系 中缀表达式求值（延迟缓冲）123456789101112131415161718192021222324252627282930313233float evaluate(char * s, char * &amp; RPN) &#123; Stack&lt;float&gt; opnd; Stack&lt;char&gt; optr; optr.push('\\0'); while (!optr.empty()) &#123; if (isdigit(*S)) readNumber(S, opnd); else &#123; switch( orderBetween(optr.top(), *S) ) &#123; case '&lt;': optr.push(*S); S++; break; case '=': optr.pop(); S++; break; case '&gt;': &#123; char op = optr.pop(); if ('!' == op) //一元运算符 opnd.push( calcu(op, opnd.pop()) ); else &#123; //二元运算符 float pOpnd2 = opnd.pop(); //操作数 float pOpnd1 = opnd.pop(); opnd.push( calcu(pOpnd1, op, pOpnd2) ); //运算并回收 &#125; break; &#125; &#125; &#125; &#125; return opnd.pop();&#125; 逆波兰表达式（RPN）:不需要判断优先级，只要遇到操作符就计算，后缀表达式 变形：若欲取之，必先予之 12341. 括号显示表示优先级2. 将运算符移动对应的右括号之后3. 抹去所有运算符4. 稍加整理 实现： 1//练习","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"《数据结构》笔记：列表","slug":"t-course_ds_003","date":"2015-08-16T03:38:34.000Z","updated":"2017-10-04T10:05:50.000Z","comments":true,"path":"2015/08/16/t-course_ds_003/","link":"","permalink":"http://yoursite.com/2015/08/16/t-course_ds_003/","excerpt":"","text":"接口与实现 列表是采用动态存储策略的典型结构，其中的元素称作节点(node)各节点通过指针或者引用彼此联结，在逻辑上构成一个线性序列属于双向链表结构 从静态到动态操作 1）静态：get O(1), search O(logn) 2）动态：insert O(n), remove O(n) 前驱后继：彼此相邻的节点，前驱或后继若存在则必然唯一 首末节点：没有前驱后后继的唯一节点 寻位置访问：called-by-position,通过节点的相互引用找到特定的节点 实现接口：列表节点作为基本单位操作 | 功能—|—pred() | 取节点前驱succ() | 取节点后继data() | 取节点数据对象insertAsPred(e) | 插入前驱节点，存入e，返回新节点位置insertAsSucc(e) | 插入后继节点，存入e，返回新节点位置 12345678910#define Post(T) ListNode&lt;T&gt;*template &lt;typename T&gt; struct ListNode &#123; //完全开放，不再过度封装 T data; //数值 Post(T) pred; //前驱 Post(T) succ; //后继 ListNode() &#123;&#125; //针对header和trailer的构造 ListNode(T e, Posi(T) p = NULL, Post(T) s = NULL) : data(e), pred(p), succ(s) &#123;&#125; //默认构造 Posi(T) insertAsPred(T const &amp; e); //前插入 Posi(T) insertAsSucc(T const &amp; e); //后插入&#125; 操作接口 模板类 12345678910111213141516171819202122232425#include \"ListNode.h\"template &lt;typename T&gt; class List &#123;private: int _size; Posi(T) header; //头元素（不可见） Posi(T) tailer; //末元素（不可见）protected: //内部函数public: //构造函数 //析构函数 //只读接口 //可写接口 //遍历接口&#125;;//构造函数 规模为0template &lt;typename T&gt; void List&lt;T&gt;::init() &#123; header = new ListNode&lt;T&gt;; trailer = new ListNode&lt;T&gt;; header-&gt;succ = trailer; header-&gt;pred = NULL; tailer-&gt;pred = header; tailer-&gt;succ = NULL; _size = 0;&#125; 无序列表 秩到位置：模仿向量的循秩访问方式，重载下标符 查找 123456template &lt;typename T&gt; Posi(T) List&lt;T&gt;::find(T const &amp;e, int n, Posi(n) p) const &#123; while (0 &lt; n--) if (e == ( p = p-&gt;pred )-&gt;data ) return p; return NULL;&#125; 插入 12345678910template &lt;typename T&gt; Posi(T) List&lt;T&gt;::insertBefore(Posi(T) p, T const &amp; e) &#123; _size++; return p-&gt;insertAsPred(e); //e当作前驱插入&#125;template &lt;typename T&gt; Posi(T) ListNode&lt;T&gt;::insertAsPred(T const &amp; e) &#123; Posi(T) x = new ListNode(e, pred, this); //创建 pred-&gt;succ = x; //建立连接 pred = x; return x;&#125; 基于复制的构造 12345678//基于复制的构造template &lt;typename T&gt; void List&lt;T&gt;::copyNodes(Posi(T) p, int n) &#123; //O(n) init(); //创建头尾节点初始化 while (n--) &#123; //自p的n下依次作为末节点插入 insertAsLast(p-&gt;data); p = p-&gt;succ; &#125;&#125; 删除节点 123456789//删除template &lt;typename T&gt; T List&lt;T&gt;::remove(Posi(T) p) &#123; //O(1) T e = p-&gt;data; //备份待删除的数值 p-&gt;pred-&gt;succ = p-&gt;succ; //跳过p p-&gt;succ-&gt;pred = p-&gt;pred; //对称 delete p; _size--; return e; //返回数值&#125; 析构 123456789101112//析构template &lt;typename T&gt; List&lt;T&gt;::~List() &#123; clear(); //清空列表 delete header; //释放头 delete tailer; //释放末&#125;template &lt;typename T&gt; int List&lt;T&gt;::clear() &#123; int oldSize = _size; while(0 &lt; _size) remove(header-&gt;succ); //反复删除首节点 return oldSize;&#125; //O(n) 唯一化 12345678910111213//唯一化template &lt;typename T&gt; int List&lt;T&gt;::deduplicate() &#123; if (_size &lt; 2) //平凡列表自然无重复 return 0; int oldSize = _size; //记录原规模 Posi(T) p = first(); Rank r = 1; //p从首节点开始 while ( trailer != ( p = p-&gt;succ ) ) &#123; //依次到末节点 Posi(T) q = find(p-&gt;data, r, p); //从前驱中查找雷同的 q ? remove(q) : r++; //若存在删除，否则秩递增 &#125; return oldSize - _size; //列表规模变化，等于删除的元素&#125; 有序列表 唯一化 1234567891011121314//有序向量唯一化template &lt;typename T&gt; int List&lt;T&gt;::uniquify() &#123; if(_size &lt; 2) return 0; int ordSize = _size; //原始规模 ListNodePosi(T) p = first(); ListNodePosi(T) q; while ( trailer != ( q = p-&gt;succ ) ) //遍历 if ( p-&gt;data != q-&gt;data ) //不同 p = q; //连接 else remove(q); //雷同删除 return oldSize - _size;&#125; //O(n) 查找 123456//查找template &lt;typename T&gt; Posi(T) List&lt;T&gt;::search(T const &amp;e, int n, Posi(T) p) const &#123; while ( 0 &lt;= n-- ) //从右往左扫描，发现下于即命中 if ( ( ( p = p-&gt;pred )-&gt;data ) &lt;= e ) break; return p;&#125; 链表 单链表：节点只包含值域和指针域两个部分 12345678#define posi(T) sList&lt;T&gt;*Template &lt;typename T&gt; struct sList &#123; T data; posi(T) next;&#125;;//特点：特定元素之后插入，删除，复杂度为O(1)//尾节点的指针为空 tail-&gt;next = NULL; - 双向链表（列表） 循环单链表：尾指针指向了首元素 12tail-&gt;next = head;//特点：特点元素前后插入，删除复杂度O(1) 循环双链表：兼具双向链表和循环链表优势 123tail-&gt;succ = head;head-&gt;pred = tail;//优势：在尾部插入删除元素的复杂度为O(1) 选择排序123456789101112131415161718192021222324template &lt;typename T&gt; void List&lt;T&gt;::selectionSort(Posi(T) p, int n) &#123; Posi(T) head = p-&gt;pred; //待排区间 Posi(T) tail = p; for (int i = 0; i &lt; n; ++i) &#123; tail = tail-&gt;succ; &#125; while (1 &lt; n) &#123; //反复从待排区间找出最大的移至有序区间前端 insertBefore( tail, remove( selectMax(head-&gt;succ), n) ); tail = tail-&gt;pred; n--; &#125;&#125;//尽可能少的使用new deletetemplate &lt;typename T&gt; Posi(T) List&lt;T&gt;::selectMax(Posi(T) p, int n) &#123; Posi(T) max = p; for (Posi(T) cur = p; 1 &lt; n; n--) &#123; if ( !lt ( (cur = cur-&gt;succ )-&gt;data, max-&gt;data) ) max = cur; return max; //返回最大节点位置 &#125;&#125;//O(n^2) 但是移动操作远远少于起泡排序//改进比较操作后可以在nlogn下完成 插入排序LightHouse","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"《数据结构》笔记：向量","slug":"t-course_ds_002","date":"2015-08-13T04:58:23.000Z","updated":"2017-10-04T10:05:46.000Z","comments":true,"path":"2015/08/13/t-course_ds_002/","link":"","permalink":"http://yoursite.com/2015/08/13/t-course_ds_002/","excerpt":"","text":"接口与实现 抽象数据类型(ADT:Abstract Data Type) = 数据模型 + 一组操作数据结构(DS:Data Structure) = 基于某种特定语言 + 实现ADT的一整套算法 数组：每个元素由编号唯一指代，并可以直接访问，亦称为线性数组 向量：数组的抽象和泛化，由一组元素按线性次序封装而成 12341）个元素与[0,n)整数一一对应，称成秩（RANK）2）元素类型不限于基本类型3）操作，管理，维护，更加简化安全4）可以为便捷的参与更加复杂的操作定制 模板：灵活指定类型,利用组成更复杂的数据结构 123template &lt;typename T&gt; Vector;Vector &lt; int &gt; myvertor;Vector &lt;BinTree&gt; forest; ADT接口：丰富的操作接口 操作 功能 size() 向量的规模 get(r) 获取秩为r的元素 put(r,e) 用e替换秩为r的元素 insert(r,e) e作为秩为r的元素插入，原后继元素后移 remove(r) 剔除秩为r的元素 disordered() 判断所有元素是否已按非降序排列 sort() 调整元素位置，使之按非降序排列 find(e) 找到目标元素e放回秩 deduplicate() 剔除重复元素 traverse() 遍历所有元素 1234567891011121314151617181920212223242526272829303132333435363738394041typedef int Rank; //秩#define DEFAULT_CAPACITY 3 //默认容量template &lt;typename T&gt; class Vector&#123;private: Rank _size; //规模 int _capacity; //容量 T* _elem; //数据区protected: //内部函数public: //构造函数 Vector(int c = DEFAULT_CAPACITY)&#123; _elem = new T[_capacity = c]; _size = 0; &#125; //默认 Vector(T const *A, Rank lo, Rank hi) &#123; copyFrom(A, lo, hi); &#125; //数组区间复制 Vector(Vector&lt;T&gt; const&amp; V, Rank lo, Rank hi) &#123; copyFrom(V._elem, lo, hi); &#125; //向量区间复制 Vector(Vector&lt;T&gt; const&amp; V) &#123; copyFrom(V._elem, 0, V._size); &#125; //向量整体复制 //析构函数 ~Vector() &#123; delete [] _elem; &#125; //只读接口 //可写接口 //遍历接口&#125;//复制template &lt;typename T&gt; void Vector&lt;T&gt;::copyFrom(T* const A, Rank lo, Rank hi) &#123; _elem = new T[_capacity = 2*(hi - lo)]; //分配空间，预留2倍的空间 _size = 0; //规模清零 while (lo &lt; hi) &#123; _elem[_size++] = A[lo++]; &#125; //元素逐一复制[0, hi-lo)&#125;//扩容template &lt;typename T&gt; void Vector&lt;T&gt;::expand() &#123; if(_size &lt; _capacity) return; //尚满，不扩 _capacity = max(_capacity, DEFAULT_CAPACITY); //不低于最小容量 T* oldElem = _elem; _elem = new T[_capacity &lt;&lt;= 1]; //容量加倍 for (int i = 0; i &lt; _size; ++i) //复制原向量内容 _elem[i] = oldElem[i]; // = 重载了的 delete [] oldElem; //释放原空间&#125; 可扩充向量：可能出现上溢(overflow)或者下溢(underflow) 上溢：不足以存放所有元素 ，空间不足下溢：寥寥无几，装填因子：_size/_capacity &lt;&lt; 50%,空间效率低 蝉的哲学：每生长一段时间，蜕掉外壳，生成新的壳 即将上溢时适当的增加容量 得益于向量的封装，扩容后数据区的指针改变了，但不至于出现野指针 容量加倍策略：成本好于容量递增策略 123复杂度：最坏情况，在初始容量为1的满容量中，连续插入n = 2^m当n = 1，2，4，8，16....时扩容空间上损失换取时间上的巨大收益 策略 递增策略 加倍策略 累计增容时间 O(n^2) O(n) 分摊增容时间 O(n) O(1) 装填因子 约100% &gt;50% 平均复杂度：加权平均数，独立的考察平均程度分摊分析：整体的考虑，连续的足够多次操作，总体成本分摊到单次操作，更加准确分析数据结构和算法成本 无序向量： 元素的访问：沿用下标式操作，对下标操纵符进行重载 1template &lt;typename T&gt; T &amp; Vector&lt;T&gt;::operator[](Rank r) const &#123; return _elem[r]; &#125; //循秩访问 插入：1.扩容2.后移(从后开始)3.赋值4.规模+1 12345678template &lt;typename T&gt; Rank Vector&lt;T&gt;::insert(Rank r, T const &amp; e) &#123; expand(); //若满，扩容 for(int i = _size; i &gt; r; i--) _elem[i] = _elem[i-1]; //原r后的整体元素后移一位(后开始) _elem[r] = e; //r处赋值 _size++; //规模加一 return r; //返回秩&#125; 删除：1.单独处理2.前移(从前开始)3.更新规模4.缩容 12345678910template &lt;typename T&gt; // 删除区间hi-loint Vector&lt;T&gt;::remove(Rank lo, Rank hi) &#123; if (lo == hi) return 0; //单独处理退化 while (hi &lt; _size) _elem[lo++] = _elem[hi++]; //整体前移一段(前开始) _size = lo; shirnk(); //缩容 return hi - lo;&#125; 单元素删除：调用多元素删除 12345template &lt;typename T&gt; T Vector&lt;T&gt;::remove(Rank r) &#123; T e = _elem[r]; remove(r, r+1); return e;&#125; 查找：无序向量，默认重载判等和比较操纵符，逆向扫描 12345template &lt;typename T&gt; Rank Vector&lt;T&gt;::find(T const &amp; e, Rank lo, Rank hi) const &#123; while ((lo &lt; hi--) &amp;&amp; e != _elem[hi]) //逆向查找 return hi;&#125;//最坏O(n)最好O(1) 输入敏感 无序向量唯一化：剔除重复的元素 12345678910template &lt;nametype T&gt; int Vector&lt;T&gt;::deduplicate() &#123; int oldSize = _size; Rank i = 1; //从第二个元素开始 while (i &lt; _size) //由前向后逐步考查 (find(_elem[i], 0, i) &lt; 0) ? i++ : remove(i); //删除雷同者 return oldSize - _size; //删除的总数&#125;//成本：O(n^2)//优化 遍历：visit操作 1234567891011//使用函数指针局部修改template &lt;typename T&gt; void Vector&lt;T&gt;::traverse(void (*visit)(T&amp;)) &#123; for (int i = 0; i &lt; _size; i++) visit(_elem[i]);&#125;//使用函数对象template &lt;typename T&gt; template &lt;typename TSV&gt;void Vector&lt;T&gt;::traverse(TSV &amp; visit)) &#123; for (int i = 0; i &lt; _size; i++) visit(_elem[i]);&#125; 有序向量：唯一化 相邻逆序对数目可以来度量向量的逆序程度 123456template &lt;typename T&gt; int Vector&lt;T&gt;::disordered() const &#123; int n = 0; for (int i = 0; i &lt; _size; i++) //逐一检查各对相邻元素 n += (_elem[i - 1] &gt; _e[i]); //逆序则计数向量有序 return n; //当且仅当n=0时&#125; //只判断是否有序，首次遇到逆序对直接终止 唯一化：低效与高效算法 1234567891011121314151617181920template &lt;typename T&gt; int Vector&lt;T&gt;::uniquift() &#123; int oldSize = _size; int i = 0; while (i &lt; _size-1) //雷同删除后者 (_elem[i] == _elem[i+1]) ? remove(i+1) : i++; return oldSize - _size;&#125;//最坏情况:O(n^2) 省去了find但竟然与无序向量竟然相同，低效算法//反思：每个元素都多次进行多次前移//改进：成批的删除(移动覆盖删除)template &lt;typename T&gt; int Vector&lt;T&gt;::uniquift() &#123; Rank i = 0, j = 0; //相邻互异元素 while(++j &lt; _size) //跳过雷同者，不同者紧靠前者右侧 if(_elem[i] != _elem[j]) _elem[++i] = _elem[j]; _size = ++i; shirnk(); return j - i;&#125;//常数迭代时间O(n) 有序向量：二分查找12345template &lt;typename T&gt; int Vector&lt;T&gt;::search(T const &amp; e, Rank lo, Rank hi) &#123; return (rand() % 2) ? binSearch(_elem, e, lo, hi) : fibSearch(_elem, e, lo, hi);&#125; 语义约定：利于有序向量的自身的维护V.insert(1+search(e), e) 1234约定：在有序向量区间V[lo,hi)中，确定不大于e的最后一个元素失败：若 &lt; V[lo] 则返回lo-1若 &gt; V[hi-1] 则返回hi-1重复：插入到不同的上一位 二分查找：折半查找，减而治之 1234567891011121314151617181920212223242526/*1)减而治之，以任一元素x=S[mi]为届，将带查找区间分三部分S(在[lo,mi) &lt;= S[mi] &lt;= S[mi,hi]2)将目标元素e与x作比较，分三种情况处理 1. e &lt; x : 必属左侧子区间，递归深入 2. e &gt; x : 必属右侧子区间，递归深入 3. e = x : 命中目标，随即返回3)二分折半策略：轴点mi总是取作中点，每经过最多2次比较，或者命中或者将规模缩减至半*///二分查找template &lt;typename T&gt; static Rank binSearch(T * A, T const &amp;e, Rank lo, Rank hi) &#123; while (lo &lt; hi) &#123; Rank mi = (lo + hi) &gt;&gt; 1; if (e &lt; A[mi]) hi = mi; //三种情况 else if ( A[mi] &lt; e) lo = mi + 1; else return mi; &#125; return -1; //查找失败&#125;//复杂度分析//递推分析：T(n) = T(n/2) + O(1) = O(log(n))//递归跟踪：递归深度log(n),每次O(1),总的O(log(n))//查找长度：关键码的比较次数//精确的为：1.5log(n) 有序向量：fibonacci查找 二分查找的改进，转向左，右分支前的关键码比较次数不等，递归深度不同，对转向成本进行补偿 123456789101112131415161718//fib查找template &lt;typename T&gt; static Rank fibSearch(T * A, T const &amp;e, Rank lo, Rank hi) &#123; Fib fib(hi - lo); //创建fib数列 while(lo &lt; hi) &#123; while (hi - lo &lt; fib.get()) fib.prev(); //向前查找确定fib(k)-1的轴点 Rank mi = lo + fib.get() - 1; //切分 if (e &lt; A[mi]) //前半段 hi = mi; else if (A[mi] &lt; e) lo = mi + 1;//后半段 else return mi; //命中 &#125; return -1;&#125;//时间复杂度：O(log(n))//精确复杂度：&lt; O(1.5log(n)) 优于二分查找 最优轴点：二分查找对应0.5，fibonacci查找对应的0.6180339黄金分割比 有序向量：改进二分查找，缩短长度到1，算法更加稳定123456789101112131415161718192021222324252627/*左右分支不平衡问题解决方案：只设置两个区间1. e &lt; x ,若e存在必属S[lo, mi),递归深入2. x &lt;= e, 若e存在必属S[mi, hi),递归深入当hi - lo = 1时，判断是否命中*///二分查找Btemplate &lt;typename T&gt; static Rank binSearch(T * A, T const &amp;e, Rank lo, Rank hi) &#123; while (1 &lt; hi - lo) &#123; Rank mi = (lo + hi) &gt;&gt; 1; (e &lt; A[mi]) ? hi = mi : lo = mi; &#125; return (e == A[mi]) ? lo : -1;&#125;//复杂度分析：最好的情况更坏，更坏的情况更好，稳定性高//严格兑现了语义约定：多个命中元素，返回最靠右的//失败时，返回小于e的最大者//二分查找Ctemplate &lt;typename T&gt; static Rank binSearch(T * A, T const &amp;e, Rank lo, Rank hi) &#123; while (lo &lt; hi) &#123; Rank mi = (lo + hi) &gt;&gt; 1; (e &lt; A[mi]) ? hi = mi : lo = mi + 1; &#125; return --lo;&#125; 有序向量：插值查找(以后研究) 均匀独立的随机分布 起泡排序12345678910111213141516171819202122232425262728293031323334353637383940//排序接口template &lt;typename T&gt; void Vector&lt;T&gt;::sort(Rank lo, Rank hi) &#123; switch (rand() % 5) &#123; case 1: bubbleSort(lo, hi); break; //起泡排序 case 2: selectSort(lo, hi); break; //选择排序 case 3: mergeSort(lo, hi); break; //归并排序 case 4: heapSort(lo, hi); break; //堆排序 case 5: quickSort(lo, hi); break; //快速排序 &#125;&#125;//起泡排序(改进版)template &lt;typename T&gt; void Vector&lt;T&gt;::bubbleSort(Rank lo, Rank hi) &#123; while (!bubble(lo, hi--)); //扫描直至全序 &#125;template &lt;typename T&gt; bool Vector&lt;T&gt;::bubble(Rank lo, Rank hi) &#123; bool sorted = true; //有序标志 while (++lo &lt; hi) //整体扫描 if (_elem[lo - 1] &gt; _elem[lo]) &#123; //若存在逆序 sorted = false; //整体尚未有序的 swap(_elem[lo - 1], _elem[lo]); //交换 &#125; return sorted; //返回序标&#125;//复杂度：O(n^2) 改进节省相当多的时间（三角形变梯形），依然有改进空间//改进后可以使之为O(n^1.5)//再次改进//起泡排序(再次改进)template &lt;typename T&gt; void Vector&lt;T&gt;::bubbleSort(Rank lo, Rank hi) &#123; while (lo &lt; ( hi = bubble(lo, hi) ) ); //扫描直至全序 &#125;template &lt;typename T&gt; Rank Vector&lt;T&gt;::bubble(Rank lo, Rank hi) &#123; Rank last = lo; while (++lo &lt; hi) if (_elem[lo - 1] &gt; _elem[lo]) &#123; last = lo; swap(_elem[lo - 1], _elem[lo]); &#125; return sorted;&#125;//省去更多的时间，跳过有序的部分，最好的情况一样O(n)，最坏的情况依然是O(n^2) 稳定性：重复的元素在输入,输出相对的次序,是保持不变的 起泡排序也是稳定的，元素a，b的相对位置发生变化，只有一种可能： 1）分别与其他元素交换，二者相互接近和相邻 2）接下来的一轮扫描交换中，二者因逆序而交换位置 归并排序：基于分治策略(递归分解) 基于的比较排序：存在的上下界，O(n2) —bubbleSort———–mergeSort–&gt; O(nlogn) 二路归并算法原理：123序列1：21 - 13 - 8 - 5 序列2：29 - 19 - 4 - 2归并： 2 - 4 - 5 - 8 - 13 - 19 - 21 - 29 12345678910111213141516171819202122232425262728293031//归并排序template &lt;typename T&gt; void Vetor&lt;T&gt;::mergeSort(Rank lo, Rank hi) &#123; if (hi -lo &lt; 2) return; //处理递归基，单元素区间自然有序 int mi = (lo + hi) &gt;&gt; 1; //中心点 mergeSort(lo, mi); //前端递归 mergeSort(mi, hi); //后段递归 merge(lo, mi, hi); //归并&#125;template &lt;typename T&gt; void Vector&lt;T&gt;::merge(Rank lo, Rank mi, Rank hi) &#123; T * A = _elem + lo; //合并后的向量 int lb = mi - lo; //前子向量 T * B = new T[lb]; //复制前子向量 for (Rank i = 0; i &lt; lb; B[i] = A[i++]) ; int lc = hi - mi; //后子向量 T * C = _elem + mi; //B[j]和C[k]小者转移A末尾 for (Rank i = 0, j = 0, k = 0; (j &lt; lb) || (k &lt; lc); ) &#123; if( (j &lt; lb) &amp;&amp; (lc &lt;= k) || (B[j] &lt;= C[k]) ) A[i++] = B[j++]; if( (k &lt; lc) &amp;&amp; (lb &lt;= j) || (C[K] &lt;= B[j]) ) A[i++] = C[k++]; &#125; //循环紧凑，效率不如拆分 delete [] B;&#125;//正确性：//复杂度：for (...; (j &lt; lb) || (k &lt; lc); ) &#123; if() &#123; A[i++] = B[j++] ; &#125; if() &#123; A[i++] = C[k++] ; &#125;&#125;for循环为主要消耗： j + k = n 总迭代不过O(n)线性时间总的 T(n) = 2T(n/2) ==&gt; O(nlogn) 最坏情况下","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"《数据结构》笔记：算法分析","slug":"t-course_ds_001","date":"2015-08-10T05:58:04.000Z","updated":"2017-10-04T10:05:34.000Z","comments":true,"path":"2015/08/10/t-course_ds_001/","link":"","permalink":"http://yoursite.com/2015/08/10/t-course_ds_001/","excerpt":"","text":"计算Dijkstra名言：计算机科学，就是计算的科学 绳索计算机和算法：古埃及人的算法，线段垂直 尺规计算机和算法：线段三等分 总结：计算 = 信息处理，借助某种工具，尊尊某种规则 算法：特定计算模型下，解决问题的指令序列 输入：待处理的信息 输出：经处理的信息 正确性：的确可以解决指定的问题 确定性：基本操作组成的序列 可行性：每个操作都可以实现，在常数时间内完成 有穷性：如何输入，有穷次操作可以，得到输出结果 可行性：所有操作都可以兑现，例子3步把大象装到冰箱 有穷性：Hailstone(n)算法 1234567int hailstone(int n) &#123; int length = 1; while(1 &lt; n)&#123; n%2==0 ? n/=2 : n=3*n+1; length++; &#125;&#125; 结论：所有的n是否都可以有穷的步骤，还没有结论 程序 ！= 算法 计算模型凯文名言：如果你需要改进某种东西，你首先的学会如何测量它 算法分析两个主要方面：正确性，成本 成本：时间成本，空间成本 怎么衡量时间成本：特定算法+不同示例 稳妥起见：关注最坏情况 同一问题多种算法，评价其优劣：实验统计不足够 图灵机模型 Tape(带)：均匀划分单元格，各注一字符，默认为’#’ Alphabet：字符种类有限 Head：总是对准某一单元格，并可以读取修改其中的字符，每经过一个节拍，可转向左侧或右侧 State TM：有限机状态 Transition Function：(q, c, d, L/R, p)若当前状态为q，字符为c，将当前字符改写为d，转向左侧/右侧；转入p状态，一旦转入h停机功能：二进制非负整数加一，全1的后缀转为0，原低位的0翻转为1 RAM模型：寄存器顺序编号，总数没有限制 总结：图灵机，RAM模型为度量算法性能提供了准确的尺度 大O记号陶渊明名言：好读书不求甚解（更多的看重长远，主流） 渐进分析： 考虑n &gt;&gt; 2, 对规模为n的输入，需执行的基本操作次数，存储单元数 大O记号（big-O notation）：T(n) = O( f(n) ) &lt;= 存在c &gt; 0， n &gt;&gt; ,有 T(n) &lt; c * f(n) 常系数可忽略：O（ c * f(n) ）= O ( f(n) ) 低次项可忽略：O ( n^a + n^b ) = O( n^a ) , a &gt; b 其他记号：最好，平均情况 常数O(1)：2 = 2013 = 2013^2013 = O(1)，不含转向 对数O(logn)：非常高效，无限接近与常数 常底数无所谓所有 a, b &gt; 0, log(a) n = log(a) b * log(b)n = O( log(b) n ) 常数次幂无所谓 对数多项式 多项式（O（n ^c））:直接往高处化，通常认为令人满意了 线性（O（n）） 从O（n）~ O（n^2）：编程题主要覆盖的范围 幂 指数（a ^n）：计算成本增长极快，和多项式之间有个分水岭（有效算法到无效算法） 1234问题：2-Subset S包含n个正整数，存在S = 2m是否有子集T，满足存在 T = m?美国大选说事 不存在可在多项式时间内解决该问题 算法分析夸赞欧拉：像欧拉一样像呼吸一样自如 主要任务：正确性+复杂度 C++基本指令：等价于RAM的基本指令，二者相当 分支转向：goto //出于结构化被隐藏了 迭代循环：for（）、while（）、…… //本质上就是if + goto 调用加递归 //本质上也是goto 分析方法：迭代（级数求和）、递归（递归跟踪+递推方程）、猜测 级数： 算数级数（与末项平方同阶）：1 + 2 + …… + n = n (n+1) /2 = O(n^2) 幂级数（比末项高出一阶）：1^C + 2^C + …… n^C = O( n^(C+1) ) 几何级数（与末项同阶）：a0 + a^1 + …… a^n = O(a^n) 收敛级数： O（1） 调和级数：1 + 1/2 + …… 1/n = O(logn) 对数级数：log1 + log2 + …… + logn = log(n!) = O(nlogn) 循环与级数： 二重循环复杂度：O(n^2)123456789101112for(int i=0 ; i&lt;n; i++) for(int j=0; j&lt;n; j++) op(); //变化界限 for(int i=0 ; i&lt;n; i++) for(int j=0; j&lt;i; j++) op(); //变化步长for(int i=0 ; i&lt;n; i++) for(int j=0; j&lt;i; j=+2017) op(); 渐进复杂度依然一样：n + n + …… + n = n^2 = O(n^2) 1234//变化成几何级数for(int i=0 ; i&lt;n; i&lt;&lt;2) for(int j=0; j&lt;n; j++) op(); 复杂度变为O(n) 例子：冒泡排序 估算：1天多少秒？1天 = 24hr 60min 60sec = 25 * 4000 = 100000 sec 迭代与递归凡治众如治寡，分数是也 例子求和 12345678910int SumI(int A[], int n)&#123; int sum = 0; //O（1） for (int i = 0; i &lt; n; ++i) &#123; sum += A[i]; //O（1） &#125; return sum; //O（1）&#125;// 时间复杂度：T(n) = O（n）// 空间复杂度：O(1) 减而治之： 求解一个大规模的问题，划分成两个子问题：其一平凡，其二规模缩减（单调性） 12345int SumJ(int A[], int n)&#123; return (n &lt; 1) ? 0 : SumJ(A, n-1) + A[n+1] ;&#125; //递归递归跟踪：T(n) = O(1)*(n+1) = O(n)递推方程：T(n) = T(n-1) + O(1) T(0) = O(1) ==&gt; T(n) = O(n) 例子:数组倒置 123void reverse(int * Am int lo, int hi)；//递归版if(lo &lt; hi) &#123; swap(A[lo], A[hi]); reverse(A, lo+1, hi-1); &#125; 分而治之： 求解一个大规模的问题，划分成多个子问题，规模相当，分别求解子问题 1234567int sum(int A[], int lo, int hi)&#123; if(lo == hi) return A[lo]; int mi = (lo+hi) &gt;&gt; 1; return sum(A, lo, mi) + sum(A, mi + 1, hi);&#125;//二分递归递归跟踪：T(n) = O(1) * (2^0 + ... + 2^logn) = O(n)递推方程：T(n) = O(1) + 2T(n/2), T(1) = O(1) T(n) = O(n); 例子：MAX2，[lo, hi) 找出最大和次大的 1234567if( A[x1 = lo] &lt; A[x2 = lo + 1]) swap(x1, x2);for(int i = lo + 2; i &lt; hi; i++) if(A[x2] &lt; A[i]) if(A[x1] &lt; A[x2 =i]) swap(x1, x2);复杂度：最好的 n-1次比较，最坏的2n-3次比较改进：分而治之 最坏5n/3-2 动态规划(DSA优化) 运转–&gt;正确–&gt;快速 例子：fib()（递归） 1234567// fib(n) = f(n-1) + f(n-2) &#123;0, 1, 1, 2, 3, 5, 8 ...&#125;int fib(n) &#123; return (2 &gt; n) ? n : fib(n-1) + fib(n-2); &#125;// fib(43) ==&gt; 巨大的延迟//时间复杂度分析//递推公式：T(n-1) + T(n-2) + 1, T(1) = T(0) = 1, S(n) = fib(n+1) = 1.68... ^n//==&gt; O(2^n) 指数复杂度 超过100项，需要几百年//递归跟踪：大量重复的递归实例 例子：fib()（迭代） 12345678910111213//方法A(记忆)//制表查询//方法B(动态规划)//颠倒计算方向，自底而上int fib2(int n)&#123; int f = 0, g = 1; //用2个参数存储中间指 while(0 &lt; n--)&#123; g = g + f; f = g - f; &#125; return g;&#125;//空间上只需要O(1) 例子：最长公共子序列（递归–&gt;动态规划） 1234567891011121314151617181920212223242526272829303132333435363738394041/* * 最长公共子序列 * 可行----&gt;递归策略----&gt;减而治之----&gt;平凡情况 * 效率----&gt;动态规划----&gt;自底而上----&gt;迭代策略 * 对于序列A[0,n],B[0,m], LCS(A,B)无非3种情况 * 1) n=-1或m=-1，作空序列 * 2) A[n] = 'X' = B[m] 则LCS( A[0,n), B[0,m), 'X' ) * 3) A[n] != B[m] 则 LCS( A[0,n], B[0,m) ) 与 LCS( A[0,n), B[0,m] ) 中取更长者(分而治之) * 采用倒推式方式求公共子序列，用二维数组存储中间值 * *///递归#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int LCS(string, int, string, int);int LCS2(string, int, string, int);int main(void)&#123; string a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; LCS(a, a.length()-1, b, b.length()-1) &lt;&lt; endl; // cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; return 0;&#125;//递归int LCS(string a, int m, string b, int n)&#123; if(m == -1 || n == -1) return 0; else if(a[m] == b[n]) return LCS(a, m-1, b, n-1) + 1; else return LCS(a, m, b, n-1) &gt; LCS(a, m-1, b, n) ? LCS(a, m, b, n-1) : LCS(a, m-1, b, n);&#125;//动态规划int LCS(string a, int m, string b, int n)&#123; int arr[m][n] = &#123;0&#125;; //用数组存储中间值 if(a[0] == a[0]) &#125;","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"《C primer plus》笔记：内存管理","slug":"t-book_c_006","date":"2015-07-15T15:48:22.000Z","updated":"2017-10-13T01:47:51.000Z","comments":true,"path":"2015/07/15/t-book_c_006/","link":"","permalink":"http://yoursite.com/2015/07/15/t-book_c_006/","excerpt":"","text":"内存管理存储类别 对象（object）：被存储的值占有一定的物理内存 此对象非面向对象中的对象 访问（access）：声明变量来访问对象，也可以通过其他方式指定对象 123int entity = 3; //声明变量访问int * pt = &amp;entity; //指针访问int rank[10]; //数组访问 作用域（scope）： 块作用域：使用的局部变量（包含形参）都有块作用域 ，C99扩展了声明 函数作用域：仅用于goto，延伸整个函数 函数原型作用域：从形参定义到原型结束，形参名并不重要，仅变长数组需要 文件作用域：定义在函数外面，从该定义至文件末尾均可见（全局变量）1234double blocky(double a)&#123; double b; for(int c=0; c&lt;10; c++)&#123; ... &#125;&#125; //a, b, c 都具备块作用域 链接（linkage）： 外部链接：全局作用域，在多个文件中使用的且具有文件作用域 内部链接：文件作用域，在一个文件使用且具有文件作用域 无链接：局部作用域，具有块，函数，原型作用域123static: int giants = 5; //文件作用，外部 static int dodgers = 3; //文件作用，内部 存储期（storage duration）：对象在内存中保留的时间 静态存储期：执行期间一直存在，文件作用域变量具有静态存储期 线程存储期：用于并发设计，从申明至线程结束 自动存储期：块作用域变量通常具备自动存储期 动态分配存储期： 存储类别：5种 存储类别 存储期 作用域 链接 声明 自动 自动 块 无 块内 寄存器 自动 块 无 块内 使用register 静态外部链接 静态 文件 外部 函数外 静态内部链接 静态 文件 内部 函数外 使用static 静态无链接 静态 文件 无 块内 使用static 自动变量： 使用auto显示声明（不同于c++中auto） 内层变量于外层同名：暂时隐藏外层变量，等运行完后回到原来作用域、 123456789#include &lt;stdio.h&gt;int main(void)&#123; int i = 3; for (int i = 0; i &lt; 10; ++i) printf(\"%d \", i); printf(\"file:%d\\n\", i); return 0;&#125;// 0 1 2 3 4 5 6 7 8 9 file:3 初始化：自动变量不会初始化除非显示初始化，未初始化会造成不可预期的异常 寄存器变量：存储在cpu中，处理速度更快的自动变量 静态内部链接变量：只能用于同一文件的函数中 12static int a = 0;int main()&#123;&#125; 静态外部链接变量：外部变量（external variable） 使用其他文件的变量必须再次声明，函数内则可以不必声明123456int a; //定义外部变量，给全局extern char coal; //声明使用其他文件外部变量int main()&#123; extern char coal; //再次声明变量，可以省略 char coal; //定义的自动变量，隐藏了外部变量&#125; 初始化：可以显示初始化，也可以自动初始化为0，只能用常量表达式初始化 使用：函数内使用时，可以声明加extern,也可以不申明 定义和申明：extern表明声明的变量定义在别处 1234int tern = 1; //定义并初始化extern int tern; //此文件声明，也可以不申明extern int a; //必须有其他文件定义过aextern int b = 0; //错误,extern只能申明不能初始化 存储类别说明符：auto, register,static,extern,_ Thread_local,typedef存储类别与函数：外部函数（默认）， 静态函数， 内联函数（C99） 123double a(); //外部函数，其他文件可以使用static double beta(); //静态函数，此文件使用extern double c(); //内联函数，其他文件定义的函数 存储类别：按需使用 随机数函数和静态变量123456789#include &lt;stdio.h&gt;static unsigned long int next = 1; //种子unsigned int rand0(void)&#123; next = next * 1103515245 + 12345; return (unsigned int) (next / 65536) % 32768;&#125;void changeNext(unsigned int seed)&#123; next = seed;&#125; 掷色子123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int roll_count = 0;int roll_n_dice(int, int);int rollem(int);// int main(void)&#123;// for (int i = 0; i &lt; 10; ++i)// &#123;// printf(\"%d\\n\", rollem(6));// &#125;// return 0;// &#125;//生成1 - 6 之间的随机数int rollem(int sides)&#123; int roll; roll = rand() % sides + 1; roll_count++; return roll;&#125; int roll_n_dice(int dice, int sides)&#123; int d; int total = 0; if(sides &lt; 2) return -2; if(sides &lt; 1) return -1; for (d = 0; d &lt; dice; ++d) total += rollem(sides); return total;&#125; 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include \"testRandom.c\"int main(void)&#123; int dice, roll; int sides, status; srand((unsigned int) time(0)); printf(\"enter a number of sides:\\n\"); while(scanf(\"%d\", &amp;sides) == 1 &amp;&amp; sides &gt; 0)&#123; printf(\"how many dice\\n\"); //检查输入部分 if(status = scanf(\"%d\", &amp;dice) != 1)&#123; if(status == EOF) //检查是否有文件终止符 break; else&#123; while(getchar() != '\\n') //去掉换行符 continue; continue; &#125; &#125; //开始计算骰子总和 roll = roll_n_dice(dice, sides); //打印结果 printf(\"total %d , using %d times, %d-sides\\n\", roll, dice, sides); &#125; printf(\"function called : %d\\n\", roll_count); return 0;&#125; 分配内存 malloc与free函数：可以申请所需内存 12345678#include &lt;stdlib.h&gt; //使用时声明double *p;p = (double *) malloc(30 * sizeof(double)); //申请内存块给指针// p为内存的首地址，可以作为数组名使用，比变长数组更灵活free(p); //回收内存，配套使用，如果不使用会造成内存泄露，即耗尽//malloc 可能分配不到内存，放回空指针if( p == NULL ) exit(EXIT_FALLURE); calloc与free函数：和malloc略有区别 123double * p;p = (double *) calloc(30 , sizeof(double)); //把块所有位置设置为0free(p); 存储类别和动态内存分配：自动对象，静态对象，动态对象存储在不同区域 类型限定符 恒常性：const关键字申明的对象不能，赋值，递增或者递减来修改 指针和形参中申明const 12345const float * p; //指向float类型的const值float const * p; //同上float * const p; //常量指针，不能指向其他值const float * const p; //前面2个的结合int sum(const int * p, const int p[]) //两个形参意义相同，表示数组数据不能更改 const 放在左边表示指针指的对象是const，放在右边表示指针是const 对全局使用const：避免数据被更改，2种策略 123456// 外部变量，给其他地方声明const int a = 1; //file1.cextern const int a; //file2.c// 使用头文件static const int a = 1; //file.h#include \"file.h\" //file.c 易变形：volatile 涉及编译器（寄存器）的优化，const和volitile同时使用时顺序不重要 新增：restrict（c99表明指针是唯一访问，并初始的方式）, _Atomic（c11并发程序中要用到的） 新位置：c99加入 12int sum( int * const a, int * restrict b); //旧式int sum( int a[const], int b[restrict]); //新式 小训练：动态分配字符（待调bug） 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define SIZE 20int get_n()&#123; int words; if(scanf(\"%d\", &amp;words) == 1 &amp;&amp; words &gt; 0) return words; else printf(\"enter error!!!\\n\");&#125;void show(char * a[], int n)&#123; int i = 0; while( i++ &lt; n )&#123; puts(a[i-1]); &#125;&#125;int main(void)&#123; int words, i = 0, j = 0; char ch; printf(\"how many words do you wish to enter:\"); words = get_n(); //处理输入的单词数 // char * q [5] = (char (*) [5])malloc( SIZE * 5 * sizeof(char) ); //动态创建 printf(\"enter %d words:\", words); while( (ch = getchar()) != '\\n' )&#123; if(ch == ' ') &#123; char * p = (char *)malloc( i * sizeof(char) ); q[j] = p; free( p ); j++; i = 0; continue; &#125; i++; &#125; show(q, words); free( q ); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"《C primer plus》笔记：文件","slug":"t-book_c_005","date":"2015-07-10T04:58:04.000Z","updated":"2017-10-13T01:56:41.000Z","comments":true,"path":"2015/07/10/t-book_c_005/","link":"","permalink":"http://yoursite.com/2015/07/10/t-book_c_005/","excerpt":"","text":"文件输入输出文件通信 重定向：books &gt; bklist 可能会把不必要的东西输出到文件 文件：一系列连续的字节，文本模式，二进制模式 文件模式：所有文件内容都以二进制形式存储 文本文件：最初使用二进制编码的字符表示文本 二进制文件：二进制值代表机器语言代码或数值数据或图片或音乐编码 不同操作系统处理不同 MS-DOS读文件\\r\\n–&gt;\\n写文件\\n–&gt;\\r\\n I/O级别：底层I/O使用操作系统标准I/O，标准高级I/O使用stdio.h头文件的定义的（通用） 标准文件：C打开3个文件，标准输入（键盘），标准输出，标准准错误输出（显示器） 标准I/O 好处：可移植性强，专门函数简化了操作，输入输出优势缓冲的 演示： 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char * argv[])&#123; int ch; //读取文件,存储每个字符的地方 FILE *fp; //文件指针 unsigned long count = 0; if(argc != 2)&#123; printf(\"Usage: %s filename \\n\", argv[0]); &#125; if( (fp = fopen(argv[1], \"r\")) == NULL )&#123; printf(\"can't open %s\\n\", argv[1]); exit(EXIT_FAILURE); &#125; while( (ch = getc(fp)) != EOF )&#123; putc(ch, stdout); count++; &#125; fclose(fp); printf(\"File %s has %lu characters\\n\", argv[1], count); return 0; &#125; 检查命令行参数：exit()关闭文件并结束程序（0或EXIT_SUCCESS结束成功，EXIT _FALLURE结束失败） fopen函数：打开文件，成功打开后返回文件指针（FILE*） 1FILE * fp = fopen(\"words\", \"r\"); 模式 含义 r 读模式 w 写模式（文件长度截0，可以创建新文件） a 写模式（添加字符，可以创建新文件） r+ 更新模式（读写） w+ 更新模式（读写，截断，创新） a+ 更新模式（读写，添加，创新） *b 二进制文件用法同上 getc和putc函数：与getchar,putchar类似 12ch = getchar(); ch = getc(fp); //文件输入ch = putchar(); ch = putc(fpout) //文件输出 文件结尾：避免读到空文件，使用入口循环 1while( (ch = getc(fp)) != EOF) &#123; putc(fpout); &#125; fclose函数：关闭指定的文件，必要刷新缓冲取区 12if (fclose(fp) != 0 ) //成功放回0,否则返回EOF printf(\"error in closing file %s\\n\", argv[1]); 指向标准文件的指针 标准文件 文件指针 设备 标准输入 stdin 键盘 标准输出 stdou 显示器 标准错误 stder 显示器 文件压缩程序12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define N 40int main(int argc, char * argv[])&#123; FILE *in, *out; int ch; char name[N]; int count; //检查命令行参数 if(argc &lt; 2)&#123; fprintf(stderr, \"Usage:%s filename\\n\", argv[0]); exit(EXIT_FAILURE); &#125; //设置输入 if( (in = fopen(argv[1], \"r\")) == NULL)&#123; fprintf(stderr, \"I could not open this file\\\" %s \\\" \\n \", argv[1]); exit(EXIT_FAILURE); &#125; //设置输出 strncpy(name, argv[1], N - 5); name[N -5] = '\\0'; strcat(name, \".red\"); if( (out = fopen(name, \"w\")) == NULL )&#123; fprintf(stderr, \"I could not open this file\"); exit(3); &#125; //拷贝 while( (ch = getc(in)) != EOF )&#123; if (count++ % 3 == 0) putc(ch, out); &#125; //关闭文件 if( fclose(in) != 0 || fclose(out) != 0 ) fprintf(stderr, \"Error in closing files\\n\"); return 0;&#125; 文件I/O fprinf和fscanf函数：与printf和scanf类似，区别在于，前面需要第一个参数待处理的文件。 12fprintf(fp, \"%s\\n\", words);fscanf(fp, \"%s\\n\", words); fgets和fputs函数： 12fgets(buf, LEN, fp); // buf char型数组的名称，fp指针fputs(buf, fp); 随机访问 fseek() ftell()函数：文件看成数组，fseek返回int.ftell返回long 123456fseek(fp, 0L, SEEK_END); //定位到文件末尾// 1）FILE指针,指向待查找的文件// 2）偏移量，从起始点开始要移动的距离，正负0// 3）模式，SEEK_SET文件开始, SEEK_CUR当前位置，SEEK_END文件末尾// 正常返回0，c出现错误返回-1ftell(fp) //返回当前位置 二进制模式和文本模式： UNIX只有一种文件格式，不需要特殊转换，MS-DOS很多编辑器都是用ctrl+z来标记文件结尾的二进制文件和文本文件模式的另一个不同的地方， MS_DOS用户\\r\\n来标识文件结尾,c程序会把\\r\\n看做成\\n,对于ftell()返回值把\\r\\n当作一个字节来计数 可移植性： 二进制模式中，实现不必支持SEEK_END模式，因此无法保证程序的可移植性，更好的办法是一个一个字节读取整个文件 文本模式中，只有使用fseek才能保证其相应的行为 fgetpos函数，fsetpos函数：新增的定位函数，突破long的限制 1234int fgetpos(FILE * restrict stream, fpos_t * restrict pos); // 成功返回0，失败返回非0// 把fpos_t的值放在pos指向的位置int fsetpos(FILE * stream, const fpos_t * pos); //成功返回0，失败返回非0// 使用fpos_t设置文件指针指向该值指向的位置 标准IO机理12345678910//第一步：调用fopen打开文件//1）自动打开3个标准文件 //2）打开文件 //3）打开一个或者两个缓冲区以及其文件缓冲的数据结构 //4）返回一个指向该结构的指针FILE * fp = fopen(\"words\", \"a+\");//第二步：调用stdio.h中的输入函数//1）文件的数据块被拷贝至缓冲区//2）设置缓冲区大小，设置fp所指向结构中的值（流中当前位置和拷贝进缓冲区的字节数） 其他标准IO函数 函数 作用 int ungetc(int, FILE*) c指定的字符放回输入流 int fflush(FILE*) 刷新缓冲区 int setcbuf(FILE,char , int, size_t) 创建一个供io替换的缓冲区 size_t fread() 二进制out size_t fwirte() 二进制in size_t fwrite函数：返回sizeof运算后的类型 123456size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp);// ptr 待写入的地址，size数据块的大小， nmemb带写入数据块的数量，fp待写入的文件char buffer[256];fwrite(buffer, 256, 1, fp);double earnings[10];fwrite(earings, sizeof(double), 10, fp); size_t fread函数：返回sizeof运算后的类型 123456size_t fwrite(void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp);// ptr 待读取文件数据在内存中的地址，size数据块的大小， nmemb带写入数据块的数量，fp待读取的文件char buffer[256];fwrite(buffer, 256, 1, fp);double earnings[10];fwrite(earings, sizeof(double), 10, fp);","categories":[{"name":"C","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"《C primer plus》笔记：字符串","slug":"t-book_c_004","date":"2015-07-06T12:48:24.000Z","updated":"2017-10-13T01:56:40.000Z","comments":true,"path":"2015/07/06/t-book_c_004/","link":"","permalink":"http://yoursite.com/2015/07/06/t-book_c_004/","excerpt":"","text":"字符串表示字符串和字符串IO123456#define MSG = \"hello world!\";char a[MAX] = \"hello world!\";char * p = \"hello world!\";puts(MSG);puts(a);puts(p); 定义字符串 字符串字面量：双引号括起来的内容，编译器会自动加入\\n，双引号之间紧邻或者空格看作相连的 1char * a = \"hello \" \"world!\"; // hello world! 函数中使用字符串，只存储一次，被视为指向该字符串位置的指针 1printf(\"%s, %p, %c\\n\", \"hello\", \"world\", *\"ok\"); // hello,0X000000999,o 字符串数组：和字符数组区别，两种初始化方式 12345char a[40] = \"sadasfsdfgsdgfdgfdhfdh\"; //简易初始化char a[40] = &#123;'a','b','c'...'g', '\\n'&#125; //标准初始化char a[] = \"dsfsdfsdfdsfsdfsdf\"; //编译器自动计算长度const char * a = \"sdsafsdfsdfsdfsfdf\"; //同上//定长初始化中未被初始化的部分填充'\\0' 数组形式与指针形式区别 数组形式的a == &amp;a[0] 只能作为常量，不能进行a ++等操作，指针形式a 是可以进行a ++的 指针对数据类型匹配很高，指向常量的指针需要被声明为常量const char * p = “abc”; 意味着不能用p改变数据的值，但可以改变p的位置 初始化数组把静态存储区的字符串拷贝给数组，初始化指针只是把字符串的地址给指针 字符串与数组 1234//相当于字符的二维数组char f[3][4] = &#123;&#123;\"ab\"&#125;,&#123;\"cd\"&#125;,&#123;\"e\"&#125;&#125;; // ab\\0, cd\\0, e\\0\\0//相当于3个字符串指针const char * p[3] = &#123;&#123;\"ab\"&#125;,&#123;\"cd\"&#125;,&#123;\"e\"&#125;&#125;; // ab\\0, cd\\0, e\\0 自动获取大小 字符串与指针：指针拷贝也只拷贝地址，没有拷贝整个字符串 字符串输入 分配空间：用显示声明来输入，否则会丢失数据 12char *name; scanf(\"%s\", name); //不好char name[SIZE]; scanf(\"%s\", name); //可以的 gets()函数：已废弃，并不知道字符串有多长，输入字符过长导致缓冲区溢出，可能导致其他数据被擦除 12345678910#include &lt;stdio.h&gt;int main(void)&#123; char name[10]; gets(name); puts(name); return 0;&#125;//gcc 编译没报任何消息//fgdfgdfgdfgfdgfdg//fgdfgdfgdfgfdgfdg 实际情况：大多数编译器仍支持 fgets()函数：可以替代gets(),可扩展，可以从文件输入，保留换行符，需要手动设置为空字符 读一行：读到换行或者读到n个字符，最终打印的n-1个字符123456789#include &lt;stdio.h&gt;int main(void)&#123; char a[10]; fgets(a, 7, stdin); //读了dsfdsf个字符+'\\0' fputs(a, stdout); //输出dsfdsf\\0 没有+'\\n' return 0;&#125;//dsfdsfsdgfdgdffdg //dsfdsf 连续读取，fgets可以存储换行符，读完一段，继续读剩下的，可以直接读到文件尾部123456789#include &lt;stdio.h&gt;#define N 10int main(void)&#123; char word[N]; while( fgets(word, N, stdin) != NULL &amp;&amp; word[0] != '\\n' )&#123; fputs(word, stdout); &#125; return 0;&#125; 每行只读一定数量的字符，并丢弃了换行符 123456789101112131415161718#include &lt;stdio.h&gt;#define N 10int main()&#123; char word[N]; int i; while( fgets(word, N, stdin) != NULL &amp;&amp; word[0] != '\\n')&#123; i = 0; while(word[i] != '\\n' &amp;&amp; word[i] != '\\0') i++; //不是换行符或者空字符跳过 if(word[i] == '\\n') word[i] = '\\0'; //遇到换行符，转空字符 else while(getchar() != '\\n') //读到空字符，丢弃剩余 continue; fputs(word, stdout); &#125; return 0;&#125; 空字符于空指针：空字符(‘\\0’)与空指针(NULL)都可以用0表示，但空字符是字符型(1字节)，空指针是指针型(4字节) gets_s()函数：c11新增，可扩展，只从标准输入中输入，丢弃换行符，输入太长时更安全 s_gets()函数：fgets()变体，遇到换行符设为空，遇到空丢弃其余字符 scanf()函数：可指定宽度，但遇空格即终止，只能用于输入单词 字符串输出 puts()函数：使用字符串地址作参数，自动添加换行符 fputs()函数：用于文件输出，不添加换行符，遇fgets()配对使用 printf()函数：不自动加换行符，打印多个字符更简单 自定义输入输出字符串函数 (类型)函数名 参数 作用 int strlen char * 统计字符串长度 char * strcat char , char 把第二个字符串拼接在第一个上 char * strncat char , char , int 把第二个字符串指定长度添加到第一个字符串上 int strcmp char , char 比较两个字符串，相同返回0，二大于1返回正，否则返回负 int strncmp char , char , int 限定比较的字符串长度 char * strcpy char , char 把第二个拷贝到第一个 char * strcpy char , char int 限制拷贝的字符串长度 void sprintf char *, 格式化, name 将printf的内容存储在一个字符串中 字符串排序 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define SIZE 81 //字符串长度#define LIM 20 //最大行数#define HALT \"\" //读到空字符结束void strSort(char * str [], int num); //排序函数char * strGets(char * , int ); //输入字符串函数int main(void)&#123; char in[LIM][SIZE]; char * pstr[LIM]; int ct = 0, k = 0; //输入输出计数 while(ct &lt; LIM &amp;&amp; strGets(in[ct], SIZE) != NULL &amp;&amp; in[ct][0] != '\\0')&#123; pstr[ct] = in[ct]; ct++; //输入字符串 &#125; strSort(pstr, ct); //排序字符串 for(k = 0; k &lt; ct; k++) puts(pstr[k]); //输出字符串 return 0;&#125;//选择排序void strSort(char * str [], int num)&#123; char *temp; int top, seek; for (top = 0; top &lt; num-1; ++top) &#123; for (seek = top + 1; seek &lt; num; ++seek) &#123; if( strcmp(str[top], str[seek]) &gt; 0 ) temp = str[top]; str[top] = str[seek]; str[seek] = temp; &#125; &#125;&#125;//自定义输入函数char * strGets(char * str, int n)&#123; char * ret_val; int i = 0; ret_val = fgets(str, n, stdin); if(ret_val)&#123; while(str[i] != '\\n' &amp;&amp; str[i] != '\\0') i++; if(str[i] == '\\n') str[i] = '\\0'; else while(getchar() != '\\n') continue; &#125; return ret_val;&#125; 排序单位是指针：排序的是指针而不是字符串本身 选择排序算法 12345678//伪代码for n = 首元素 to n=倒数第2个元素 找出剩余元素中的最大元素，并将其放在第n个元素//C代码for(top = 0; top &lt; n - 1; top++) for(seek = top + 1; seek &lt; n; seek++) if(a[top] &gt; a[seek]) swap(&amp;a[top], &amp;a[seek]); 字符串和ctype.h字符函数12 命令行参数：int argc, char *argv[]12345int main(int argc, char *argv[])&#123; argc // 命令行字符串数量 argv // 字符串数组指针 argv[n] 表示第n个字符串的地址&#125; 123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char * argv[])&#123; int i = argc; printf(\"%d\\n\", argc); while( i-- &gt; 1 ) puts(argv[i]);&#125;// --i情况 (没想到argc = 4) (- -)// test86 see you later 0 1 2 3 // 1) (i = 4- 1 = 3, i &gt; 0) -&gt; a[3]// 2) (i = 3- 1 = 2, i &gt; 0) -&gt; a[2]// i--情况// 1) (i = 4 &gt; 0, i = 3 - 1 = 2) -&gt; a[3]// 2) (i = 3 &gt; 0, i = 2 - 1 = 2) -&gt; a[2]// 3) (i = 2 &gt; 0, i = 1 - 1 = 1) -&gt; a[1] 字符串转数字12 小训练：逆转字符串 1234567891011void reStr(char * a, int n)&#123; int i = 0; char b[n]; while(i++ &lt; n) b[i] = a[i-1]; i = 0; while(n-- &gt;= 0)&#123; a[i] = b[n]; i++; &#125;&#125; 小训练：命令行输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#define N 10void pf(char * , int);void toUpper(char * , int);void toLower(char * , int);int main(int argc, char * argv[])&#123; char a[N]; switch (argv[1][1])&#123; case 'p': pf(a, N); break; case 'u': toUpper(a, N); break; case 'l': toLower(a, N); break; default : puts(\"enter error!\"); break; &#125; return 0;&#125;//原样输出void pf(char * a, int n)&#123; while( fgets(a, n, stdin) != NULL &amp;&amp; a[0] != '\\n')&#123; fputs(a, stdout); &#125; &#125;//输出大写void toLower(char * a, int n)&#123; int i; while( fgets(a, n, stdin) != NULL &amp;&amp; a[0] != '\\n')&#123; i = 0; while(i++ &lt; n-1)&#123; // i=0&lt;9 i=1 a[0], i=1&lt;9 i=2 a[1] ---&gt; i=8&lt;9 i=9 a[8] if(isupper(a[i-1])) a[i-1] = tolower(a[i-1]); &#125; fputs(a, stdout); &#125;&#125;//输出小写void toUpper(char * a, int n)&#123; int i; while( fgets(a, n, stdin) != NULL &amp;&amp; a[0] != '\\n')&#123; i = 0; while(i++ &lt; n-1)&#123; if(islower(a[i-1])) a[i-1] = toupper(a[i-1]); &#125; fputs(a, stdout); &#125;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"《C primer plus》笔记：函数","slug":"t-book_c_003","date":"2015-07-04T13:38:02.000Z","updated":"2017-10-13T01:56:39.000Z","comments":true,"path":"2015/07/04/t-book_c_003/","link":"","permalink":"http://yoursite.com/2015/07/04/t-book_c_003/","excerpt":"","text":"函数复习函数 什么是函数：完成特定任务的独立程序代码单元 函数的作用：省去重复多于代码，提高代码可读性，方便修改 函数的构成： 函数原型：声明函数，告诉编译器函数的类型 函数调用：使用函数 函数定义：实现函数 1234567int fun(char s); //申明函数fun('a'); //调用函数int fun(char s)&#123; return s;&#125; //实现函数 函数形参：局部变量，内部私有，每个变量要求声明类型 1void show(int, int); //也是合法的 函数实参：实参是具体的值, 会赋值给形参 返回值：测试函数的程序称为驱动程序，return语句会终止函数并把控制交给主调函数 无参数：注意加void 1void show(void); 递归 定义：C允许函数调用自己，这种调用称为递归 演示： 1234567891011121314151617181920#include &lt;stdio.h&gt;int up_and_down(int);int main(void)&#123; up_and_down(1); return 0;&#125;int up_and_down(int n)&#123; printf(\"%d, %p\\n\", n, &amp;n); if(n &lt; 4) up_and_down(n+1); printf(\"%d, %p\\n\", n, &amp;n);&#125;// 1, 0060FF20// 2, 0060FF00// 3, 0060FEE0// 4, 0060FEC0// 4, 0060FEC0// 3, 0060FEE0// 2, 0060FF00// 1, 0060FF20 原理： 每次调用都有自己的变量，变量都是n但值不同 每次调用完之后都会返回一次，逐级返回 调用之前的顺序执行，调用之后的倒序返回 没有拷贝函数代码，可以代替循环，可以被i循环代替 必须包含让递归停止的语句 尾递归：递归调用置于函数的末尾，相当于循环，能使用选择循环，莫使用递归（速度，内存优势） 递归和倒序计算 整数化二进制 1234567void to_binary(int n)&#123; int r; r = n % 2; if( n &gt;= 2 ) to_binary( n/2 ); printf(\"%d\", r==0 ? 0 : 1);&#125; 递归优缺点：为很多程序提供了简单的解决方案，但效率和消耗不令人满意 多文件编译 预处理和申明函数放在头文件中 使用命令编译(linux) 12gcc file1.c file2.c //一起编译gcc file1.c file2.o 指针 本质：值为内存地址的变量 作用：存储变量的地址 取地址符&amp;：得到变量的地址 &amp;a 表示a的地址 解引用符：找到存储在地址中的值 &amp;a ==&gt; a 用%p打印地址 声明与赋值：严格区分开 1234int * pi; //声明int型指针pi = &amp;a; //给指针赋值int *pi = &amp;a; //上面两步合并成一步b = *pi; //获取pi所指向地址中存储变量的值并赋值给b 使用指针在函数间通信：函数传值无法真正的改变实参的值，传地址可以改变实参的值。 交换两个整数值： 1234567891011121314#include &lt;stdio.h&gt;void swap(int *, int *);int main(void)&#123; int a = 1, b =2; swap(&amp;a, &amp;b); printf(\"%d, %d\\n\", a, b); return 0;&#125;void swap(int *p, int *q)&#123; int temp; temp = *p; *p = *q; *q = temp;&#125; 小训练1：10进制转任何进制 1234567void to_base_n(int x, int n)&#123; int r; r = x%n; if(x &gt;= n) to_base_n(x/n, n); printf(\"%d\", r );&#125; 小训练2：Fibonacci递归与非递归 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int fibonacciRec(int); //递归int fibonacci(int); //非递归int main(void)&#123; int n; scanf(\"%d\", &amp;n); printf(\"%d\\n\", fibonacciRec(n) ); printf(\"%d\\n\", fibonacci(n) ); return 0;&#125;int fibonacciRec(int n)&#123; if(n == 1 || n == 2) return 1; else return fibonacciRec(n-1) + fibonacciRec(n-2);&#125;int fibonacci(int n)&#123; int i, fib1 = 1, fib2 = 1; if( n == 1 || n == 2) return 1; for(i = 3 ; i &lt;= n; i++)&#123; fib2 = fib1 + fib2; fib1 = fib2 - fib1; &#125; return fib2;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"《C primer plus》笔记：数组","slug":"t-book_c_002","date":"2015-07-03T04:48:33.000Z","updated":"2019-02-26T02:26:10.293Z","comments":true,"path":"2015/07/03/t-book_c_002/","link":"","permalink":"http://yoursite.com/2015/07/03/t-book_c_002/","excerpt":"","text":"数组一维数组 声明：和声明变量一样，但是数组不能直接赋值给它，可以初始化 1int a[10]; 初始化：声明并初始化并非赋值，不允许先声明后直接赋值 12int a[10] = &#123;1，2，3，4，5，6，6，7，7，8&#125;; //可读可写const int b[10] = = &#123;1，2，3，4，5，6，6，7，7，8&#125;;//只读数组 未完全初始化：不初始化，数组里面同变量一样全是垃圾值，如果部分初始化，其余值为0 指定初始化器：C99增加的特性，可以指定某个位置的值 123int a[10] = &#123;1, 2, 3, [4] = 10, 5, 6, [9] = 20&#125;;// 1, 2, 3, 0, 0, 10, 5, 6, 0, 20//直接到指定的值给其赋值，中间未赋值的设置为0 赋值：通过循环依次给数组赋值，不允许作为单元给数组赋值 12for(i=0; i&lt;SIZE; i++) a[i] = i; 边界：使用时要防止下标越界，gcc编译器允许编译，但是越界的值是垃圾值 编译器是相信程序员的，程序员最好声明数组时，用符号常量来表示数组大小 变长数组（VLA）：c90不允许，c99允许，c11可选（不是必备） 12int a = 5;int a[a]; //a为变量，非常量 多维数组 申明：第一个是行，第二个是列 1int a[3][4]; 初始化：2种方式 1234567int a[3][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;;int a[3][4] = &#123; &#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;9, 10, 11, 12&#125; &#125;; // 3行4列 赋值：使用双重循环进行赋值 123for(a = 0; a &lt; ROWS; a++) for( b = 0 ; b &lt; COLS; b++) arr[a][b] = a + b; 指针和数组 指针与数组的联系：数组名是数组首元素的地址,首地址加1是下一个元素的地址 1int a[3]; // a == &amp;a[0]; 123456789101112131415161718192021#include &lt;stdio.h&gt;#define SIZE 10int main()&#123; short a[SIZE] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; double b[SIZE] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; short i, *pa = a; double *pb = b; for (i = 0; i &lt; 2; ++i) &#123; printf(\"pa%d point %p\\n\", i, pa++); &#125; for (i = 0; i &lt; 2; ++i) &#123; printf(\"pb%d point %p\\n\", i, pb++); &#125;&#125;// pa0 point 0060FF00// pa1 point 0060FF02// pb0 point 0060FEB0// pb1 point 0060FEB8 系统中，地址是按字节编址，而在c语言中指针加1是指增加一个存储单元，而不是固定的字节 123a[SIZE]; // a+5 == &amp;a[0+5] *(a+5) == a[5]*a+1 ==&gt; (*a)+1 ==&gt; a[0]+1*(a+1) ==&gt; a[1] 数组的传递 函数原型与定义（数组）：通过传指针的方式，传数组 1234int sum(int *， int); //通过指针传递（数组首地址）int sum(int [], int); //等效1，提醒读者是数组int sum(int * a, int n)&#123;&#125;int sum(int a[], int n)&#123;&#125; 调用数组：传递数组首地址 1sum(a, SIZE); //a为数组名， SZIE为数组大小 指针形参：传2个指针表示数组的开始和结束 12345678int sum(int * start, int * end)&#123; int sum = 0; while(start &lt; end)&#123; sum += *start; start++; &#125; return sum;&#125; 是否可以 sum += *start++ ? 答案是可以的 123456789101112131415161718#include &lt;stdio.h&gt;#define SIZE 4int sum(int * start, int * end)&#123; int sum = 0; while(start &lt; end)&#123; sum += *start++; //分析 * ++（后缀） 同优先级右结合 //步骤分解 1. start先使用用 sum = sum + *start; // 2. start = start + 1; &#125; return sum;&#125;int main(void)&#123; int a[SIZE] = &#123;1, 2 , 3, 4&#125;; printf(\"%d\", sum(a, a+SIZE)); return 0;&#125;// 10 正确 另外两种形式又怎样呢？ 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int a[2] = &#123;1, 2&#125;;int main()&#123; int *p1, *p2, *p3; p1 = p2 = p3 = a; printf(\"%d,%d,%d\\n\", *p1, *p1++, *p1); //分析: 函数中参数的传递的顺序是从右往左传递 // 1.*p1 = 1 ==&gt; no3 = 1 // 2.*p1++ ==&gt; *p1 = 1 , p1 += 1 ==&gt; no2 = 1 // 3.*p1 ==&gt; a[1] ==&gt; no3 = 2 printf(\"%d,%d,%d\\n\", *p2, (*p2)++, *p2); // 1.*p2 = 1 ==&gt; no3 = 1 // 2.(*p2)++ ==&gt; *p2 = a[0], no2 = 1, a[0] = 2 // 3.*p2 = a[0] = 2 ==&gt; no1 = 2; printf(\"%d,%d,%d\\n\", *p3, *++p3, *p3); // 1.*p3 = a[0] ==&gt; no3 = 2 // 2.*++p3 ==&gt; p3= p3+1 = &amp;a[1] =&gt; no2 = *&amp;a[1] = 2 // 3.*p3 = a[1] = 2 ==&gt; no1 = 2 return 0;&#125;// 2 1 1// 2 1 1// 2 2 2 函数中参数的传递的顺序是从右往左传递 指针操作 赋值 解引用 取地址 与整数相加 递增 与整数相减 递减 求差 比较 保护数组数据 原因：通过地址传的数组都是原始数据，可以改变但有些时候不需要改变数组的原始数据 对形参使用const:不需要改变数组内容时，最好加上const 12int sum(coust int *, int); //不能完全保护int sum(const int [], int); //完全保护 const其他内容：const比#define更加灵活，不应该把const数组作实参传递 1234567const double PI = 3.14; //PI值不能被改变const int a[SIZE] = &#123;1,3,4&#125;; //数组值不能被改变const int *p = a; //将int类型声明为const，不能用p来改变a的值//可以用数组改变其值，p也可以指向其他变量int * const p = a; //常量指针不能指向其他地方//可以修改指向的值const int * const p = a; //不能指向其他地方，也不能通过p来改变变量的值 指针和多维数组 首地址之间的关系：a == a[0] == &amp;a[0][0] 值虽然相同，但代表的含义不同 12345678int a[3][4] = &#123; &#123;1,2,3,4&#125; &#123;5,6,7,8&#125; &#123;7,8,9,1&#125; &#125;;// a == &amp;a[0][0]; 二维数组的首地址// a[0] == &amp;a[0][0]; 作为第一个数组名a[0]的首地址也为二维数组的首地址// 即有 a == a[0] 值虽然相同，但代表的含义不同 解引用： 12345a &amp;a[0][0] 二维数组首地址 a+2 &amp;a[2] 二维数组第3个元素地址*(a+2) &amp;a[2][0] 二维数组第3个元素的首地址*(a+2)+1 &amp;a[2][1] 二维数组第3个元素的第二个元素的地址*(*(a+2)+1) a[2][1] 二维数组第3个元素的第二个元素的值 地址步长：a + 1 跨一个数组元素， *a + 1 跨一个数元素 12 指向多维数组的指针：[]优先级高于*,所以一定要加（） 1234int (*p) [2]; //声明含有两个int的数组int a[2][3];p = a; //指向二维数组aint * p[2]; //声明一个含有两个指针的数组 指针兼容性：指针之间类型没有隐式转化，类型不匹配会编译出错 多维数组与函数：形参3种写法,指针式无法省略参数会引发歧义 123int sum(int (*p)[COLS], int ROWS); //指针式int sum(int a[][COLS], int ROWS); //数组式int sum(int [][COLS], int ROWS); //数组略参式 变长数组：变长数组并不能改变大小，只是在初始化的时候可以用变量来初始化大小 123456int sum(int a[rows][cols], int rows, int cols); //无效顺序int sum(int rows, int cols, int a[rows][cols]); //有效int sum(int, int, int a[*][*]); //省略形参名const int SIZE = 80;int sum[SIZE]; c11允许 ,c90好像不允许 复合字面量：C99加入的 { 2，3，4，5，9 } 12345int a[2] = &#123;10 ,20&#125;; //初始化数组(int [2]) &#123;10, 20&#125;; //初始化匿名数组，必须在创建的同时使用它(int []) &#123;10, 20&#125;; //省略大小，编译器自动计算int *p = (int []) &#123;10, 20&#125;; //首地址给指针psum( (int [])&#123;10, 20&#125;, SIZE ); //用作实参 小训练：一维数组3种拷贝函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#define N 5void cp_arr(double [], const double [], int);void cp_ptr(double [], const double *, int);void cp_ptrs(double *, const double *, const double *);void show_arr(double [], int);int main(void)&#123; double source[N] = &#123;1, 2, 3, 4, 5&#125;; double target1[N], target2[N], target3[N]; cp_arr(target1, source, N); cp_ptr(target2, source, N); cp_ptrs(target3, source, source+N); show_arr(target1, N); putchar('\\n'); show_arr(target2, N); putchar('\\n'); show_arr(target3, N); putchar('\\n'); return 0;&#125;void cp_arr(double target[], const double source[], int n)&#123; int i; for (i = 0; i &lt; n; ++i) &#123; target[i] = source[i]; &#125;&#125;void cp_ptr(double target[], const double *source, int n)&#123; int i; for (i = 0; i &lt; n; ++i) &#123; target[i] = *(source+i); &#125;&#125;void cp_ptrs(double target[], const double *source_start, const double *source_end)&#123; while(source_start &lt; source_end)&#123; *target = *source_start++; target++; &#125;&#125;void show_arr(double a[], int n)&#123; int i; for (i = 0; i &lt; n; ++i) &#123; printf(\"%.2lf \", a[i]); &#125;&#125; 小训练：二维数组处理函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define ROWS 3 //行数#define COLS 5 //列数void getArr(double [][COLS] ,int);void averageGroup(double [], const double [][COLS], int);double average(const double [][COLS], int);double max(double [][COLS], int);void swap(double *, double *);void show(double [], int, double, double);int main(void)&#123; double arr[ROWS][COLS] = &#123;0&#125;; double aveGroup[ROWS] = &#123;0&#125;; //注意初始化 double ave = 0; double m = 0; getArr(arr, ROWS); averageGroup(aveGroup, arr, ROWS); ave = average(arr, ROWS); m = max(arr, ROWS); show(aveGroup, ROWS, ave, m); return 0;&#125;//给二维数组赋值void getArr(double a[][COLS], int rows)&#123; int i, j; for (i = 0; i &lt; rows; ++i) for (j = 0; j &lt; COLS; ++j) scanf(\"%lf\", &amp;a[i][j]);&#125;//求每行数据的平均值void averageGroup(double b[], const double a[][COLS], int rows)&#123; int i, j; double sum = 0; for (i = 0; i &lt; rows; ++i)&#123; for (j = 0; j &lt; COLS; ++j) sum += a[i][j]; b[i] = sum/rows; &#125;&#125;//求所有数据的平均值double average(const double a[][COLS], int rows)&#123; int i, j; double sum = 0; for (i = 0; i &lt; rows; ++i) for (j = 0; j &lt; COLS; ++j) sum += a[i][j]; return sum/(COLS*rows);&#125;//求二维数组的最大值double max(double a[][COLS], int rows)&#123; int i, j; for (i = 0; i &lt; rows; ++i) &#123; for (j = 0; j &lt; COLS; ++j) if(a[i][j] &gt; a[i][j+1]) swap(&amp;a[i][j], &amp;a[i][j+1]); if(a[i][j] &gt; a[i+1][j]) swap(&amp;a[i][j], &amp;a[i+1][j]); &#125; return a[i][j];&#125;//打印结果void show(double a[], int size, double av, double m)&#123; int i; for(i = 0; i &lt; size; i++)&#123; printf(\"%.2lf \", a[i]); &#125; printf(\"\\naverage = %.2lf\\n\", av); printf(\"max = %.2lf\\n\", m);&#125;//交换两个变量值void swap(double *p, double *q)&#123; double temp = *p; *p = *q; *q = temp;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"《C primer plus》笔记：C与数据","slug":"t-book_c_001","date":"2015-07-01T13:48:04.000Z","updated":"2017-10-13T01:56:36.000Z","comments":true,"path":"2015/07/01/t-book_c_001/","link":"","permalink":"http://yoursite.com/2015/07/01/t-book_c_001/","excerpt":"","text":"C与数据11种数据类型 整型类：int，short（短整型），long（长整型），unsigned（无符号），char（字符整型） 浮点类：float（单精度），double（双精度） C90新增：signed（有符号），void（空） C99新增：_Bool（布尔指），_Complex（复数），_Imaginary（虚数） 存储单元 位：最小的存储单元，存储0或1 字节：常用存储单位，几乎所有机器有1字节等于8位，即1字节可以表示0-255之间的整数 字：自然存储单位：8位的微型计算机一字为8位，16，32位的为即一字为16位或32位 基本整型类型 int型：储存要占1个机器字长，16位机器，范围-32768 ~ 32767目前大多数机器32位，即占4个字节，存储数字范围为：-2147483648 ~ 2147483647 short型：存储小于等于int，-32768 ~ 32767 long型：储存大于等于int，-2147483648 ~ 2147483647 long long型：存储至少64位，即8个字节 unsigned型：无符号，只能存储正整数，能存储比signed更大的整数 目前普遍设置：long long 64位8字节，long 32位4字节，short 16位2字节，int 16/32位 2/4字节 常量：超出int范围，视为long，超出long范围，视为unsigned long，继续long long, unsigned long long 用H/h作为short，用L/l作为long， 用LL/ll作为long long，用U/u作为unsigned，例如343H，3234L，35455LL，435345U，534546467ULL char型：一个字节，-128 ~ 127，ASCII编码0~127,存储绰绰有余，C语言将字符常量视为int型非char型，是否有符号看编译器 整型可以表示10，8，16进制，如32，032，0x32/0X32 基本浮点类型 float：至少6位有效数字，取值至少10的-37到+37次方。通常浮点占32位，8位指数的值和符号，剩下的24位非指数的值和符号。浮点最大：999999961690316250000000000000000000.000000超过：1.#INF00 double，至少13位有效数字。通常64位，剩下的32位给非指数部分。 long double 更高的精确要求，至少比double精确 复数和虚数类型 复数：float_Complex，double_Complex,long double_Complex 虚数：float_Imaginary，double_Imaginary，long double_Imaginary 类型大小sizeof()函数sizeof(int),sizeof(char)等等…… 问题整型，浮点的上溢出，下溢出？ 字符串与格式化输出输入字符串 string 字符串数组（变量）来存储，char name[40]; 输入scanf(“%s”,name) name是数组首地址 输出printf(“%s”,name) 数组大小sizeof(name) =&gt; 40，可以写成 sizeof name 字符串长度 strlen(name) =&gt;字符实际长度 空字符结尾（\\n） 预处理 define 格式 #define NAME ‘shaosuo’ 注意是简单的替换，没有其他操作 限定符 const 明示常量：limits.h float.h imits/h:包含INT_MAX， INT_MIN 等预处理常量数值h float.h:包含FLT_MAX， FLT_MIN.. 输出函数 printf()转换格式 %a/A 浮点，16进制，p计数 %g/G 自动选择%f，%e %i 有符号10进制整数 %u 无符号10进制整数 %% 打印百分号 %p 指针 %o 无符号8进制 %x 无符号16进制 转换修饰符 标记：-（左对齐），+（添加符号），空格（空格覆盖正号），#（防止0被删除），0（0填充符号位） 宽度：数字（最小字段宽度）（用于字段对齐，右对齐） 精度：.数字 类型：h（short），hh（char），j，l，ll，L（long double），t，z 返回值12345678910#include &lt;stdio.h&gt;int main()&#123; int a = 0, b =0; int pn1 = printf(\"ok!\\n\"); // pn1 = 4 int pn2 = printf(\"ok!,%d,%d\\n\",a, b); // pn2 = 8 int sn1 = scanf(\"%d\", &amp;a, &amp;b); // sn1 = 1 int sn2 = scanf(\"%d%d\", &amp;a, &amp;b); // sn2 = 2 printf(\"pn1=%d, sn1=%d, pn2=%d, sn2=%d\\n\", pn1, sn1, pn2, sn2); return 0;&#125; printf（）返回正确按照格式变量个数，即打印字符的数 scanf（）返回正确按照指定格式接收的变量个数 运算符表达式和语句 基本运算符 算数：（），+（取正），-（取负），+，-，*，/，%（取模），=（赋值） sizeof：如果对象是类型，必须加括号，是变量可以不加，返回字节大小 %取模运算符：如13%5=3，只能用于整数，不能用于浮点数 递增（减）运算符++（–）：前缀与后缀区别，i++ =&gt; 先使用 i，再递增，++ i =&gt; 先递增 i，再使用 类型自动转换 普遍：较小类型转换为较大类型 运算时：两个值被分别两种；类型的更高级别 高低：long double，double，float，unsigned long long，long long，unsigned long， long，unsigned int，int（int和long大小可能相同） 参数传递时，char，short转换成int，float转化成double 赋值语句可能导致类型的升级和降级 类型强制转化 格式：（double）a = （double）1 + (double) 1; 显示使用类型转化比较好，避免不必要的错误控制语句 循环 关系运算符，表达式：&lt;，&lt;=，==，&gt;=，&gt;，!= 真假：非0 即为真 注意：= 赋值，== 比较 优先级关系：x &gt; y + 2 =&gt; x = ( y + 2 ) while语句：非计数循环 123456789#include &lt;stdio.h&gt;int main()&#123; char a[27] = \"abcdefghijklmnopqrstuvwxyz\"; int i = 0; while( i++ &lt; 26)&#123; printf(\"%c\\n\", a[i-1]); //前面+1 ，-1即为真实元素 &#125; return 0;&#125; for语句：计数循环 逗号运算符：结果为右边的值 入口，出口条件：while，do while 嵌套循环 1234567891011121314#include &lt;stdio.h&gt;int main()&#123; char lets[27] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; int i, j; for (i = 0; i &lt; 6; i++) &#123; for (j = 0; j &lt;= i; j++) &#123; printf(\"%c\", lets[i*(i+1)/2+j]); &#125; printf(\"\\n\"); &#125; return 0;&#125; 示例：倒序打印（test47.c） 123456789101112#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAX_LEN 255int main()&#123; char a[MAX_LEN]; scanf(\"%s\", a); int len = strlen(a); while(len-- &gt; 0)&#123; printf(\"%c\", a[len]); &#125; return 0;&#125; 示例：冒泡排序（test43.c） 12345678910111213void bb(int a[])&#123;int i, j;for (i = 0; i &lt; LEN -1; ++i) &#123; for (j = 0; j &lt; LEN - i - 1; ++j) &#123; if(a[j] &lt; a[j+1]) &#123; swap(&amp;a[j], &amp;a[j+1]); &#125; &#125; &#125;&#125; 分支与跳转 选择语句 if……：执行或者跳过这条语句 双选语句 if ……else：在两条语句中进行选择 1234if(n == 0) s = 1;else s = -1; 字符输入输出函数：getchar(),putchar(),它们是#include中的预处理，不是真正的函数 12ch = getchar(); //scanf(\"%c\", &amp;ch);putchar(ch); //printf(\"%c\", ch); ctype.h系列的字符函数：使用时别忘记头文件 函数名 作用 isalnum（） 字母或数组 isalpha（） 字母 isblank（） 空白符 isdigit（） 数字 islower（） 小写字母 isupper（） 大写字母 isxdigit（） 16进制字母 tolower（） 返回小写字母 toupper（） 返回大写字母 多重选择if …… （else if） …… else：在多条语句中选择，完全等价与if else多重嵌套模式 12345678if (score &lt;= 60) score = 6;else if(score &lt;= 70 ) score = 7;else if(score &lt;= 80) score = 8;else score = 10; 逻辑运算符：&amp;&amp;（与）， ||（或），！（非） 替代iso664.h：and，or，not 优先级：！与递增运算符一样，&amp;&amp;大于|| 条件运算符： ？： 1max = a &gt; b ? a : b; 配对：else 与最近的 if 配对 循环辅助continue：程序循环到一部分，可以跳过剩余部分，进行下一轮循环 循环辅助break：程序循环到一部，直接跳出该层循环，进入下一阶段 多重选择switch ……break：可用来替代ifelse，使用break跳出，不往下继续执行 123456789switch (整型表达式)&#123; case 常量1: 语句 case 常量2: 语句 default: 语句&#125; 多重case标签 跳转语句goto：避免使用goto 注意：“==” 不要写成“=”，不要忘记打印结果 123456789101112#include &lt;stdio.h&gt;int main()&#123; char ch, pre; int n = 0; while( (ch = getchar()) != '#' )&#123; if(pre == 'e' &amp;&amp; ch == 'i') //切记 n++; pre = ch; &#125; printf(\"%d\\n\", n); //切记 return 0;&#125; 综合训练：注意，getchar连续输入要去掉\\n，菜单要过滤字符，退出写在循环条件中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;int main()&#123; char choice; float fweight = 0, sweight = 0, tweight = 0; float fcharge = 0, scharge = 0, tcharge = 0; float weight, price, charge, orderCharge, orderWeight, account, extCharge, pay; printf(\"enter a, b, c chooce your goods, q is quit:\\n\"); while ( (choice = getchar()) != 'q' ) &#123; if('\\n' == choice) continue; if( choice == 'a' || choice == 'b' || choice == 'c' ) &#123; switch (choice) &#123; case 'a': price = 2.05; printf(\"please enter want to buy yangli weight:\\n\"); scanf(\"%f\", &amp;weight); ; fweight += weight; fcharge += fweight * price; printf(\"%.2f\\n\", fweight); break; case 'b': price = 1.15; printf(\"please enter want to buy taincai weight:\\n\"); scanf(\"%f\", &amp;weight); sweight += weight; scharge += sweight * price; printf(\"%.2f\\n\", sweight); break; case 'c': price = 1.09; printf(\"please enter want to buy hulubo weight:\\n\"); scanf(\"%f\", &amp;weight); tweight += weight; tcharge += tweight * price; printf(\"%.2f\\n\", tweight); break; default: ; &#125; &#125; else &#123; printf(\"pleae enter 'a', 'b', 'c' !\\n\"); &#125; printf(\"enter a, b, c chooce your goods, q is quit:\\n\"); &#125; orderWeight = fweight + sweight + tweight; orderCharge = fcharge + scharge + tcharge; account = orderCharge &gt; 100 ? orderCharge * 0.05 : 0; if( orderWeight &lt;= 5 ) extCharge = 6.5; else if( orderWeight &lt;= 20) extCharge = 14; else extCharge = 14 + (orderWeight-14) * 0.5; pay = orderCharge + extCharge - account; printf(\"******************* order ******************\\n\"); printf(\"*name-------price------weight-------charge*\\n\"); printf(\"*yang-------$2.05--------%9.2f---------$%9.2f*\\n\", fweight, fcharge); printf(\"*tian-------$1.15--------%9.2f---------$%9.2f*\\n\", sweight, scharge); printf(\"*hulobo-----$1.09--------%9.2f---------$%9.2f*\\n\", tweight, tcharge); printf(\"totalWeight:%.2f, orderCharge:$%.2f\", orderWeight, orderCharge); printf(\"account:$%.2f, extCharge:$%.2f, pay:$%.2f\\n\", account, extCharge, pay); printf(\"*************************************************\\n\"); return 0;&#125; 友好的交互 缓冲区：字符被收集存储的临时存储区（是否有无缓冲输入取决于系统）正常的都是有缓冲输入 123graph LRtypeHI!--&gt;|无缓冲区程序立即使用| HI!typeHI!--&gt;|缓冲区| HI! 结束键盘输入：文件，流，键盘输入 12345678#include &lt;stdio.h&gt;int main()&#123; char ch; while( (ch =getchar()) != '#') &#123; putchar(ch); &#125;&#125; 使用的#字符可能会被我们用到，使用#退出并不一定起作用c语言把输入输出设备，视为文件，stdin流表示键盘输入，stdout流表示显示输出使用文件的形式来结束键盘的输入 文件结尾：Ctrl+Z(曾经操作系统)，存储文件大小信息，EOF（C语言） 1#define EOF -1 //stdio.h定义的 1while( (ch =getchar()) != EOF) getchar（）返回int，可能会报信息，但不影响putchar（）输出字符 正确的使用是找到操作系统，文件终止符识别方案，大多数是Ctrl+D，有些是Ctrl+Z EOF不要加字符的‘’ 重定向和文件：把stdin流重新赋给文件，主要问题与操作系统有关 123testFileIO &lt; words // UNIX与DOS 输入重定向testFileIO &gt; mywords //输出重定向 DOS Ctrl+Z结束，UNIX Ctrl+D结束testFileIO &lt; words &gt; mywords //组合重定向 不能读多个文件，也不能写多个文件，空格不是必须的，写入的会把之前的覆盖掉 友好的用户界面丢弃换行符两种方式比较 12if (ch == '\\n') //当输入的字符为换行符时，直接跳入下一轮循环 continue; 12while( getchar() != '\\n' ) //只要输入的字符不为换行符进入下一轮循环 continue; 问题来了？为什么用第二种不用第一种？ 混合字符数字输入：1.验证输入正确性2.丢弃换行符 12if（2 != scanf(\"%d%d\", &amp;a, &amp;b)） break; 输入验证：事先预测可能输入，检测和处理 1while( scanf(\"%ld\", &amp;n) == 1 &amp;&amp; n &gt; 0 ) //验证正整数 模块化编程：用单独的函数，验证输入和管理显示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;void count();int get_int();char get_first();char get_choice();int main()&#123; char choice; count(); while( (choice = get_choice()) != 'q' )&#123; switch (choice)&#123; case 'a': printf(\"buy low, sell high\\n\"); break; case 'b': printf(\"\\a\\n\"); break; case 'c': count(); break; default: printf(\"error!!!\\n\"); break; &#125; &#125; return 0;&#125;//计数void count()&#123; int n, i; printf(\"Count how far?\\n\"); n = get_int(); for (int i = 0; i &lt;= n; ++i) &#123; printf(\"%d\\n\", i); &#125; while( getchar() != '\\n' ) continue;&#125;//异常处理int get_int()&#123; int n; char ch; while( scanf(\"%d\", &amp;n) != 1 )&#123; while( getchar() != '\\n') putchar(ch); printf(\"is not a integer!!!\\n\"); &#125; return n;&#125;//过滤换行符char get_first()&#123; char choice; choice = getchar(); while( getchar() != '\\n' ) continue; return choice;&#125;//删选合适的字符char get_choice()&#123; char choice; printf(\"please enter a, b, c\\n\"); choice = get_first(); while( (choice &lt; 'a' || choice &gt; 'c') &amp;&amp; choice != 'q')&#123; printf(\"please enter correct code!!\\n\"); choice = get_first(); &#125; return choice;&#125; 实战例子（test57.c）:统计文件字符数 1234567891011121314#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main()&#123; char ch; int count = 0; while( (ch = getchar()) != EOF ) &#123; if(isblank(ch) || ch == '\\n') continue; count++; &#125; printf(\"count : %d\\n\", count); return 0;&#125; 实战例子（test61.c）:二分查找找1-100中的数 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int ran, lower = 1, upper = 100, i = 0; int smart = (lower + upper) / 2; printf(\"please enter 1 ~ 100 a integer:\"); scanf(\"%d\", &amp;ran); while( ran != smart)&#123; if(ran &lt; smart) upper = smart; else lower = smart; i++; printf(\"though %d times = %d\\n\", i, smart); smart = (lower + upper) / 2; &#125; printf(\"though %d times = %d\\n\", i+1, smart); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]}]}